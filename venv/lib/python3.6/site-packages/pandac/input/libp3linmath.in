1578453921
3 3
12 libp3linmath 4 Ns0b 12 panda3d.core 
1549
1966 11 MathNumbers 0 4 3515 24 MathNumbers::MathNumbers 0 2 1 2 0
112
inline MathNumbers::MathNumbers(void) = default;
inline MathNumbers::MathNumbers(MathNumbers const &) = default;

1967 12 ~MathNumbers 0 4 3515 25 MathNumbers::~MathNumbers 0 0 0
32
MathNumbers::~MathNumbers(void);

1968 9 deg_2_rad 0 1 0 9 deg_2_rad 0 2 1876 1877 0
67
inline double deg_2_rad(double f);
inline float deg_2_rad(float f);

1969 9 rad_2_deg 0 1 0 9 rad_2_deg 0 2 1878 1879 0
67
inline double rad_2_deg(double f);
inline float rad_2_deg(float f);

1970 10 LVecBase2f 0 4 3516 22 LVecBase2f::LVecBase2f 0 4 3 4 5 6 22
/**
 *
 */

/**
 *
 */
205
inline LVecBase2f::LVecBase2f(void) = default;
inline LVecBase2f::LVecBase2f(float fill_value);
inline LVecBase2f::LVecBase2f(float x, float y);
inline LVecBase2f::LVecBase2f(LVecBase2f const &) = default;

1971 12 operator new 0 4 3516 24 LVecBase2f::operator new 0 1 7 0
124
inline void *LVecBase2f::operator new(std::size_t size);
inline void *LVecBase2f::operator new(std::size_t size, void *ptr);

1972 15 operator delete 0 4 3516 27 LVecBase2f::operator delete 0 0 0
108
inline void LVecBase2f::operator delete(void *ptr);
inline void LVecBase2f::operator delete(void *, void *);

1973 12 validate_ptr 0 4 3516 24 LVecBase2f::validate_ptr 0 0 0
61
static inline bool LVecBase2f::validate_ptr(void const *ptr);

1974 10 operator = 0 4 3516 22 LVecBase2f::operator = 0 2 8 9 0
119
void LVecBase2f::operator =(LVecBase2f const &copy) = default;
void LVecBase2f::operator =(float fill_value) = default;

1975 4 zero 0 4 3516 16 LVecBase2f::zero 0 1 10 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase2f const &LVecBase2f::zero(void);

1976 6 unit_x 0 4 3516 18 LVecBase2f::unit_x 0 1 11 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase2f const &LVecBase2f::unit_x(void);

1977 6 unit_y 0 4 3516 18 LVecBase2f::unit_y 0 1 12 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase2f const &LVecBase2f::unit_y(void);

1978 10 __reduce__ 0 4 3516 22 LVecBase2f::__reduce__ 0 1 13 0
62
inline PyObject *LVecBase2f::__reduce__(PyObject *self) const;

1979 11 __getattr__ 0 4 3516 23 LVecBase2f::__getattr__ 0 1 14 0
93
inline PyObject *LVecBase2f::__getattr__(PyObject *self, std::string const &attr_name) const;

1980 11 __setattr__ 0 4 3516 23 LVecBase2f::__setattr__ 0 1 15 0
99
inline int LVecBase2f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

1981 11 operator [] 0 4 3516 23 LVecBase2f::operator [] 0 2 16 17 10
/**
 *
 */
96
inline float LVecBase2f::operator [](int i) const;
inline float &LVecBase2f::operator [](int i);

1982 4 size 0 4 3516 16 LVecBase2f::size 0 1 18 0
44
static constexpr int LVecBase2f::size(void);

1983 6 is_nan 0 4 3516 18 LVecBase2f::is_nan 0 1 19 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase2f::is_nan(void) const;

1984 8 get_cell 0 4 3516 20 LVecBase2f::get_cell 0 1 20 10
/**
 *
 */
47
inline float LVecBase2f::get_cell(int i) const;

1985 8 set_cell 0 4 3516 20 LVecBase2f::set_cell 0 1 21 10
/**
 *
 */
53
inline void LVecBase2f::set_cell(int i, float value);

1986 5 get_x 0 4 3516 17 LVecBase2f::get_x 0 1 22 10
/**
 *
 */
43
inline float LVecBase2f::get_x(void) const;

1987 5 get_y 0 4 3516 17 LVecBase2f::get_y 0 1 23 10
/**
 *
 */
43
inline float LVecBase2f::get_y(void) const;

1988 5 set_x 0 4 3516 17 LVecBase2f::set_x 0 1 24 10
/**
 *
 */
43
inline void LVecBase2f::set_x(float value);

1989 5 set_y 0 4 3516 17 LVecBase2f::set_y 0 1 25 10
/**
 *
 */
43
inline void LVecBase2f::set_y(float value);

1990 11 add_to_cell 0 4 3516 23 LVecBase2f::add_to_cell 0 1 26 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
56
inline void LVecBase2f::add_to_cell(int i, float value);

1991 5 add_x 0 4 3516 17 LVecBase2f::add_x 0 1 27 10
/**
 *
 */
43
inline void LVecBase2f::add_x(float value);

1992 5 add_y 0 4 3516 17 LVecBase2f::add_y 0 1 28 10
/**
 *
 */
43
inline void LVecBase2f::add_y(float value);

1993 8 get_data 0 4 3516 20 LVecBase2f::get_data 0 1 29 155
/**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */
53
inline float const *LVecBase2f::get_data(void) const;

1994 18 get_num_components 0 4 3516 30 LVecBase2f::get_num_components 0 1 30 0
58
static constexpr int LVecBase2f::get_num_components(void);

1995 4 fill 0 4 3516 16 LVecBase2f::fill 0 1 31 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
47
inline void LVecBase2f::fill(float fill_value);

1996 3 set 0 4 3516 15 LVecBase2f::set 0 1 32 10
/**
 *
 */
46
inline void LVecBase2f::set(float x, float y);

1997 3 dot 0 4 3516 15 LVecBase2f::dot 0 1 33 10
/**
 *
 */
60
inline float LVecBase2f::dot(LVecBase2f const &other) const;

1998 14 length_squared 0 4 3516 26 LVecBase2f::length_squared 0 1 34 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
52
inline float LVecBase2f::length_squared(void) const;

1999 6 length 0 4 3516 18 LVecBase2f::length 0 1 35 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
44
inline float LVecBase2f::length(void) const;

2000 9 normalize 0 4 3516 21 LVecBase2f::normalize 0 1 36 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase2f::normalize(void);

2001 10 normalized 0 4 3516 22 LVecBase2f::normalized 0 1 37 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase2f LVecBase2f::normalized(void) const;

2002 7 project 0 4 3516 19 LVecBase2f::project 0 1 38 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase2f LVecBase2f::project(LVecBase2f const &onto) const;

2003 10 operator < 0 4 3516 22 LVecBase2f::operator < 0 1 39 0
66
inline bool LVecBase2f::operator <(LVecBase2f const &other) const;

2004 11 operator == 0 4 3516 23 LVecBase2f::operator == 0 1 40 0
67
inline bool LVecBase2f::operator ==(LVecBase2f const &other) const;

2005 11 operator != 0 4 3516 23 LVecBase2f::operator != 0 1 41 0
67
inline bool LVecBase2f::operator !=(LVecBase2f const &other) const;

2006 10 compare_to 0 4 3516 22 LVecBase2f::compare_to 0 2 42 43 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
148
inline int LVecBase2f::compare_to(LVecBase2f const &other) const;
inline int LVecBase2f::compare_to(LVecBase2f const &other, float threshold) const;

2007 8 get_hash 0 4 3516 20 LVecBase2f::get_hash 0 2 44 45 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
116
inline std::size_t LVecBase2f::get_hash(void) const;
inline std::size_t LVecBase2f::get_hash(float threshold) const;

2008 8 add_hash 0 4 3516 20 LVecBase2f::add_hash 0 2 46 47 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
146
inline std::size_t LVecBase2f::add_hash(std::size_t hash) const;
inline std::size_t LVecBase2f::add_hash(std::size_t hash, float threshold) const;

2009 13 generate_hash 0 4 3516 25 LVecBase2f::generate_hash 0 2 48 49 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
170
inline void LVecBase2f::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase2f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

2010 10 operator - 0 68 3516 22 LVecBase2f::operator - 0 1 50 0
53
inline LVecBase2f LVecBase2f::operator -(void) const;

2011 10 operator + 0 4 3516 22 LVecBase2f::operator + 0 1 51 0
72
inline LVecBase2f LVecBase2f::operator +(LVecBase2f const &other) const;

2012 10 operator - 0 4 3516 22 LVecBase2f::operator - 0 1 52 0
72
inline LVecBase2f LVecBase2f::operator -(LVecBase2f const &other) const;

2013 10 operator * 0 4 3516 22 LVecBase2f::operator * 0 1 53 0
61
inline LVecBase2f LVecBase2f::operator *(float scalar) const;

2014 10 operator / 0 4 3516 22 LVecBase2f::operator / 0 1 54 0
61
inline LVecBase2f LVecBase2f::operator /(float scalar) const;

2015 11 operator += 0 4 3516 23 LVecBase2f::operator += 0 1 55 0
61
inline void LVecBase2f::operator +=(LVecBase2f const &other);

2016 11 operator -= 0 4 3516 23 LVecBase2f::operator -= 0 1 56 0
61
inline void LVecBase2f::operator -=(LVecBase2f const &other);

2017 11 operator *= 0 4 3516 23 LVecBase2f::operator *= 0 1 57 0
50
inline void LVecBase2f::operator *=(float scalar);

2018 11 operator /= 0 4 3516 23 LVecBase2f::operator /= 0 1 58 0
50
inline void LVecBase2f::operator /=(float scalar);

2019 18 componentwise_mult 0 4 3516 30 LVecBase2f::componentwise_mult 0 1 59 10
/**
 *
 */
68
inline void LVecBase2f::componentwise_mult(LVecBase2f const &other);

2020 7 __pow__ 0 4 3516 19 LVecBase2f::__pow__ 0 1 60 0
60
inline LVecBase2f LVecBase2f::__pow__(float exponent) const;

2021 8 __ipow__ 0 4 3516 20 LVecBase2f::__ipow__ 0 1 61 0
70
inline PyObject *LVecBase2f::__ipow__(PyObject *self, float exponent);

2022 4 fmax 0 4 3516 16 LVecBase2f::fmax 0 1 62 10
/**
 *
 */
66
inline LVecBase2f LVecBase2f::fmax(LVecBase2f const &other) const;

2023 4 fmin 0 4 3516 16 LVecBase2f::fmin 0 1 63 10
/**
 *
 */
66
inline LVecBase2f LVecBase2f::fmin(LVecBase2f const &other) const;

2024 12 almost_equal 0 4 3516 24 LVecBase2f::almost_equal 0 2 64 65 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
154
inline bool LVecBase2f::almost_equal(LVecBase2f const &other, float threshold) const;
inline bool LVecBase2f::almost_equal(LVecBase2f const &other) const;

2025 6 output 0 4 3516 18 LVecBase2f::output 0 1 66 10
/**
 *
 */
56
inline void LVecBase2f::output(std::ostream &out) const;

2026 8 __repr__ 0 4 3516 20 LVecBase2f::__repr__ 0 1 67 0
52
inline std::string LVecBase2f::__repr__(void) const;

2027 20 write_datagram_fixed 0 4 3516 32 LVecBase2f::write_datagram_fixed 0 1 68 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase2f::write_datagram_fixed(Datagram &destination) const;

2028 19 read_datagram_fixed 0 4 3516 31 LVecBase2f::read_datagram_fixed 0 1 69 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase2f::read_datagram_fixed(DatagramIterator &source);

2029 14 write_datagram 0 4 3516 26 LVecBase2f::write_datagram 0 1 70 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase2f::write_datagram(Datagram &destination) const;

2030 13 read_datagram 0 4 3516 25 LVecBase2f::read_datagram 0 1 71 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase2f::read_datagram(DatagramIterator &source);

2031 14 get_class_type 0 4 3516 26 LVecBase2f::get_class_type 0 1 72 0
51
static TypeHandle LVecBase2f::get_class_type(void);

2032 11 ~LVecBase2f 0 4 3516 23 LVecBase2f::~LVecBase2f 0 0 0
30
LVecBase2f::~LVecBase2f(void);

2033 10 LVecBase2d 0 4 3519 22 LVecBase2d::LVecBase2d 0 4 73 74 75 76 22
/**
 *
 */

/**
 *
 */
208
inline LVecBase2d::LVecBase2d(void) = default;
inline LVecBase2d::LVecBase2d(double fill_value);
inline LVecBase2d::LVecBase2d(double x, double y);
inline LVecBase2d::LVecBase2d(LVecBase2d const &) = default;

2034 12 operator new 0 4 3519 24 LVecBase2d::operator new 0 1 77 0
124
inline void *LVecBase2d::operator new(std::size_t size);
inline void *LVecBase2d::operator new(std::size_t size, void *ptr);

2035 15 operator delete 0 4 3519 27 LVecBase2d::operator delete 0 0 0
108
inline void LVecBase2d::operator delete(void *ptr);
inline void LVecBase2d::operator delete(void *, void *);

2036 12 validate_ptr 0 4 3519 24 LVecBase2d::validate_ptr 0 0 0
61
static inline bool LVecBase2d::validate_ptr(void const *ptr);

2037 10 operator = 0 4 3519 22 LVecBase2d::operator = 0 2 78 79 0
120
void LVecBase2d::operator =(LVecBase2d const &copy) = default;
void LVecBase2d::operator =(double fill_value) = default;

2038 4 zero 0 4 3519 16 LVecBase2d::zero 0 1 80 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase2d const &LVecBase2d::zero(void);

2039 6 unit_x 0 4 3519 18 LVecBase2d::unit_x 0 1 81 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase2d const &LVecBase2d::unit_x(void);

2040 6 unit_y 0 4 3519 18 LVecBase2d::unit_y 0 1 82 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase2d const &LVecBase2d::unit_y(void);

2041 10 __reduce__ 0 4 3519 22 LVecBase2d::__reduce__ 0 1 83 0
62
inline PyObject *LVecBase2d::__reduce__(PyObject *self) const;

2042 11 __getattr__ 0 4 3519 23 LVecBase2d::__getattr__ 0 1 84 0
93
inline PyObject *LVecBase2d::__getattr__(PyObject *self, std::string const &attr_name) const;

2043 11 __setattr__ 0 4 3519 23 LVecBase2d::__setattr__ 0 1 85 0
99
inline int LVecBase2d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2044 11 operator [] 0 4 3519 23 LVecBase2d::operator [] 0 2 86 87 10
/**
 *
 */
98
inline double LVecBase2d::operator [](int i) const;
inline double &LVecBase2d::operator [](int i);

2045 4 size 0 4 3519 16 LVecBase2d::size 0 1 88 0
44
static constexpr int LVecBase2d::size(void);

2046 6 is_nan 0 4 3519 18 LVecBase2d::is_nan 0 1 89 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase2d::is_nan(void) const;

2047 8 get_cell 0 4 3519 20 LVecBase2d::get_cell 0 1 90 10
/**
 *
 */
48
inline double LVecBase2d::get_cell(int i) const;

2048 8 set_cell 0 4 3519 20 LVecBase2d::set_cell 0 1 91 10
/**
 *
 */
54
inline void LVecBase2d::set_cell(int i, double value);

2049 5 get_x 0 4 3519 17 LVecBase2d::get_x 0 1 92 10
/**
 *
 */
44
inline double LVecBase2d::get_x(void) const;

2050 5 get_y 0 4 3519 17 LVecBase2d::get_y 0 1 93 10
/**
 *
 */
44
inline double LVecBase2d::get_y(void) const;

2051 5 set_x 0 4 3519 17 LVecBase2d::set_x 0 1 94 10
/**
 *
 */
44
inline void LVecBase2d::set_x(double value);

2052 5 set_y 0 4 3519 17 LVecBase2d::set_y 0 1 95 10
/**
 *
 */
44
inline void LVecBase2d::set_y(double value);

2053 11 add_to_cell 0 4 3519 23 LVecBase2d::add_to_cell 0 1 96 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
57
inline void LVecBase2d::add_to_cell(int i, double value);

2054 5 add_x 0 4 3519 17 LVecBase2d::add_x 0 1 97 10
/**
 *
 */
44
inline void LVecBase2d::add_x(double value);

2055 5 add_y 0 4 3519 17 LVecBase2d::add_y 0 1 98 10
/**
 *
 */
44
inline void LVecBase2d::add_y(double value);

2056 8 get_data 0 4 3519 20 LVecBase2d::get_data 0 1 99 155
/**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */
54
inline double const *LVecBase2d::get_data(void) const;

2057 18 get_num_components 0 4 3519 30 LVecBase2d::get_num_components 0 1 100 0
58
static constexpr int LVecBase2d::get_num_components(void);

2058 4 fill 0 4 3519 16 LVecBase2d::fill 0 1 101 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
48
inline void LVecBase2d::fill(double fill_value);

2059 3 set 0 4 3519 15 LVecBase2d::set 0 1 102 10
/**
 *
 */
48
inline void LVecBase2d::set(double x, double y);

2060 3 dot 0 4 3519 15 LVecBase2d::dot 0 1 103 10
/**
 *
 */
61
inline double LVecBase2d::dot(LVecBase2d const &other) const;

2061 14 length_squared 0 4 3519 26 LVecBase2d::length_squared 0 1 104 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
53
inline double LVecBase2d::length_squared(void) const;

2062 6 length 0 4 3519 18 LVecBase2d::length 0 1 105 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
45
inline double LVecBase2d::length(void) const;

2063 9 normalize 0 4 3519 21 LVecBase2d::normalize 0 1 106 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase2d::normalize(void);

2064 10 normalized 0 4 3519 22 LVecBase2d::normalized 0 1 107 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase2d LVecBase2d::normalized(void) const;

2065 7 project 0 4 3519 19 LVecBase2d::project 0 1 108 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase2d LVecBase2d::project(LVecBase2d const &onto) const;

2066 10 operator < 0 4 3519 22 LVecBase2d::operator < 0 1 109 0
66
inline bool LVecBase2d::operator <(LVecBase2d const &other) const;

2067 11 operator == 0 4 3519 23 LVecBase2d::operator == 0 1 110 0
67
inline bool LVecBase2d::operator ==(LVecBase2d const &other) const;

2068 11 operator != 0 4 3519 23 LVecBase2d::operator != 0 1 111 0
67
inline bool LVecBase2d::operator !=(LVecBase2d const &other) const;

2069 10 compare_to 0 4 3519 22 LVecBase2d::compare_to 0 2 112 113 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
149
inline int LVecBase2d::compare_to(LVecBase2d const &other) const;
inline int LVecBase2d::compare_to(LVecBase2d const &other, double threshold) const;

2070 8 get_hash 0 4 3519 20 LVecBase2d::get_hash 0 2 114 115 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
117
inline std::size_t LVecBase2d::get_hash(void) const;
inline std::size_t LVecBase2d::get_hash(double threshold) const;

2071 8 add_hash 0 4 3519 20 LVecBase2d::add_hash 0 2 116 117 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
147
inline std::size_t LVecBase2d::add_hash(std::size_t hash) const;
inline std::size_t LVecBase2d::add_hash(std::size_t hash, double threshold) const;

2072 13 generate_hash 0 4 3519 25 LVecBase2d::generate_hash 0 2 118 119 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
171
inline void LVecBase2d::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase2d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

2073 10 operator - 0 68 3519 22 LVecBase2d::operator - 0 1 120 0
53
inline LVecBase2d LVecBase2d::operator -(void) const;

2074 10 operator + 0 4 3519 22 LVecBase2d::operator + 0 1 121 0
72
inline LVecBase2d LVecBase2d::operator +(LVecBase2d const &other) const;

2075 10 operator - 0 4 3519 22 LVecBase2d::operator - 0 1 122 0
72
inline LVecBase2d LVecBase2d::operator -(LVecBase2d const &other) const;

2076 10 operator * 0 4 3519 22 LVecBase2d::operator * 0 1 123 0
62
inline LVecBase2d LVecBase2d::operator *(double scalar) const;

2077 10 operator / 0 4 3519 22 LVecBase2d::operator / 0 1 124 0
62
inline LVecBase2d LVecBase2d::operator /(double scalar) const;

2078 11 operator += 0 4 3519 23 LVecBase2d::operator += 0 1 125 0
61
inline void LVecBase2d::operator +=(LVecBase2d const &other);

2079 11 operator -= 0 4 3519 23 LVecBase2d::operator -= 0 1 126 0
61
inline void LVecBase2d::operator -=(LVecBase2d const &other);

2080 11 operator *= 0 4 3519 23 LVecBase2d::operator *= 0 1 127 0
51
inline void LVecBase2d::operator *=(double scalar);

2081 11 operator /= 0 4 3519 23 LVecBase2d::operator /= 0 1 128 0
51
inline void LVecBase2d::operator /=(double scalar);

2082 18 componentwise_mult 0 4 3519 30 LVecBase2d::componentwise_mult 0 1 129 10
/**
 *
 */
68
inline void LVecBase2d::componentwise_mult(LVecBase2d const &other);

2083 7 __pow__ 0 4 3519 19 LVecBase2d::__pow__ 0 1 130 0
61
inline LVecBase2d LVecBase2d::__pow__(double exponent) const;

2084 8 __ipow__ 0 4 3519 20 LVecBase2d::__ipow__ 0 1 131 0
71
inline PyObject *LVecBase2d::__ipow__(PyObject *self, double exponent);

2085 4 fmax 0 4 3519 16 LVecBase2d::fmax 0 1 132 10
/**
 *
 */
66
inline LVecBase2d LVecBase2d::fmax(LVecBase2d const &other) const;

2086 4 fmin 0 4 3519 16 LVecBase2d::fmin 0 1 133 10
/**
 *
 */
66
inline LVecBase2d LVecBase2d::fmin(LVecBase2d const &other) const;

2087 12 almost_equal 0 4 3519 24 LVecBase2d::almost_equal 0 2 134 135 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
155
inline bool LVecBase2d::almost_equal(LVecBase2d const &other, double threshold) const;
inline bool LVecBase2d::almost_equal(LVecBase2d const &other) const;

2088 6 output 0 4 3519 18 LVecBase2d::output 0 1 136 10
/**
 *
 */
56
inline void LVecBase2d::output(std::ostream &out) const;

2089 8 __repr__ 0 4 3519 20 LVecBase2d::__repr__ 0 1 137 0
52
inline std::string LVecBase2d::__repr__(void) const;

2090 20 write_datagram_fixed 0 4 3519 32 LVecBase2d::write_datagram_fixed 0 1 138 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase2d::write_datagram_fixed(Datagram &destination) const;

2091 19 read_datagram_fixed 0 4 3519 31 LVecBase2d::read_datagram_fixed 0 1 139 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase2d::read_datagram_fixed(DatagramIterator &source);

2092 14 write_datagram 0 4 3519 26 LVecBase2d::write_datagram 0 1 140 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase2d::write_datagram(Datagram &destination) const;

2093 13 read_datagram 0 4 3519 25 LVecBase2d::read_datagram 0 1 141 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase2d::read_datagram(DatagramIterator &source);

2094 14 get_class_type 0 4 3519 26 LVecBase2d::get_class_type 0 1 142 0
51
static TypeHandle LVecBase2d::get_class_type(void);

2095 11 ~LVecBase2d 0 4 3519 23 LVecBase2d::~LVecBase2d 0 0 0
30
LVecBase2d::~LVecBase2d(void);

2096 10 LVecBase2i 0 4 3522 22 LVecBase2i::LVecBase2i 0 4 143 144 145 146 22
/**
 *
 */

/**
 *
 */
199
inline LVecBase2i::LVecBase2i(void) = default;
inline LVecBase2i::LVecBase2i(int fill_value);
inline LVecBase2i::LVecBase2i(int x, int y);
inline LVecBase2i::LVecBase2i(LVecBase2i const &) = default;

2097 12 operator new 0 4 3522 24 LVecBase2i::operator new 0 1 147 0
124
inline void *LVecBase2i::operator new(std::size_t size);
inline void *LVecBase2i::operator new(std::size_t size, void *ptr);

2098 15 operator delete 0 4 3522 27 LVecBase2i::operator delete 0 0 0
108
inline void LVecBase2i::operator delete(void *ptr);
inline void LVecBase2i::operator delete(void *, void *);

2099 12 validate_ptr 0 4 3522 24 LVecBase2i::validate_ptr 0 0 0
61
static inline bool LVecBase2i::validate_ptr(void const *ptr);

2100 10 operator = 0 4 3522 22 LVecBase2i::operator = 0 2 148 149 0
117
void LVecBase2i::operator =(LVecBase2i const &copy) = default;
void LVecBase2i::operator =(int fill_value) = default;

2101 4 zero 0 4 3522 16 LVecBase2i::zero 0 1 150 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase2i const &LVecBase2i::zero(void);

2102 6 unit_x 0 4 3522 18 LVecBase2i::unit_x 0 1 151 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase2i const &LVecBase2i::unit_x(void);

2103 6 unit_y 0 4 3522 18 LVecBase2i::unit_y 0 1 152 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase2i const &LVecBase2i::unit_y(void);

2104 10 __reduce__ 0 4 3522 22 LVecBase2i::__reduce__ 0 1 153 0
62
inline PyObject *LVecBase2i::__reduce__(PyObject *self) const;

2105 11 __getattr__ 0 4 3522 23 LVecBase2i::__getattr__ 0 1 154 0
93
inline PyObject *LVecBase2i::__getattr__(PyObject *self, std::string const &attr_name) const;

2106 11 __setattr__ 0 4 3522 23 LVecBase2i::__setattr__ 0 1 155 0
99
inline int LVecBase2i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2107 11 operator [] 0 4 3522 23 LVecBase2i::operator [] 0 2 156 157 10
/**
 *
 */
92
inline int LVecBase2i::operator [](int i) const;
inline int &LVecBase2i::operator [](int i);

2108 4 size 0 4 3522 16 LVecBase2i::size 0 1 158 0
44
static constexpr int LVecBase2i::size(void);

2109 6 is_nan 0 4 3522 18 LVecBase2i::is_nan 0 1 159 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase2i::is_nan(void) const;

2110 8 get_cell 0 4 3522 20 LVecBase2i::get_cell 0 1 160 10
/**
 *
 */
45
inline int LVecBase2i::get_cell(int i) const;

2111 8 set_cell 0 4 3522 20 LVecBase2i::set_cell 0 1 161 10
/**
 *
 */
51
inline void LVecBase2i::set_cell(int i, int value);

2112 5 get_x 0 4 3522 17 LVecBase2i::get_x 0 1 162 10
/**
 *
 */
41
inline int LVecBase2i::get_x(void) const;

2113 5 get_y 0 4 3522 17 LVecBase2i::get_y 0 1 163 10
/**
 *
 */
41
inline int LVecBase2i::get_y(void) const;

2114 5 set_x 0 4 3522 17 LVecBase2i::set_x 0 1 164 10
/**
 *
 */
41
inline void LVecBase2i::set_x(int value);

2115 5 set_y 0 4 3522 17 LVecBase2i::set_y 0 1 165 10
/**
 *
 */
41
inline void LVecBase2i::set_y(int value);

2116 11 add_to_cell 0 4 3522 23 LVecBase2i::add_to_cell 0 1 166 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
54
inline void LVecBase2i::add_to_cell(int i, int value);

2117 5 add_x 0 4 3522 17 LVecBase2i::add_x 0 1 167 10
/**
 *
 */
41
inline void LVecBase2i::add_x(int value);

2118 5 add_y 0 4 3522 17 LVecBase2i::add_y 0 1 168 10
/**
 *
 */
41
inline void LVecBase2i::add_y(int value);

2119 8 get_data 0 4 3522 20 LVecBase2i::get_data 0 1 169 155
/**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */
51
inline int const *LVecBase2i::get_data(void) const;

2120 18 get_num_components 0 4 3522 30 LVecBase2i::get_num_components 0 1 170 0
58
static constexpr int LVecBase2i::get_num_components(void);

2121 4 fill 0 4 3522 16 LVecBase2i::fill 0 1 171 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
45
inline void LVecBase2i::fill(int fill_value);

2122 3 set 0 4 3522 15 LVecBase2i::set 0 1 172 10
/**
 *
 */
42
inline void LVecBase2i::set(int x, int y);

2123 3 dot 0 4 3522 15 LVecBase2i::dot 0 1 173 10
/**
 *
 */
58
inline int LVecBase2i::dot(LVecBase2i const &other) const;

2124 14 length_squared 0 4 3522 26 LVecBase2i::length_squared 0 1 174 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
50
inline int LVecBase2i::length_squared(void) const;

2125 10 operator < 0 4 3522 22 LVecBase2i::operator < 0 1 175 0
66
inline bool LVecBase2i::operator <(LVecBase2i const &other) const;

2126 11 operator == 0 4 3522 23 LVecBase2i::operator == 0 1 176 0
67
inline bool LVecBase2i::operator ==(LVecBase2i const &other) const;

2127 11 operator != 0 4 3522 23 LVecBase2i::operator != 0 1 177 0
67
inline bool LVecBase2i::operator !=(LVecBase2i const &other) const;

2128 10 compare_to 0 4 3522 22 LVecBase2i::compare_to 0 1 178 97
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */
65
inline int LVecBase2i::compare_to(LVecBase2i const &other) const;

2129 8 get_hash 0 4 3522 20 LVecBase2i::get_hash 0 1 179 49
/**
 * Returns a suitable hash for phash_map.
 */
52
inline std::size_t LVecBase2i::get_hash(void) const;

2130 8 add_hash 0 4 3522 20 LVecBase2i::add_hash 0 1 180 49
/**
 * Adds the vector into the running hash.
 */
64
inline std::size_t LVecBase2i::add_hash(std::size_t hash) const;

2131 13 generate_hash 0 4 3522 25 LVecBase2i::generate_hash 0 1 181 59
/**
 * Adds the vector to the indicated hash generator.
 */
76
inline void LVecBase2i::generate_hash(ChecksumHashGenerator &hashgen) const;

2132 10 operator - 0 68 3522 22 LVecBase2i::operator - 0 1 182 0
53
inline LVecBase2i LVecBase2i::operator -(void) const;

2133 10 operator + 0 4 3522 22 LVecBase2i::operator + 0 1 183 0
72
inline LVecBase2i LVecBase2i::operator +(LVecBase2i const &other) const;

2134 10 operator - 0 4 3522 22 LVecBase2i::operator - 0 1 184 0
72
inline LVecBase2i LVecBase2i::operator -(LVecBase2i const &other) const;

2135 10 operator * 0 4 3522 22 LVecBase2i::operator * 0 1 185 0
59
inline LVecBase2i LVecBase2i::operator *(int scalar) const;

2136 10 operator / 0 4 3522 22 LVecBase2i::operator / 0 1 186 0
59
inline LVecBase2i LVecBase2i::operator /(int scalar) const;

2137 11 operator += 0 4 3522 23 LVecBase2i::operator += 0 1 187 0
61
inline void LVecBase2i::operator +=(LVecBase2i const &other);

2138 11 operator -= 0 4 3522 23 LVecBase2i::operator -= 0 1 188 0
61
inline void LVecBase2i::operator -=(LVecBase2i const &other);

2139 11 operator *= 0 4 3522 23 LVecBase2i::operator *= 0 1 189 0
48
inline void LVecBase2i::operator *=(int scalar);

2140 11 operator /= 0 4 3522 23 LVecBase2i::operator /= 0 1 190 0
48
inline void LVecBase2i::operator /=(int scalar);

2141 18 componentwise_mult 0 4 3522 30 LVecBase2i::componentwise_mult 0 1 191 10
/**
 *
 */
68
inline void LVecBase2i::componentwise_mult(LVecBase2i const &other);

2142 7 __pow__ 0 4 3522 19 LVecBase2i::__pow__ 0 1 192 0
58
inline LVecBase2i LVecBase2i::__pow__(int exponent) const;

2143 8 __ipow__ 0 4 3522 20 LVecBase2i::__ipow__ 0 1 193 0
68
inline PyObject *LVecBase2i::__ipow__(PyObject *self, int exponent);

2144 4 fmax 0 4 3522 16 LVecBase2i::fmax 0 1 194 10
/**
 *
 */
66
inline LVecBase2i LVecBase2i::fmax(LVecBase2i const &other) const;

2145 4 fmin 0 4 3522 16 LVecBase2i::fmin 0 1 195 10
/**
 *
 */
66
inline LVecBase2i LVecBase2i::fmin(LVecBase2i const &other) const;

2146 12 almost_equal 0 4 3522 24 LVecBase2i::almost_equal 0 2 196 197 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
152
inline bool LVecBase2i::almost_equal(LVecBase2i const &other, int threshold) const;
inline bool LVecBase2i::almost_equal(LVecBase2i const &other) const;

2147 6 output 0 4 3522 18 LVecBase2i::output 0 1 198 10
/**
 *
 */
56
inline void LVecBase2i::output(std::ostream &out) const;

2148 8 __repr__ 0 4 3522 20 LVecBase2i::__repr__ 0 1 199 0
52
inline std::string LVecBase2i::__repr__(void) const;

2149 20 write_datagram_fixed 0 4 3522 32 LVecBase2i::write_datagram_fixed 0 1 200 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase2i::write_datagram_fixed(Datagram &destination) const;

2150 19 read_datagram_fixed 0 4 3522 31 LVecBase2i::read_datagram_fixed 0 1 201 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase2i::read_datagram_fixed(DatagramIterator &source);

2151 14 write_datagram 0 4 3522 26 LVecBase2i::write_datagram 0 1 202 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase2i::write_datagram(Datagram &destination) const;

2152 13 read_datagram 0 4 3522 25 LVecBase2i::read_datagram 0 1 203 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase2i::read_datagram(DatagramIterator &source);

2153 14 get_class_type 0 4 3522 26 LVecBase2i::get_class_type 0 1 204 0
51
static TypeHandle LVecBase2i::get_class_type(void);

2154 11 ~LVecBase2i 0 4 3522 23 LVecBase2i::~LVecBase2i 0 0 0
30
LVecBase2i::~LVecBase2i(void);

2155 9 LVector2f 0 4 3525 20 LVector2f::LVector2f 0 5 205 206 207 208 209 146
/**
 * Constructs a new LVector2 from a LVecBase2
 */

/**
 * Constructs a new LVector2 with all components set to the fill value.
 */

/**
 *
 */
249
inline LVector2f::LVector2f(void) = default;
inline LVector2f::LVector2f(LVecBase2f const &copy);
inline LVector2f::LVector2f(float fill_value);
inline LVector2f::LVector2f(float x, float y);
inline LVector2f::LVector2f(LVector2f const &) = default;

2156 11 __getattr__ 0 4 3525 22 LVector2f::__getattr__ 0 1 210 0
92
inline PyObject *LVector2f::__getattr__(PyObject *self, std::string const &attr_name) const;

2157 11 __setattr__ 0 4 3525 22 LVector2f::__setattr__ 0 1 211 0
98
inline int LVector2f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2158 4 zero 0 4 3525 15 LVector2f::zero 0 1 212 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector2f const &LVector2f::zero(void);

2159 6 unit_x 0 4 3525 17 LVector2f::unit_x 0 1 213 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector2f const &LVector2f::unit_x(void);

2160 6 unit_y 0 4 3525 17 LVector2f::unit_y 0 1 214 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector2f const &LVector2f::unit_y(void);

2161 10 operator - 0 68 3525 21 LVector2f::operator - 0 1 215 0
51
inline LVector2f LVector2f::operator -(void) const;

2162 10 operator + 0 4 3525 21 LVector2f::operator + 0 2 216 217 0
141
inline LVecBase2f LVector2f::operator +(LVecBase2f const &other) const;
inline LVector2f LVector2f::operator +(LVector2f const &other) const;

2163 10 operator - 0 4 3525 21 LVector2f::operator - 0 2 218 219 0
141
inline LVecBase2f LVector2f::operator -(LVecBase2f const &other) const;
inline LVector2f LVector2f::operator -(LVector2f const &other) const;

2164 10 operator * 0 4 3525 21 LVector2f::operator * 0 1 220 0
59
inline LVector2f LVector2f::operator *(float scalar) const;

2165 10 operator / 0 4 3525 21 LVector2f::operator / 0 1 221 0
59
inline LVector2f LVector2f::operator /(float scalar) const;

2166 10 normalized 0 4 3525 21 LVector2f::normalized 0 1 222 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector2f LVector2f::normalized(void) const;

2167 7 project 0 4 3525 18 LVector2f::project 0 1 223 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector2f LVector2f::project(LVecBase2f const &onto) const;

2168 16 signed_angle_rad 0 4 3525 27 LVector2f::signed_angle_rad 0 1 224 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
71
inline float LVector2f::signed_angle_rad(LVector2f const &other) const;

2169 16 signed_angle_deg 0 4 3525 27 LVector2f::signed_angle_deg 0 1 225 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
71
inline float LVector2f::signed_angle_deg(LVector2f const &other) const;

2170 8 __repr__ 0 4 3525 19 LVector2f::__repr__ 0 1 226 0
51
inline std::string LVector2f::__repr__(void) const;

2171 14 get_class_type 0 4 3525 25 LVector2f::get_class_type 0 1 227 0
50
static TypeHandle LVector2f::get_class_type(void);

2172 10 ~LVector2f 0 4 3525 21 LVector2f::~LVector2f 0 0 0
28
LVector2f::~LVector2f(void);

2173 9 LVector2d 0 4 3526 20 LVector2d::LVector2d 0 5 228 229 230 231 232 146
/**
 * Constructs a new LVector2 from a LVecBase2
 */

/**
 * Constructs a new LVector2 with all components set to the fill value.
 */

/**
 *
 */
252
inline LVector2d::LVector2d(void) = default;
inline LVector2d::LVector2d(LVecBase2d const &copy);
inline LVector2d::LVector2d(double fill_value);
inline LVector2d::LVector2d(double x, double y);
inline LVector2d::LVector2d(LVector2d const &) = default;

2174 11 __getattr__ 0 4 3526 22 LVector2d::__getattr__ 0 1 233 0
92
inline PyObject *LVector2d::__getattr__(PyObject *self, std::string const &attr_name) const;

2175 11 __setattr__ 0 4 3526 22 LVector2d::__setattr__ 0 1 234 0
98
inline int LVector2d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2176 4 zero 0 4 3526 15 LVector2d::zero 0 1 235 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector2d const &LVector2d::zero(void);

2177 6 unit_x 0 4 3526 17 LVector2d::unit_x 0 1 236 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector2d const &LVector2d::unit_x(void);

2178 6 unit_y 0 4 3526 17 LVector2d::unit_y 0 1 237 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector2d const &LVector2d::unit_y(void);

2179 10 operator - 0 68 3526 21 LVector2d::operator - 0 1 238 0
51
inline LVector2d LVector2d::operator -(void) const;

2180 10 operator + 0 4 3526 21 LVector2d::operator + 0 2 239 240 0
141
inline LVecBase2d LVector2d::operator +(LVecBase2d const &other) const;
inline LVector2d LVector2d::operator +(LVector2d const &other) const;

2181 10 operator - 0 4 3526 21 LVector2d::operator - 0 2 241 242 0
141
inline LVecBase2d LVector2d::operator -(LVecBase2d const &other) const;
inline LVector2d LVector2d::operator -(LVector2d const &other) const;

2182 10 operator * 0 4 3526 21 LVector2d::operator * 0 1 243 0
60
inline LVector2d LVector2d::operator *(double scalar) const;

2183 10 operator / 0 4 3526 21 LVector2d::operator / 0 1 244 0
60
inline LVector2d LVector2d::operator /(double scalar) const;

2184 10 normalized 0 4 3526 21 LVector2d::normalized 0 1 245 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector2d LVector2d::normalized(void) const;

2185 7 project 0 4 3526 18 LVector2d::project 0 1 246 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector2d LVector2d::project(LVecBase2d const &onto) const;

2186 16 signed_angle_rad 0 4 3526 27 LVector2d::signed_angle_rad 0 1 247 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
72
inline double LVector2d::signed_angle_rad(LVector2d const &other) const;

2187 16 signed_angle_deg 0 4 3526 27 LVector2d::signed_angle_deg 0 1 248 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
72
inline double LVector2d::signed_angle_deg(LVector2d const &other) const;

2188 8 __repr__ 0 4 3526 19 LVector2d::__repr__ 0 1 249 0
51
inline std::string LVector2d::__repr__(void) const;

2189 14 get_class_type 0 4 3526 25 LVector2d::get_class_type 0 1 250 0
50
static TypeHandle LVector2d::get_class_type(void);

2190 10 ~LVector2d 0 4 3526 21 LVector2d::~LVector2d 0 0 0
28
LVector2d::~LVector2d(void);

2191 9 LVector2i 0 4 3527 20 LVector2i::LVector2i 0 5 251 252 253 254 255 146
/**
 * Constructs a new LVector2 from a LVecBase2
 */

/**
 * Constructs a new LVector2 with all components set to the fill value.
 */

/**
 *
 */
243
inline LVector2i::LVector2i(void) = default;
inline LVector2i::LVector2i(LVecBase2i const &copy);
inline LVector2i::LVector2i(int fill_value);
inline LVector2i::LVector2i(int x, int y);
inline LVector2i::LVector2i(LVector2i const &) = default;

2192 11 __getattr__ 0 4 3527 22 LVector2i::__getattr__ 0 1 256 0
92
inline PyObject *LVector2i::__getattr__(PyObject *self, std::string const &attr_name) const;

2193 11 __setattr__ 0 4 3527 22 LVector2i::__setattr__ 0 1 257 0
98
inline int LVector2i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2194 4 zero 0 4 3527 15 LVector2i::zero 0 1 258 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector2i const &LVector2i::zero(void);

2195 6 unit_x 0 4 3527 17 LVector2i::unit_x 0 1 259 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector2i const &LVector2i::unit_x(void);

2196 6 unit_y 0 4 3527 17 LVector2i::unit_y 0 1 260 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector2i const &LVector2i::unit_y(void);

2197 10 operator - 0 68 3527 21 LVector2i::operator - 0 1 261 0
51
inline LVector2i LVector2i::operator -(void) const;

2198 10 operator + 0 4 3527 21 LVector2i::operator + 0 2 262 263 0
141
inline LVecBase2i LVector2i::operator +(LVecBase2i const &other) const;
inline LVector2i LVector2i::operator +(LVector2i const &other) const;

2199 10 operator - 0 4 3527 21 LVector2i::operator - 0 2 264 265 0
141
inline LVecBase2i LVector2i::operator -(LVecBase2i const &other) const;
inline LVector2i LVector2i::operator -(LVector2i const &other) const;

2200 10 operator * 0 4 3527 21 LVector2i::operator * 0 1 266 0
57
inline LVector2i LVector2i::operator *(int scalar) const;

2201 10 operator / 0 4 3527 21 LVector2i::operator / 0 1 267 0
57
inline LVector2i LVector2i::operator /(int scalar) const;

2202 8 __repr__ 0 4 3527 19 LVector2i::__repr__ 0 1 268 0
51
inline std::string LVector2i::__repr__(void) const;

2203 14 get_class_type 0 4 3527 25 LVector2i::get_class_type 0 1 269 0
50
static TypeHandle LVector2i::get_class_type(void);

2204 10 ~LVector2i 0 4 3527 21 LVector2i::~LVector2i 0 0 0
28
LVector2i::~LVector2i(void);

2205 8 LPoint2f 0 4 3528 18 LPoint2f::LPoint2f 0 5 270 271 272 273 274 190
/**
 * Constructs a new LPoint2 from a LVecBase2
 */

/**
 * Constructs a new LPoint2 all components set to the fill value.
 */

/**
 * Constructs a new LPoint2 with the given components
 */
238
inline LPoint2f::LPoint2f(void) = default;
inline LPoint2f::LPoint2f(LVecBase2f const &copy);
inline LPoint2f::LPoint2f(float fill_value);
inline LPoint2f::LPoint2f(float x, float y);
inline LPoint2f::LPoint2f(LPoint2f const &) = default;

2206 11 __getattr__ 0 4 3528 21 LPoint2f::__getattr__ 0 1 275 0
91
inline PyObject *LPoint2f::__getattr__(PyObject *self, std::string const &attr_name) const;

2207 11 __setattr__ 0 4 3528 21 LPoint2f::__setattr__ 0 1 276 0
97
inline int LPoint2f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2208 4 zero 0 4 3528 14 LPoint2f::zero 0 1 277 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint2f const &LPoint2f::zero(void);

2209 6 unit_x 0 4 3528 16 LPoint2f::unit_x 0 1 278 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint2f const &LPoint2f::unit_x(void);

2210 6 unit_y 0 4 3528 16 LPoint2f::unit_y 0 1 279 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint2f const &LPoint2f::unit_y(void);

2211 10 operator - 0 68 3528 20 LPoint2f::operator - 0 1 280 0
49
inline LPoint2f LPoint2f::operator -(void) const;

2212 10 operator + 0 4 3528 20 LPoint2f::operator + 0 2 281 282 0
138
inline LVecBase2f LPoint2f::operator +(LVecBase2f const &other) const;
inline LPoint2f LPoint2f::operator +(LVector2f const &other) const;

2213 10 operator - 0 4 3528 20 LPoint2f::operator - 0 3 283 284 285 0
206
inline LVecBase2f LPoint2f::operator -(LVecBase2f const &other) const;
inline LVector2f LPoint2f::operator -(LPoint2f const &other) const;
inline LPoint2f LPoint2f::operator -(LVector2f const &other) const;

2214 10 operator * 0 4 3528 20 LPoint2f::operator * 0 1 286 0
57
inline LPoint2f LPoint2f::operator *(float scalar) const;

2215 10 operator / 0 4 3528 20 LPoint2f::operator / 0 1 287 0
57
inline LPoint2f LPoint2f::operator /(float scalar) const;

2216 10 normalized 0 4 3528 20 LPoint2f::normalized 0 1 288 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint2f LPoint2f::normalized(void) const;

2217 7 project 0 4 3528 17 LPoint2f::project 0 1 289 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint2f LPoint2f::project(LVecBase2f const &onto) const;

2218 8 __repr__ 0 4 3528 18 LPoint2f::__repr__ 0 1 290 0
50
inline std::string LPoint2f::__repr__(void) const;

2219 14 get_class_type 0 4 3528 24 LPoint2f::get_class_type 0 1 291 0
49
static TypeHandle LPoint2f::get_class_type(void);

2220 9 ~LPoint2f 0 4 3528 19 LPoint2f::~LPoint2f 0 0 0
26
LPoint2f::~LPoint2f(void);

2221 8 LPoint2d 0 4 3529 18 LPoint2d::LPoint2d 0 5 292 293 294 295 296 190
/**
 * Constructs a new LPoint2 from a LVecBase2
 */

/**
 * Constructs a new LPoint2 all components set to the fill value.
 */

/**
 * Constructs a new LPoint2 with the given components
 */
241
inline LPoint2d::LPoint2d(void) = default;
inline LPoint2d::LPoint2d(LVecBase2d const &copy);
inline LPoint2d::LPoint2d(double fill_value);
inline LPoint2d::LPoint2d(double x, double y);
inline LPoint2d::LPoint2d(LPoint2d const &) = default;

2222 11 __getattr__ 0 4 3529 21 LPoint2d::__getattr__ 0 1 297 0
91
inline PyObject *LPoint2d::__getattr__(PyObject *self, std::string const &attr_name) const;

2223 11 __setattr__ 0 4 3529 21 LPoint2d::__setattr__ 0 1 298 0
97
inline int LPoint2d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2224 4 zero 0 4 3529 14 LPoint2d::zero 0 1 299 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint2d const &LPoint2d::zero(void);

2225 6 unit_x 0 4 3529 16 LPoint2d::unit_x 0 1 300 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint2d const &LPoint2d::unit_x(void);

2226 6 unit_y 0 4 3529 16 LPoint2d::unit_y 0 1 301 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint2d const &LPoint2d::unit_y(void);

2227 10 operator - 0 68 3529 20 LPoint2d::operator - 0 1 302 0
49
inline LPoint2d LPoint2d::operator -(void) const;

2228 10 operator + 0 4 3529 20 LPoint2d::operator + 0 2 303 304 0
138
inline LVecBase2d LPoint2d::operator +(LVecBase2d const &other) const;
inline LPoint2d LPoint2d::operator +(LVector2d const &other) const;

2229 10 operator - 0 4 3529 20 LPoint2d::operator - 0 3 305 306 307 0
206
inline LVecBase2d LPoint2d::operator -(LVecBase2d const &other) const;
inline LVector2d LPoint2d::operator -(LPoint2d const &other) const;
inline LPoint2d LPoint2d::operator -(LVector2d const &other) const;

2230 10 operator * 0 4 3529 20 LPoint2d::operator * 0 1 308 0
58
inline LPoint2d LPoint2d::operator *(double scalar) const;

2231 10 operator / 0 4 3529 20 LPoint2d::operator / 0 1 309 0
58
inline LPoint2d LPoint2d::operator /(double scalar) const;

2232 10 normalized 0 4 3529 20 LPoint2d::normalized 0 1 310 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint2d LPoint2d::normalized(void) const;

2233 7 project 0 4 3529 17 LPoint2d::project 0 1 311 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint2d LPoint2d::project(LVecBase2d const &onto) const;

2234 8 __repr__ 0 4 3529 18 LPoint2d::__repr__ 0 1 312 0
50
inline std::string LPoint2d::__repr__(void) const;

2235 14 get_class_type 0 4 3529 24 LPoint2d::get_class_type 0 1 313 0
49
static TypeHandle LPoint2d::get_class_type(void);

2236 9 ~LPoint2d 0 4 3529 19 LPoint2d::~LPoint2d 0 0 0
26
LPoint2d::~LPoint2d(void);

2237 8 LPoint2i 0 4 3530 18 LPoint2i::LPoint2i 0 5 314 315 316 317 318 190
/**
 * Constructs a new LPoint2 from a LVecBase2
 */

/**
 * Constructs a new LPoint2 all components set to the fill value.
 */

/**
 * Constructs a new LPoint2 with the given components
 */
232
inline LPoint2i::LPoint2i(void) = default;
inline LPoint2i::LPoint2i(LVecBase2i const &copy);
inline LPoint2i::LPoint2i(int fill_value);
inline LPoint2i::LPoint2i(int x, int y);
inline LPoint2i::LPoint2i(LPoint2i const &) = default;

2238 11 __getattr__ 0 4 3530 21 LPoint2i::__getattr__ 0 1 319 0
91
inline PyObject *LPoint2i::__getattr__(PyObject *self, std::string const &attr_name) const;

2239 11 __setattr__ 0 4 3530 21 LPoint2i::__setattr__ 0 1 320 0
97
inline int LPoint2i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2240 4 zero 0 4 3530 14 LPoint2i::zero 0 1 321 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint2i const &LPoint2i::zero(void);

2241 6 unit_x 0 4 3530 16 LPoint2i::unit_x 0 1 322 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint2i const &LPoint2i::unit_x(void);

2242 6 unit_y 0 4 3530 16 LPoint2i::unit_y 0 1 323 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint2i const &LPoint2i::unit_y(void);

2243 10 operator - 0 68 3530 20 LPoint2i::operator - 0 1 324 0
49
inline LPoint2i LPoint2i::operator -(void) const;

2244 10 operator + 0 4 3530 20 LPoint2i::operator + 0 2 325 326 0
138
inline LVecBase2i LPoint2i::operator +(LVecBase2i const &other) const;
inline LPoint2i LPoint2i::operator +(LVector2i const &other) const;

2245 10 operator - 0 4 3530 20 LPoint2i::operator - 0 3 327 328 329 0
206
inline LVecBase2i LPoint2i::operator -(LVecBase2i const &other) const;
inline LVector2i LPoint2i::operator -(LPoint2i const &other) const;
inline LPoint2i LPoint2i::operator -(LVector2i const &other) const;

2246 10 operator * 0 4 3530 20 LPoint2i::operator * 0 1 330 0
55
inline LPoint2i LPoint2i::operator *(int scalar) const;

2247 10 operator / 0 4 3530 20 LPoint2i::operator / 0 1 331 0
55
inline LPoint2i LPoint2i::operator /(int scalar) const;

2248 8 __repr__ 0 4 3530 18 LPoint2i::__repr__ 0 1 332 0
50
inline std::string LPoint2i::__repr__(void) const;

2249 14 get_class_type 0 4 3530 24 LPoint2i::get_class_type 0 1 333 0
49
static TypeHandle LPoint2i::get_class_type(void);

2250 9 ~LPoint2i 0 4 3530 19 LPoint2i::~LPoint2i 0 0 0
26
LPoint2i::~LPoint2i(void);

2251 10 LVecBase3f 0 4 3531 22 LVecBase3f::LVecBase3f 0 5 334 335 336 337 338 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
278
inline LVecBase3f::LVecBase3f(void) = default;
inline LVecBase3f::LVecBase3f(float fill_value);
inline LVecBase3f::LVecBase3f(float x, float y, float z);
inline LVecBase3f::LVecBase3f(LVecBase2f const &copy, float z);
inline LVecBase3f::LVecBase3f(LVecBase3f const &) = default;

2252 12 operator new 0 4 3531 24 LVecBase3f::operator new 0 1 339 0
124
inline void *LVecBase3f::operator new(std::size_t size);
inline void *LVecBase3f::operator new(std::size_t size, void *ptr);

2253 15 operator delete 0 4 3531 27 LVecBase3f::operator delete 0 0 0
108
inline void LVecBase3f::operator delete(void *ptr);
inline void LVecBase3f::operator delete(void *, void *);

2254 12 validate_ptr 0 4 3531 24 LVecBase3f::validate_ptr 0 0 0
61
static inline bool LVecBase3f::validate_ptr(void const *ptr);

2255 10 operator = 0 4 3531 22 LVecBase3f::operator = 0 2 340 341 0
119
void LVecBase3f::operator =(LVecBase3f const &copy) = default;
void LVecBase3f::operator =(float fill_value) = default;

2256 4 zero 0 4 3531 16 LVecBase3f::zero 0 1 342 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase3f const &LVecBase3f::zero(void);

2257 6 unit_x 0 4 3531 18 LVecBase3f::unit_x 0 1 343 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase3f const &LVecBase3f::unit_x(void);

2258 6 unit_y 0 4 3531 18 LVecBase3f::unit_y 0 1 344 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase3f const &LVecBase3f::unit_y(void);

2259 6 unit_z 0 4 3531 18 LVecBase3f::unit_z 0 1 345 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase3f const &LVecBase3f::unit_z(void);

2260 10 __reduce__ 0 4 3531 22 LVecBase3f::__reduce__ 0 1 346 0
62
inline PyObject *LVecBase3f::__reduce__(PyObject *self) const;

2261 11 __getattr__ 0 4 3531 23 LVecBase3f::__getattr__ 0 1 347 0
93
inline PyObject *LVecBase3f::__getattr__(PyObject *self, std::string const &attr_name) const;

2262 11 __setattr__ 0 4 3531 23 LVecBase3f::__setattr__ 0 1 348 0
99
inline int LVecBase3f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2263 11 operator [] 0 4 3531 23 LVecBase3f::operator [] 0 2 349 350 10
/**
 *
 */
96
inline float LVecBase3f::operator [](int i) const;
inline float &LVecBase3f::operator [](int i);

2264 4 size 0 4 3531 16 LVecBase3f::size 0 1 351 0
44
static constexpr int LVecBase3f::size(void);

2265 6 is_nan 0 4 3531 18 LVecBase3f::is_nan 0 1 352 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase3f::is_nan(void) const;

2266 8 get_cell 0 4 3531 20 LVecBase3f::get_cell 0 1 353 10
/**
 *
 */
47
inline float LVecBase3f::get_cell(int i) const;

2267 5 get_x 0 4 3531 17 LVecBase3f::get_x 0 1 354 10
/**
 *
 */
43
inline float LVecBase3f::get_x(void) const;

2268 5 get_y 0 4 3531 17 LVecBase3f::get_y 0 1 355 10
/**
 *
 */
43
inline float LVecBase3f::get_y(void) const;

2269 5 get_z 0 4 3531 17 LVecBase3f::get_z 0 1 356 10
/**
 *
 */
43
inline float LVecBase3f::get_z(void) const;

2270 8 set_cell 0 4 3531 20 LVecBase3f::set_cell 0 1 357 10
/**
 *
 */
53
inline void LVecBase3f::set_cell(int i, float value);

2271 5 set_x 0 4 3531 17 LVecBase3f::set_x 0 1 358 10
/**
 *
 */
43
inline void LVecBase3f::set_x(float value);

2272 5 set_y 0 4 3531 17 LVecBase3f::set_y 0 1 359 10
/**
 *
 */
43
inline void LVecBase3f::set_y(float value);

2273 5 set_z 0 4 3531 17 LVecBase3f::set_z 0 1 360 10
/**
 *
 */
43
inline void LVecBase3f::set_z(float value);

2274 6 get_xy 0 4 3531 18 LVecBase3f::get_xy 0 1 361 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
49
inline LVecBase2f LVecBase3f::get_xy(void) const;

2275 6 get_xz 0 4 3531 18 LVecBase3f::get_xz 0 1 362 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
49
inline LVecBase2f LVecBase3f::get_xz(void) const;

2276 6 get_yz 0 4 3531 18 LVecBase3f::get_yz 0 1 363 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
49
inline LVecBase2f LVecBase3f::get_yz(void) const;

2277 11 add_to_cell 0 4 3531 23 LVecBase3f::add_to_cell 0 1 364 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
56
inline void LVecBase3f::add_to_cell(int i, float value);

2278 5 add_x 0 4 3531 17 LVecBase3f::add_x 0 1 365 10
/**
 *
 */
43
inline void LVecBase3f::add_x(float value);

2279 5 add_y 0 4 3531 17 LVecBase3f::add_y 0 1 366 10
/**
 *
 */
43
inline void LVecBase3f::add_y(float value);

2280 5 add_z 0 4 3531 17 LVecBase3f::add_z 0 1 367 10
/**
 *
 */
43
inline void LVecBase3f::add_z(float value);

2281 8 get_data 0 4 3531 20 LVecBase3f::get_data 0 1 368 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
53
inline float const *LVecBase3f::get_data(void) const;

2282 18 get_num_components 0 4 3531 30 LVecBase3f::get_num_components 0 1 369 0
58
static constexpr int LVecBase3f::get_num_components(void);

2283 4 fill 0 4 3531 16 LVecBase3f::fill 0 1 370 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
47
inline void LVecBase3f::fill(float fill_value);

2284 3 set 0 4 3531 15 LVecBase3f::set 0 1 371 10
/**
 *
 */
55
inline void LVecBase3f::set(float x, float y, float z);

2285 3 dot 0 4 3531 15 LVecBase3f::dot 0 1 372 10
/**
 *
 */
60
inline float LVecBase3f::dot(LVecBase3f const &other) const;

2286 14 length_squared 0 4 3531 26 LVecBase3f::length_squared 0 1 373 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
52
inline float LVecBase3f::length_squared(void) const;

2287 6 length 0 4 3531 18 LVecBase3f::length 0 1 374 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
44
inline float LVecBase3f::length(void) const;

2288 9 normalize 0 4 3531 21 LVecBase3f::normalize 0 1 375 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase3f::normalize(void);

2289 10 normalized 0 4 3531 22 LVecBase3f::normalized 0 1 376 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase3f LVecBase3f::normalized(void) const;

2290 7 project 0 4 3531 19 LVecBase3f::project 0 1 377 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase3f LVecBase3f::project(LVecBase3f const &onto) const;

2291 5 cross 0 4 3531 17 LVecBase3f::cross 0 1 378 10
/**
 *
 */
67
inline LVecBase3f LVecBase3f::cross(LVecBase3f const &other) const;

2292 10 operator < 0 4 3531 22 LVecBase3f::operator < 0 1 379 0
66
inline bool LVecBase3f::operator <(LVecBase3f const &other) const;

2293 11 operator == 0 4 3531 23 LVecBase3f::operator == 0 1 380 0
67
inline bool LVecBase3f::operator ==(LVecBase3f const &other) const;

2294 11 operator != 0 4 3531 23 LVecBase3f::operator != 0 1 381 0
67
inline bool LVecBase3f::operator !=(LVecBase3f const &other) const;

2295 20 get_standardized_hpr 0 4 3531 32 LVecBase3f::get_standardized_hpr 0 1 382 623
/**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */
63
inline LVecBase3f LVecBase3f::get_standardized_hpr(void) const;

2296 10 compare_to 0 4 3531 22 LVecBase3f::compare_to 0 2 383 384 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
148
inline int LVecBase3f::compare_to(LVecBase3f const &other) const;
inline int LVecBase3f::compare_to(LVecBase3f const &other, float threshold) const;

2297 8 get_hash 0 4 3531 20 LVecBase3f::get_hash 0 2 385 386 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
116
inline std::size_t LVecBase3f::get_hash(void) const;
inline std::size_t LVecBase3f::get_hash(float threshold) const;

2298 8 add_hash 0 4 3531 20 LVecBase3f::add_hash 0 2 387 388 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
146
inline std::size_t LVecBase3f::add_hash(std::size_t hash) const;
inline std::size_t LVecBase3f::add_hash(std::size_t hash, float threshold) const;

2299 13 generate_hash 0 4 3531 25 LVecBase3f::generate_hash 0 2 389 390 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
170
inline void LVecBase3f::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase3f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

2300 10 operator - 0 68 3531 22 LVecBase3f::operator - 0 1 391 0
53
inline LVecBase3f LVecBase3f::operator -(void) const;

2301 10 operator + 0 4 3531 22 LVecBase3f::operator + 0 1 392 0
72
inline LVecBase3f LVecBase3f::operator +(LVecBase3f const &other) const;

2302 10 operator - 0 4 3531 22 LVecBase3f::operator - 0 1 393 0
72
inline LVecBase3f LVecBase3f::operator -(LVecBase3f const &other) const;

2303 10 operator * 0 4 3531 22 LVecBase3f::operator * 0 1 394 0
61
inline LVecBase3f LVecBase3f::operator *(float scalar) const;

2304 10 operator / 0 4 3531 22 LVecBase3f::operator / 0 1 395 0
61
inline LVecBase3f LVecBase3f::operator /(float scalar) const;

2305 11 operator += 0 4 3531 23 LVecBase3f::operator += 0 1 396 0
61
inline void LVecBase3f::operator +=(LVecBase3f const &other);

2306 11 operator -= 0 4 3531 23 LVecBase3f::operator -= 0 1 397 0
61
inline void LVecBase3f::operator -=(LVecBase3f const &other);

2307 11 operator *= 0 4 3531 23 LVecBase3f::operator *= 0 1 398 0
50
inline void LVecBase3f::operator *=(float scalar);

2308 11 operator /= 0 4 3531 23 LVecBase3f::operator /= 0 1 399 0
50
inline void LVecBase3f::operator /=(float scalar);

2309 18 componentwise_mult 0 4 3531 30 LVecBase3f::componentwise_mult 0 1 400 10
/**
 *
 */
68
inline void LVecBase3f::componentwise_mult(LVecBase3f const &other);

2310 7 __pow__ 0 4 3531 19 LVecBase3f::__pow__ 0 1 401 0
60
inline LVecBase3f LVecBase3f::__pow__(float exponent) const;

2311 8 __ipow__ 0 4 3531 20 LVecBase3f::__ipow__ 0 1 402 0
70
inline PyObject *LVecBase3f::__ipow__(PyObject *self, float exponent);

2312 4 fmax 0 4 3531 16 LVecBase3f::fmax 0 1 403 10
/**
 *
 */
66
inline LVecBase3f LVecBase3f::fmax(LVecBase3f const &other) const;

2313 4 fmin 0 4 3531 16 LVecBase3f::fmin 0 1 404 10
/**
 *
 */
66
inline LVecBase3f LVecBase3f::fmin(LVecBase3f const &other) const;

2314 10 cross_into 0 4 3531 22 LVecBase3f::cross_into 0 1 405 10
/**
 *
 */
60
inline void LVecBase3f::cross_into(LVecBase3f const &other);

2315 12 almost_equal 0 4 3531 24 LVecBase3f::almost_equal 0 2 406 407 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
154
inline bool LVecBase3f::almost_equal(LVecBase3f const &other, float threshold) const;
inline bool LVecBase3f::almost_equal(LVecBase3f const &other) const;

2316 6 output 0 4 3531 18 LVecBase3f::output 0 1 408 10
/**
 *
 */
56
inline void LVecBase3f::output(std::ostream &out) const;

2317 8 __repr__ 0 4 3531 20 LVecBase3f::__repr__ 0 1 409 0
52
inline std::string LVecBase3f::__repr__(void) const;

2318 20 write_datagram_fixed 0 4 3531 32 LVecBase3f::write_datagram_fixed 0 1 410 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase3f::write_datagram_fixed(Datagram &destination) const;

2319 19 read_datagram_fixed 0 4 3531 31 LVecBase3f::read_datagram_fixed 0 1 411 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase3f::read_datagram_fixed(DatagramIterator &source);

2320 14 write_datagram 0 4 3531 26 LVecBase3f::write_datagram 0 1 412 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase3f::write_datagram(Datagram &destination) const;

2321 13 read_datagram 0 4 3531 25 LVecBase3f::read_datagram 0 1 413 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase3f::read_datagram(DatagramIterator &source);

2322 14 get_class_type 0 4 3531 26 LVecBase3f::get_class_type 0 1 414 0
51
static TypeHandle LVecBase3f::get_class_type(void);

2323 11 ~LVecBase3f 0 4 3531 23 LVecBase3f::~LVecBase3f 0 0 0
30
LVecBase3f::~LVecBase3f(void);

2324 10 LVecBase3d 0 4 3533 22 LVecBase3d::LVecBase3d 0 5 415 416 417 418 419 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
283
inline LVecBase3d::LVecBase3d(void) = default;
inline LVecBase3d::LVecBase3d(double fill_value);
inline LVecBase3d::LVecBase3d(double x, double y, double z);
inline LVecBase3d::LVecBase3d(LVecBase2d const &copy, double z);
inline LVecBase3d::LVecBase3d(LVecBase3d const &) = default;

2325 12 operator new 0 4 3533 24 LVecBase3d::operator new 0 1 420 0
124
inline void *LVecBase3d::operator new(std::size_t size);
inline void *LVecBase3d::operator new(std::size_t size, void *ptr);

2326 15 operator delete 0 4 3533 27 LVecBase3d::operator delete 0 0 0
108
inline void LVecBase3d::operator delete(void *ptr);
inline void LVecBase3d::operator delete(void *, void *);

2327 12 validate_ptr 0 4 3533 24 LVecBase3d::validate_ptr 0 0 0
61
static inline bool LVecBase3d::validate_ptr(void const *ptr);

2328 10 operator = 0 4 3533 22 LVecBase3d::operator = 0 2 421 422 0
120
void LVecBase3d::operator =(LVecBase3d const &copy) = default;
void LVecBase3d::operator =(double fill_value) = default;

2329 4 zero 0 4 3533 16 LVecBase3d::zero 0 1 423 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase3d const &LVecBase3d::zero(void);

2330 6 unit_x 0 4 3533 18 LVecBase3d::unit_x 0 1 424 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase3d const &LVecBase3d::unit_x(void);

2331 6 unit_y 0 4 3533 18 LVecBase3d::unit_y 0 1 425 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase3d const &LVecBase3d::unit_y(void);

2332 6 unit_z 0 4 3533 18 LVecBase3d::unit_z 0 1 426 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase3d const &LVecBase3d::unit_z(void);

2333 10 __reduce__ 0 4 3533 22 LVecBase3d::__reduce__ 0 1 427 0
62
inline PyObject *LVecBase3d::__reduce__(PyObject *self) const;

2334 11 __getattr__ 0 4 3533 23 LVecBase3d::__getattr__ 0 1 428 0
93
inline PyObject *LVecBase3d::__getattr__(PyObject *self, std::string const &attr_name) const;

2335 11 __setattr__ 0 4 3533 23 LVecBase3d::__setattr__ 0 1 429 0
99
inline int LVecBase3d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2336 11 operator [] 0 4 3533 23 LVecBase3d::operator [] 0 2 430 431 10
/**
 *
 */
98
inline double LVecBase3d::operator [](int i) const;
inline double &LVecBase3d::operator [](int i);

2337 4 size 0 4 3533 16 LVecBase3d::size 0 1 432 0
44
static constexpr int LVecBase3d::size(void);

2338 6 is_nan 0 4 3533 18 LVecBase3d::is_nan 0 1 433 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase3d::is_nan(void) const;

2339 8 get_cell 0 4 3533 20 LVecBase3d::get_cell 0 1 434 10
/**
 *
 */
48
inline double LVecBase3d::get_cell(int i) const;

2340 5 get_x 0 4 3533 17 LVecBase3d::get_x 0 1 435 10
/**
 *
 */
44
inline double LVecBase3d::get_x(void) const;

2341 5 get_y 0 4 3533 17 LVecBase3d::get_y 0 1 436 10
/**
 *
 */
44
inline double LVecBase3d::get_y(void) const;

2342 5 get_z 0 4 3533 17 LVecBase3d::get_z 0 1 437 10
/**
 *
 */
44
inline double LVecBase3d::get_z(void) const;

2343 8 set_cell 0 4 3533 20 LVecBase3d::set_cell 0 1 438 10
/**
 *
 */
54
inline void LVecBase3d::set_cell(int i, double value);

2344 5 set_x 0 4 3533 17 LVecBase3d::set_x 0 1 439 10
/**
 *
 */
44
inline void LVecBase3d::set_x(double value);

2345 5 set_y 0 4 3533 17 LVecBase3d::set_y 0 1 440 10
/**
 *
 */
44
inline void LVecBase3d::set_y(double value);

2346 5 set_z 0 4 3533 17 LVecBase3d::set_z 0 1 441 10
/**
 *
 */
44
inline void LVecBase3d::set_z(double value);

2347 6 get_xy 0 4 3533 18 LVecBase3d::get_xy 0 1 442 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
49
inline LVecBase2d LVecBase3d::get_xy(void) const;

2348 6 get_xz 0 4 3533 18 LVecBase3d::get_xz 0 1 443 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
49
inline LVecBase2d LVecBase3d::get_xz(void) const;

2349 6 get_yz 0 4 3533 18 LVecBase3d::get_yz 0 1 444 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
49
inline LVecBase2d LVecBase3d::get_yz(void) const;

2350 11 add_to_cell 0 4 3533 23 LVecBase3d::add_to_cell 0 1 445 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
57
inline void LVecBase3d::add_to_cell(int i, double value);

2351 5 add_x 0 4 3533 17 LVecBase3d::add_x 0 1 446 10
/**
 *
 */
44
inline void LVecBase3d::add_x(double value);

2352 5 add_y 0 4 3533 17 LVecBase3d::add_y 0 1 447 10
/**
 *
 */
44
inline void LVecBase3d::add_y(double value);

2353 5 add_z 0 4 3533 17 LVecBase3d::add_z 0 1 448 10
/**
 *
 */
44
inline void LVecBase3d::add_z(double value);

2354 8 get_data 0 4 3533 20 LVecBase3d::get_data 0 1 449 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
54
inline double const *LVecBase3d::get_data(void) const;

2355 18 get_num_components 0 4 3533 30 LVecBase3d::get_num_components 0 1 450 0
58
static constexpr int LVecBase3d::get_num_components(void);

2356 4 fill 0 4 3533 16 LVecBase3d::fill 0 1 451 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
48
inline void LVecBase3d::fill(double fill_value);

2357 3 set 0 4 3533 15 LVecBase3d::set 0 1 452 10
/**
 *
 */
58
inline void LVecBase3d::set(double x, double y, double z);

2358 3 dot 0 4 3533 15 LVecBase3d::dot 0 1 453 10
/**
 *
 */
61
inline double LVecBase3d::dot(LVecBase3d const &other) const;

2359 14 length_squared 0 4 3533 26 LVecBase3d::length_squared 0 1 454 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
53
inline double LVecBase3d::length_squared(void) const;

2360 6 length 0 4 3533 18 LVecBase3d::length 0 1 455 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
45
inline double LVecBase3d::length(void) const;

2361 9 normalize 0 4 3533 21 LVecBase3d::normalize 0 1 456 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase3d::normalize(void);

2362 10 normalized 0 4 3533 22 LVecBase3d::normalized 0 1 457 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase3d LVecBase3d::normalized(void) const;

2363 7 project 0 4 3533 19 LVecBase3d::project 0 1 458 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase3d LVecBase3d::project(LVecBase3d const &onto) const;

2364 5 cross 0 4 3533 17 LVecBase3d::cross 0 1 459 10
/**
 *
 */
67
inline LVecBase3d LVecBase3d::cross(LVecBase3d const &other) const;

2365 10 operator < 0 4 3533 22 LVecBase3d::operator < 0 1 460 0
66
inline bool LVecBase3d::operator <(LVecBase3d const &other) const;

2366 11 operator == 0 4 3533 23 LVecBase3d::operator == 0 1 461 0
67
inline bool LVecBase3d::operator ==(LVecBase3d const &other) const;

2367 11 operator != 0 4 3533 23 LVecBase3d::operator != 0 1 462 0
67
inline bool LVecBase3d::operator !=(LVecBase3d const &other) const;

2368 20 get_standardized_hpr 0 4 3533 32 LVecBase3d::get_standardized_hpr 0 1 463 623
/**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */
63
inline LVecBase3d LVecBase3d::get_standardized_hpr(void) const;

2369 10 compare_to 0 4 3533 22 LVecBase3d::compare_to 0 2 464 465 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
149
inline int LVecBase3d::compare_to(LVecBase3d const &other) const;
inline int LVecBase3d::compare_to(LVecBase3d const &other, double threshold) const;

2370 8 get_hash 0 4 3533 20 LVecBase3d::get_hash 0 2 466 467 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
117
inline std::size_t LVecBase3d::get_hash(void) const;
inline std::size_t LVecBase3d::get_hash(double threshold) const;

2371 8 add_hash 0 4 3533 20 LVecBase3d::add_hash 0 2 468 469 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
147
inline std::size_t LVecBase3d::add_hash(std::size_t hash) const;
inline std::size_t LVecBase3d::add_hash(std::size_t hash, double threshold) const;

2372 13 generate_hash 0 4 3533 25 LVecBase3d::generate_hash 0 2 470 471 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
171
inline void LVecBase3d::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase3d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

2373 10 operator - 0 68 3533 22 LVecBase3d::operator - 0 1 472 0
53
inline LVecBase3d LVecBase3d::operator -(void) const;

2374 10 operator + 0 4 3533 22 LVecBase3d::operator + 0 1 473 0
72
inline LVecBase3d LVecBase3d::operator +(LVecBase3d const &other) const;

2375 10 operator - 0 4 3533 22 LVecBase3d::operator - 0 1 474 0
72
inline LVecBase3d LVecBase3d::operator -(LVecBase3d const &other) const;

2376 10 operator * 0 4 3533 22 LVecBase3d::operator * 0 1 475 0
62
inline LVecBase3d LVecBase3d::operator *(double scalar) const;

2377 10 operator / 0 4 3533 22 LVecBase3d::operator / 0 1 476 0
62
inline LVecBase3d LVecBase3d::operator /(double scalar) const;

2378 11 operator += 0 4 3533 23 LVecBase3d::operator += 0 1 477 0
61
inline void LVecBase3d::operator +=(LVecBase3d const &other);

2379 11 operator -= 0 4 3533 23 LVecBase3d::operator -= 0 1 478 0
61
inline void LVecBase3d::operator -=(LVecBase3d const &other);

2380 11 operator *= 0 4 3533 23 LVecBase3d::operator *= 0 1 479 0
51
inline void LVecBase3d::operator *=(double scalar);

2381 11 operator /= 0 4 3533 23 LVecBase3d::operator /= 0 1 480 0
51
inline void LVecBase3d::operator /=(double scalar);

2382 18 componentwise_mult 0 4 3533 30 LVecBase3d::componentwise_mult 0 1 481 10
/**
 *
 */
68
inline void LVecBase3d::componentwise_mult(LVecBase3d const &other);

2383 7 __pow__ 0 4 3533 19 LVecBase3d::__pow__ 0 1 482 0
61
inline LVecBase3d LVecBase3d::__pow__(double exponent) const;

2384 8 __ipow__ 0 4 3533 20 LVecBase3d::__ipow__ 0 1 483 0
71
inline PyObject *LVecBase3d::__ipow__(PyObject *self, double exponent);

2385 4 fmax 0 4 3533 16 LVecBase3d::fmax 0 1 484 10
/**
 *
 */
66
inline LVecBase3d LVecBase3d::fmax(LVecBase3d const &other) const;

2386 4 fmin 0 4 3533 16 LVecBase3d::fmin 0 1 485 10
/**
 *
 */
66
inline LVecBase3d LVecBase3d::fmin(LVecBase3d const &other) const;

2387 10 cross_into 0 4 3533 22 LVecBase3d::cross_into 0 1 486 10
/**
 *
 */
60
inline void LVecBase3d::cross_into(LVecBase3d const &other);

2388 12 almost_equal 0 4 3533 24 LVecBase3d::almost_equal 0 2 487 488 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
155
inline bool LVecBase3d::almost_equal(LVecBase3d const &other, double threshold) const;
inline bool LVecBase3d::almost_equal(LVecBase3d const &other) const;

2389 6 output 0 4 3533 18 LVecBase3d::output 0 1 489 10
/**
 *
 */
56
inline void LVecBase3d::output(std::ostream &out) const;

2390 8 __repr__ 0 4 3533 20 LVecBase3d::__repr__ 0 1 490 0
52
inline std::string LVecBase3d::__repr__(void) const;

2391 20 write_datagram_fixed 0 4 3533 32 LVecBase3d::write_datagram_fixed 0 1 491 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase3d::write_datagram_fixed(Datagram &destination) const;

2392 19 read_datagram_fixed 0 4 3533 31 LVecBase3d::read_datagram_fixed 0 1 492 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase3d::read_datagram_fixed(DatagramIterator &source);

2393 14 write_datagram 0 4 3533 26 LVecBase3d::write_datagram 0 1 493 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase3d::write_datagram(Datagram &destination) const;

2394 13 read_datagram 0 4 3533 25 LVecBase3d::read_datagram 0 1 494 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase3d::read_datagram(DatagramIterator &source);

2395 14 get_class_type 0 4 3533 26 LVecBase3d::get_class_type 0 1 495 0
51
static TypeHandle LVecBase3d::get_class_type(void);

2396 11 ~LVecBase3d 0 4 3533 23 LVecBase3d::~LVecBase3d 0 0 0
30
LVecBase3d::~LVecBase3d(void);

2397 10 LVecBase3i 0 4 3535 22 LVecBase3i::LVecBase3i 0 5 496 497 498 499 500 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
268
inline LVecBase3i::LVecBase3i(void) = default;
inline LVecBase3i::LVecBase3i(int fill_value);
inline LVecBase3i::LVecBase3i(int x, int y, int z);
inline LVecBase3i::LVecBase3i(LVecBase2i const &copy, int z);
inline LVecBase3i::LVecBase3i(LVecBase3i const &) = default;

2398 12 operator new 0 4 3535 24 LVecBase3i::operator new 0 1 501 0
124
inline void *LVecBase3i::operator new(std::size_t size);
inline void *LVecBase3i::operator new(std::size_t size, void *ptr);

2399 15 operator delete 0 4 3535 27 LVecBase3i::operator delete 0 0 0
108
inline void LVecBase3i::operator delete(void *ptr);
inline void LVecBase3i::operator delete(void *, void *);

2400 12 validate_ptr 0 4 3535 24 LVecBase3i::validate_ptr 0 0 0
61
static inline bool LVecBase3i::validate_ptr(void const *ptr);

2401 10 operator = 0 4 3535 22 LVecBase3i::operator = 0 2 502 503 0
117
void LVecBase3i::operator =(LVecBase3i const &copy) = default;
void LVecBase3i::operator =(int fill_value) = default;

2402 4 zero 0 4 3535 16 LVecBase3i::zero 0 1 504 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase3i const &LVecBase3i::zero(void);

2403 6 unit_x 0 4 3535 18 LVecBase3i::unit_x 0 1 505 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase3i const &LVecBase3i::unit_x(void);

2404 6 unit_y 0 4 3535 18 LVecBase3i::unit_y 0 1 506 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase3i const &LVecBase3i::unit_y(void);

2405 6 unit_z 0 4 3535 18 LVecBase3i::unit_z 0 1 507 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase3i const &LVecBase3i::unit_z(void);

2406 10 __reduce__ 0 4 3535 22 LVecBase3i::__reduce__ 0 1 508 0
62
inline PyObject *LVecBase3i::__reduce__(PyObject *self) const;

2407 11 __getattr__ 0 4 3535 23 LVecBase3i::__getattr__ 0 1 509 0
93
inline PyObject *LVecBase3i::__getattr__(PyObject *self, std::string const &attr_name) const;

2408 11 __setattr__ 0 4 3535 23 LVecBase3i::__setattr__ 0 1 510 0
99
inline int LVecBase3i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2409 11 operator [] 0 4 3535 23 LVecBase3i::operator [] 0 2 511 512 10
/**
 *
 */
92
inline int LVecBase3i::operator [](int i) const;
inline int &LVecBase3i::operator [](int i);

2410 4 size 0 4 3535 16 LVecBase3i::size 0 1 513 0
44
static constexpr int LVecBase3i::size(void);

2411 6 is_nan 0 4 3535 18 LVecBase3i::is_nan 0 1 514 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase3i::is_nan(void) const;

2412 8 get_cell 0 4 3535 20 LVecBase3i::get_cell 0 1 515 10
/**
 *
 */
45
inline int LVecBase3i::get_cell(int i) const;

2413 5 get_x 0 4 3535 17 LVecBase3i::get_x 0 1 516 10
/**
 *
 */
41
inline int LVecBase3i::get_x(void) const;

2414 5 get_y 0 4 3535 17 LVecBase3i::get_y 0 1 517 10
/**
 *
 */
41
inline int LVecBase3i::get_y(void) const;

2415 5 get_z 0 4 3535 17 LVecBase3i::get_z 0 1 518 10
/**
 *
 */
41
inline int LVecBase3i::get_z(void) const;

2416 8 set_cell 0 4 3535 20 LVecBase3i::set_cell 0 1 519 10
/**
 *
 */
51
inline void LVecBase3i::set_cell(int i, int value);

2417 5 set_x 0 4 3535 17 LVecBase3i::set_x 0 1 520 10
/**
 *
 */
41
inline void LVecBase3i::set_x(int value);

2418 5 set_y 0 4 3535 17 LVecBase3i::set_y 0 1 521 10
/**
 *
 */
41
inline void LVecBase3i::set_y(int value);

2419 5 set_z 0 4 3535 17 LVecBase3i::set_z 0 1 522 10
/**
 *
 */
41
inline void LVecBase3i::set_z(int value);

2420 6 get_xy 0 4 3535 18 LVecBase3i::get_xy 0 1 523 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
49
inline LVecBase2i LVecBase3i::get_xy(void) const;

2421 6 get_xz 0 4 3535 18 LVecBase3i::get_xz 0 1 524 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
49
inline LVecBase2i LVecBase3i::get_xz(void) const;

2422 6 get_yz 0 4 3535 18 LVecBase3i::get_yz 0 1 525 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
49
inline LVecBase2i LVecBase3i::get_yz(void) const;

2423 11 add_to_cell 0 4 3535 23 LVecBase3i::add_to_cell 0 1 526 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
54
inline void LVecBase3i::add_to_cell(int i, int value);

2424 5 add_x 0 4 3535 17 LVecBase3i::add_x 0 1 527 10
/**
 *
 */
41
inline void LVecBase3i::add_x(int value);

2425 5 add_y 0 4 3535 17 LVecBase3i::add_y 0 1 528 10
/**
 *
 */
41
inline void LVecBase3i::add_y(int value);

2426 5 add_z 0 4 3535 17 LVecBase3i::add_z 0 1 529 10
/**
 *
 */
41
inline void LVecBase3i::add_z(int value);

2427 8 get_data 0 4 3535 20 LVecBase3i::get_data 0 1 530 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
51
inline int const *LVecBase3i::get_data(void) const;

2428 18 get_num_components 0 4 3535 30 LVecBase3i::get_num_components 0 1 531 0
58
static constexpr int LVecBase3i::get_num_components(void);

2429 4 fill 0 4 3535 16 LVecBase3i::fill 0 1 532 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
45
inline void LVecBase3i::fill(int fill_value);

2430 3 set 0 4 3535 15 LVecBase3i::set 0 1 533 10
/**
 *
 */
49
inline void LVecBase3i::set(int x, int y, int z);

2431 3 dot 0 4 3535 15 LVecBase3i::dot 0 1 534 10
/**
 *
 */
58
inline int LVecBase3i::dot(LVecBase3i const &other) const;

2432 14 length_squared 0 4 3535 26 LVecBase3i::length_squared 0 1 535 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
50
inline int LVecBase3i::length_squared(void) const;

2433 5 cross 0 4 3535 17 LVecBase3i::cross 0 1 536 10
/**
 *
 */
67
inline LVecBase3i LVecBase3i::cross(LVecBase3i const &other) const;

2434 10 operator < 0 4 3535 22 LVecBase3i::operator < 0 1 537 0
66
inline bool LVecBase3i::operator <(LVecBase3i const &other) const;

2435 11 operator == 0 4 3535 23 LVecBase3i::operator == 0 1 538 0
67
inline bool LVecBase3i::operator ==(LVecBase3i const &other) const;

2436 11 operator != 0 4 3535 23 LVecBase3i::operator != 0 1 539 0
67
inline bool LVecBase3i::operator !=(LVecBase3i const &other) const;

2437 10 compare_to 0 4 3535 22 LVecBase3i::compare_to 0 1 540 97
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */
65
inline int LVecBase3i::compare_to(LVecBase3i const &other) const;

2438 8 get_hash 0 4 3535 20 LVecBase3i::get_hash 0 1 541 49
/**
 * Returns a suitable hash for phash_map.
 */
52
inline std::size_t LVecBase3i::get_hash(void) const;

2439 8 add_hash 0 4 3535 20 LVecBase3i::add_hash 0 1 542 49
/**
 * Adds the vector into the running hash.
 */
64
inline std::size_t LVecBase3i::add_hash(std::size_t hash) const;

2440 13 generate_hash 0 4 3535 25 LVecBase3i::generate_hash 0 1 543 59
/**
 * Adds the vector to the indicated hash generator.
 */
76
inline void LVecBase3i::generate_hash(ChecksumHashGenerator &hashgen) const;

2441 10 operator - 0 68 3535 22 LVecBase3i::operator - 0 1 544 0
53
inline LVecBase3i LVecBase3i::operator -(void) const;

2442 10 operator + 0 4 3535 22 LVecBase3i::operator + 0 1 545 0
72
inline LVecBase3i LVecBase3i::operator +(LVecBase3i const &other) const;

2443 10 operator - 0 4 3535 22 LVecBase3i::operator - 0 1 546 0
72
inline LVecBase3i LVecBase3i::operator -(LVecBase3i const &other) const;

2444 10 operator * 0 4 3535 22 LVecBase3i::operator * 0 1 547 0
59
inline LVecBase3i LVecBase3i::operator *(int scalar) const;

2445 10 operator / 0 4 3535 22 LVecBase3i::operator / 0 1 548 0
59
inline LVecBase3i LVecBase3i::operator /(int scalar) const;

2446 11 operator += 0 4 3535 23 LVecBase3i::operator += 0 1 549 0
61
inline void LVecBase3i::operator +=(LVecBase3i const &other);

2447 11 operator -= 0 4 3535 23 LVecBase3i::operator -= 0 1 550 0
61
inline void LVecBase3i::operator -=(LVecBase3i const &other);

2448 11 operator *= 0 4 3535 23 LVecBase3i::operator *= 0 1 551 0
48
inline void LVecBase3i::operator *=(int scalar);

2449 11 operator /= 0 4 3535 23 LVecBase3i::operator /= 0 1 552 0
48
inline void LVecBase3i::operator /=(int scalar);

2450 18 componentwise_mult 0 4 3535 30 LVecBase3i::componentwise_mult 0 1 553 10
/**
 *
 */
68
inline void LVecBase3i::componentwise_mult(LVecBase3i const &other);

2451 7 __pow__ 0 4 3535 19 LVecBase3i::__pow__ 0 1 554 0
58
inline LVecBase3i LVecBase3i::__pow__(int exponent) const;

2452 8 __ipow__ 0 4 3535 20 LVecBase3i::__ipow__ 0 1 555 0
68
inline PyObject *LVecBase3i::__ipow__(PyObject *self, int exponent);

2453 4 fmax 0 4 3535 16 LVecBase3i::fmax 0 1 556 10
/**
 *
 */
66
inline LVecBase3i LVecBase3i::fmax(LVecBase3i const &other) const;

2454 4 fmin 0 4 3535 16 LVecBase3i::fmin 0 1 557 10
/**
 *
 */
66
inline LVecBase3i LVecBase3i::fmin(LVecBase3i const &other) const;

2455 10 cross_into 0 4 3535 22 LVecBase3i::cross_into 0 1 558 10
/**
 *
 */
60
inline void LVecBase3i::cross_into(LVecBase3i const &other);

2456 12 almost_equal 0 4 3535 24 LVecBase3i::almost_equal 0 2 559 560 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
152
inline bool LVecBase3i::almost_equal(LVecBase3i const &other, int threshold) const;
inline bool LVecBase3i::almost_equal(LVecBase3i const &other) const;

2457 6 output 0 4 3535 18 LVecBase3i::output 0 1 561 10
/**
 *
 */
56
inline void LVecBase3i::output(std::ostream &out) const;

2458 8 __repr__ 0 4 3535 20 LVecBase3i::__repr__ 0 1 562 0
52
inline std::string LVecBase3i::__repr__(void) const;

2459 20 write_datagram_fixed 0 4 3535 32 LVecBase3i::write_datagram_fixed 0 1 563 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase3i::write_datagram_fixed(Datagram &destination) const;

2460 19 read_datagram_fixed 0 4 3535 31 LVecBase3i::read_datagram_fixed 0 1 564 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase3i::read_datagram_fixed(DatagramIterator &source);

2461 14 write_datagram 0 4 3535 26 LVecBase3i::write_datagram 0 1 565 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase3i::write_datagram(Datagram &destination) const;

2462 13 read_datagram 0 4 3535 25 LVecBase3i::read_datagram 0 1 566 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase3i::read_datagram(DatagramIterator &source);

2463 14 get_class_type 0 4 3535 26 LVecBase3i::get_class_type 0 1 567 0
51
static TypeHandle LVecBase3i::get_class_type(void);

2464 11 ~LVecBase3i 0 4 3535 23 LVecBase3i::~LVecBase3i 0 0 0
30
LVecBase3i::~LVecBase3i(void);

2465 29 get_default_coordinate_system 0 1 0 29 get_default_coordinate_system 0 1 1880 0
53
CoordinateSystem get_default_coordinate_system(void);

2466 30 parse_coordinate_system_string 0 1 0 30 parse_coordinate_system_string 0 1 1881 0
72
CoordinateSystem parse_coordinate_system_string(std::string const &str);

2467 24 format_coordinate_system 0 1 0 24 format_coordinate_system 0 1 1882 0
58
std::string format_coordinate_system(CoordinateSystem cs);

2468 15 is_right_handed 0 1 0 15 is_right_handed 0 1 1883 0
57
bool is_right_handed(CoordinateSystem cs = ::CS_default);

2469 9 LVector3f 0 4 3538 20 LVector3f::LVector3f 0 6 568 569 570 571 572 573 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
320
inline LVector3f::LVector3f(void) = default;
inline LVector3f::LVector3f(LVecBase3f const &copy);
inline LVector3f::LVector3f(float fill_value);
inline LVector3f::LVector3f(float x, float y, float z);
inline LVector3f::LVector3f(LVecBase2f const &copy, float z);
inline LVector3f::LVector3f(LVector3f const &) = default;

2470 11 __getattr__ 0 4 3538 22 LVector3f::__getattr__ 0 1 574 0
92
inline PyObject *LVector3f::__getattr__(PyObject *self, std::string const &attr_name) const;

2471 11 __setattr__ 0 4 3538 22 LVector3f::__setattr__ 0 1 575 0
98
inline int LVector3f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2472 4 zero 0 4 3538 15 LVector3f::zero 0 1 576 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector3f const &LVector3f::zero(void);

2473 6 unit_x 0 4 3538 17 LVector3f::unit_x 0 1 577 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector3f const &LVector3f::unit_x(void);

2474 6 unit_y 0 4 3538 17 LVector3f::unit_y 0 1 578 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector3f const &LVector3f::unit_y(void);

2475 6 unit_z 0 4 3538 17 LVector3f::unit_z 0 1 579 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector3f const &LVector3f::unit_z(void);

2476 6 get_xy 0 4 3538 17 LVector3f::get_xy 0 1 580 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
47
inline LVector2f LVector3f::get_xy(void) const;

2477 6 get_xz 0 4 3538 17 LVector3f::get_xz 0 1 581 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
47
inline LVector2f LVector3f::get_xz(void) const;

2478 6 get_yz 0 4 3538 17 LVector3f::get_yz 0 1 582 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
47
inline LVector2f LVector3f::get_yz(void) const;

2479 10 operator - 0 68 3538 21 LVector3f::operator - 0 1 583 0
51
inline LVector3f LVector3f::operator -(void) const;

2480 10 operator + 0 4 3538 21 LVector3f::operator + 0 2 584 585 0
141
inline LVecBase3f LVector3f::operator +(LVecBase3f const &other) const;
inline LVector3f LVector3f::operator +(LVector3f const &other) const;

2481 10 operator - 0 4 3538 21 LVector3f::operator - 0 2 586 587 0
141
inline LVecBase3f LVector3f::operator -(LVecBase3f const &other) const;
inline LVector3f LVector3f::operator -(LVector3f const &other) const;

2482 5 cross 0 4 3538 16 LVector3f::cross 0 1 588 10
/**
 *
 */
65
inline LVector3f LVector3f::cross(LVecBase3f const &other) const;

2483 10 normalized 0 4 3538 21 LVector3f::normalized 0 1 589 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector3f LVector3f::normalized(void) const;

2484 7 project 0 4 3538 18 LVector3f::project 0 1 590 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector3f LVector3f::project(LVecBase3f const &onto) const;

2485 9 angle_rad 0 4 3538 20 LVector3f::angle_rad 0 1 591 147
/**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */
64
inline float LVector3f::angle_rad(LVector3f const &other) const;

2486 9 angle_deg 0 4 3538 20 LVector3f::angle_deg 0 1 592 138
/**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */
64
inline float LVector3f::angle_deg(LVector3f const &other) const;

2487 16 signed_angle_rad 0 4 3538 27 LVector3f::signed_angle_rad 0 1 593 259
/**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
93
inline float LVector3f::signed_angle_rad(LVector3f const &other, LVector3f const &ref) const;

2488 16 signed_angle_deg 0 4 3538 27 LVector3f::signed_angle_deg 0 1 594 259
/**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
93
inline float LVector3f::signed_angle_deg(LVector3f const &other, LVector3f const &ref) const;

2489 18 relative_angle_rad 0 4 3538 29 LVector3f::relative_angle_rad 0 1 595 34
/**
 * @deprecated Do not use.
 */
73
inline float LVector3f::relative_angle_rad(LVector3f const &other) const;

2490 18 relative_angle_deg 0 4 3538 29 LVector3f::relative_angle_deg 0 1 596 34
/**
 * @deprecated Do not use.
 */
73
inline float LVector3f::relative_angle_deg(LVector3f const &other) const;

2491 10 operator * 0 4 3538 21 LVector3f::operator * 0 1 597 0
59
inline LVector3f LVector3f::operator *(float scalar) const;

2492 10 operator / 0 4 3538 21 LVector3f::operator / 0 1 598 0
59
inline LVector3f LVector3f::operator /(float scalar) const;

2493 2 up 0 4 3538 13 LVector3f::up 0 1 599 65
/**
 * Returns the up vector for the given coordinate system.
 */
74
static inline LVector3f LVector3f::up(CoordinateSystem cs = ::CS_default);

2494 5 right 0 4 3538 16 LVector3f::right 0 1 600 68
/**
 * Returns the right vector for the given coordinate system.
 */
77
static inline LVector3f LVector3f::right(CoordinateSystem cs = ::CS_default);

2495 7 forward 0 4 3538 18 LVector3f::forward 0 1 601 70
/**
 * Returns the forward vector for the given coordinate system.
 */
79
static inline LVector3f LVector3f::forward(CoordinateSystem cs = ::CS_default);

2496 4 down 0 4 3538 15 LVector3f::down 0 1 602 67
/**
 * Returns the down vector for the given coordinate system.
 */
76
static inline LVector3f LVector3f::down(CoordinateSystem cs = ::CS_default);

2497 4 left 0 4 3538 15 LVector3f::left 0 1 603 67
/**
 * Returns the left vector for the given coordinate system.
 */
76
static inline LVector3f LVector3f::left(CoordinateSystem cs = ::CS_default);

2498 4 back 0 4 3538 15 LVector3f::back 0 1 604 67
/**
 * Returns the back vector for the given coordinate system.
 */
76
static inline LVector3f LVector3f::back(CoordinateSystem cs = ::CS_default);

2499 3 rfu 0 4 3538 14 LVector3f::rfu 0 1 605 221
// INLINE_LINMATH static FLOATNAME(LVector3) & rfu(FLOATTYPE right,

/**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */
109
static inline LVector3f LVector3f::rfu(float right, float fwd, float up, CoordinateSystem cs = ::CS_default);

2500 8 __repr__ 0 4 3538 19 LVector3f::__repr__ 0 1 606 0
51
inline std::string LVector3f::__repr__(void) const;

2501 14 get_class_type 0 4 3538 25 LVector3f::get_class_type 0 1 607 0
50
static TypeHandle LVector3f::get_class_type(void);

2502 10 ~LVector3f 0 4 3538 21 LVector3f::~LVector3f 0 0 0
28
LVector3f::~LVector3f(void);

2503 9 LVector3d 0 4 3539 20 LVector3d::LVector3d 0 6 608 609 610 611 612 613 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
325
inline LVector3d::LVector3d(void) = default;
inline LVector3d::LVector3d(LVecBase3d const &copy);
inline LVector3d::LVector3d(double fill_value);
inline LVector3d::LVector3d(double x, double y, double z);
inline LVector3d::LVector3d(LVecBase2d const &copy, double z);
inline LVector3d::LVector3d(LVector3d const &) = default;

2504 11 __getattr__ 0 4 3539 22 LVector3d::__getattr__ 0 1 614 0
92
inline PyObject *LVector3d::__getattr__(PyObject *self, std::string const &attr_name) const;

2505 11 __setattr__ 0 4 3539 22 LVector3d::__setattr__ 0 1 615 0
98
inline int LVector3d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2506 4 zero 0 4 3539 15 LVector3d::zero 0 1 616 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector3d const &LVector3d::zero(void);

2507 6 unit_x 0 4 3539 17 LVector3d::unit_x 0 1 617 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector3d const &LVector3d::unit_x(void);

2508 6 unit_y 0 4 3539 17 LVector3d::unit_y 0 1 618 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector3d const &LVector3d::unit_y(void);

2509 6 unit_z 0 4 3539 17 LVector3d::unit_z 0 1 619 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector3d const &LVector3d::unit_z(void);

2510 6 get_xy 0 4 3539 17 LVector3d::get_xy 0 1 620 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
47
inline LVector2d LVector3d::get_xy(void) const;

2511 6 get_xz 0 4 3539 17 LVector3d::get_xz 0 1 621 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
47
inline LVector2d LVector3d::get_xz(void) const;

2512 6 get_yz 0 4 3539 17 LVector3d::get_yz 0 1 622 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
47
inline LVector2d LVector3d::get_yz(void) const;

2513 10 operator - 0 68 3539 21 LVector3d::operator - 0 1 623 0
51
inline LVector3d LVector3d::operator -(void) const;

2514 10 operator + 0 4 3539 21 LVector3d::operator + 0 2 624 625 0
141
inline LVecBase3d LVector3d::operator +(LVecBase3d const &other) const;
inline LVector3d LVector3d::operator +(LVector3d const &other) const;

2515 10 operator - 0 4 3539 21 LVector3d::operator - 0 2 626 627 0
141
inline LVecBase3d LVector3d::operator -(LVecBase3d const &other) const;
inline LVector3d LVector3d::operator -(LVector3d const &other) const;

2516 5 cross 0 4 3539 16 LVector3d::cross 0 1 628 10
/**
 *
 */
65
inline LVector3d LVector3d::cross(LVecBase3d const &other) const;

2517 10 normalized 0 4 3539 21 LVector3d::normalized 0 1 629 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector3d LVector3d::normalized(void) const;

2518 7 project 0 4 3539 18 LVector3d::project 0 1 630 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector3d LVector3d::project(LVecBase3d const &onto) const;

2519 9 angle_rad 0 4 3539 20 LVector3d::angle_rad 0 1 631 147
/**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */
65
inline double LVector3d::angle_rad(LVector3d const &other) const;

2520 9 angle_deg 0 4 3539 20 LVector3d::angle_deg 0 1 632 138
/**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */
65
inline double LVector3d::angle_deg(LVector3d const &other) const;

2521 16 signed_angle_rad 0 4 3539 27 LVector3d::signed_angle_rad 0 1 633 259
/**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
94
inline double LVector3d::signed_angle_rad(LVector3d const &other, LVector3d const &ref) const;

2522 16 signed_angle_deg 0 4 3539 27 LVector3d::signed_angle_deg 0 1 634 259
/**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
94
inline double LVector3d::signed_angle_deg(LVector3d const &other, LVector3d const &ref) const;

2523 18 relative_angle_rad 0 4 3539 29 LVector3d::relative_angle_rad 0 1 635 34
/**
 * @deprecated Do not use.
 */
74
inline double LVector3d::relative_angle_rad(LVector3d const &other) const;

2524 18 relative_angle_deg 0 4 3539 29 LVector3d::relative_angle_deg 0 1 636 34
/**
 * @deprecated Do not use.
 */
74
inline double LVector3d::relative_angle_deg(LVector3d const &other) const;

2525 10 operator * 0 4 3539 21 LVector3d::operator * 0 1 637 0
60
inline LVector3d LVector3d::operator *(double scalar) const;

2526 10 operator / 0 4 3539 21 LVector3d::operator / 0 1 638 0
60
inline LVector3d LVector3d::operator /(double scalar) const;

2527 2 up 0 4 3539 13 LVector3d::up 0 1 639 65
/**
 * Returns the up vector for the given coordinate system.
 */
74
static inline LVector3d LVector3d::up(CoordinateSystem cs = ::CS_default);

2528 5 right 0 4 3539 16 LVector3d::right 0 1 640 68
/**
 * Returns the right vector for the given coordinate system.
 */
77
static inline LVector3d LVector3d::right(CoordinateSystem cs = ::CS_default);

2529 7 forward 0 4 3539 18 LVector3d::forward 0 1 641 70
/**
 * Returns the forward vector for the given coordinate system.
 */
79
static inline LVector3d LVector3d::forward(CoordinateSystem cs = ::CS_default);

2530 4 down 0 4 3539 15 LVector3d::down 0 1 642 67
/**
 * Returns the down vector for the given coordinate system.
 */
76
static inline LVector3d LVector3d::down(CoordinateSystem cs = ::CS_default);

2531 4 left 0 4 3539 15 LVector3d::left 0 1 643 67
/**
 * Returns the left vector for the given coordinate system.
 */
76
static inline LVector3d LVector3d::left(CoordinateSystem cs = ::CS_default);

2532 4 back 0 4 3539 15 LVector3d::back 0 1 644 67
/**
 * Returns the back vector for the given coordinate system.
 */
76
static inline LVector3d LVector3d::back(CoordinateSystem cs = ::CS_default);

2533 3 rfu 0 4 3539 14 LVector3d::rfu 0 1 645 221
// INLINE_LINMATH static FLOATNAME(LVector3) & rfu(FLOATTYPE right,

/**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */
112
static inline LVector3d LVector3d::rfu(double right, double fwd, double up, CoordinateSystem cs = ::CS_default);

2534 8 __repr__ 0 4 3539 19 LVector3d::__repr__ 0 1 646 0
51
inline std::string LVector3d::__repr__(void) const;

2535 14 get_class_type 0 4 3539 25 LVector3d::get_class_type 0 1 647 0
50
static TypeHandle LVector3d::get_class_type(void);

2536 10 ~LVector3d 0 4 3539 21 LVector3d::~LVector3d 0 0 0
28
LVector3d::~LVector3d(void);

2537 9 LVector3i 0 4 3540 20 LVector3i::LVector3i 0 6 648 649 650 651 652 653 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
310
inline LVector3i::LVector3i(void) = default;
inline LVector3i::LVector3i(LVecBase3i const &copy);
inline LVector3i::LVector3i(int fill_value);
inline LVector3i::LVector3i(int x, int y, int z);
inline LVector3i::LVector3i(LVecBase2i const &copy, int z);
inline LVector3i::LVector3i(LVector3i const &) = default;

2538 11 __getattr__ 0 4 3540 22 LVector3i::__getattr__ 0 1 654 0
92
inline PyObject *LVector3i::__getattr__(PyObject *self, std::string const &attr_name) const;

2539 11 __setattr__ 0 4 3540 22 LVector3i::__setattr__ 0 1 655 0
98
inline int LVector3i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2540 4 zero 0 4 3540 15 LVector3i::zero 0 1 656 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector3i const &LVector3i::zero(void);

2541 6 unit_x 0 4 3540 17 LVector3i::unit_x 0 1 657 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector3i const &LVector3i::unit_x(void);

2542 6 unit_y 0 4 3540 17 LVector3i::unit_y 0 1 658 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector3i const &LVector3i::unit_y(void);

2543 6 unit_z 0 4 3540 17 LVector3i::unit_z 0 1 659 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector3i const &LVector3i::unit_z(void);

2544 6 get_xy 0 4 3540 17 LVector3i::get_xy 0 1 660 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
47
inline LVector2i LVector3i::get_xy(void) const;

2545 6 get_xz 0 4 3540 17 LVector3i::get_xz 0 1 661 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
47
inline LVector2i LVector3i::get_xz(void) const;

2546 6 get_yz 0 4 3540 17 LVector3i::get_yz 0 1 662 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
47
inline LVector2i LVector3i::get_yz(void) const;

2547 10 operator - 0 68 3540 21 LVector3i::operator - 0 1 663 0
51
inline LVector3i LVector3i::operator -(void) const;

2548 10 operator + 0 4 3540 21 LVector3i::operator + 0 2 664 665 0
141
inline LVecBase3i LVector3i::operator +(LVecBase3i const &other) const;
inline LVector3i LVector3i::operator +(LVector3i const &other) const;

2549 10 operator - 0 4 3540 21 LVector3i::operator - 0 2 666 667 0
141
inline LVecBase3i LVector3i::operator -(LVecBase3i const &other) const;
inline LVector3i LVector3i::operator -(LVector3i const &other) const;

2550 5 cross 0 4 3540 16 LVector3i::cross 0 1 668 10
/**
 *
 */
65
inline LVector3i LVector3i::cross(LVecBase3i const &other) const;

2551 10 operator * 0 4 3540 21 LVector3i::operator * 0 1 669 0
57
inline LVector3i LVector3i::operator *(int scalar) const;

2552 10 operator / 0 4 3540 21 LVector3i::operator / 0 1 670 0
57
inline LVector3i LVector3i::operator /(int scalar) const;

2553 2 up 0 4 3540 13 LVector3i::up 0 1 671 65
/**
 * Returns the up vector for the given coordinate system.
 */
74
static inline LVector3i LVector3i::up(CoordinateSystem cs = ::CS_default);

2554 5 right 0 4 3540 16 LVector3i::right 0 1 672 68
/**
 * Returns the right vector for the given coordinate system.
 */
77
static inline LVector3i LVector3i::right(CoordinateSystem cs = ::CS_default);

2555 7 forward 0 4 3540 18 LVector3i::forward 0 1 673 70
/**
 * Returns the forward vector for the given coordinate system.
 */
79
static inline LVector3i LVector3i::forward(CoordinateSystem cs = ::CS_default);

2556 4 down 0 4 3540 15 LVector3i::down 0 1 674 67
/**
 * Returns the down vector for the given coordinate system.
 */
76
static inline LVector3i LVector3i::down(CoordinateSystem cs = ::CS_default);

2557 4 left 0 4 3540 15 LVector3i::left 0 1 675 67
/**
 * Returns the left vector for the given coordinate system.
 */
76
static inline LVector3i LVector3i::left(CoordinateSystem cs = ::CS_default);

2558 4 back 0 4 3540 15 LVector3i::back 0 1 676 67
/**
 * Returns the back vector for the given coordinate system.
 */
76
static inline LVector3i LVector3i::back(CoordinateSystem cs = ::CS_default);

2559 3 rfu 0 4 3540 14 LVector3i::rfu 0 1 677 221
// INLINE_LINMATH static FLOATNAME(LVector3) & rfu(FLOATTYPE right,

/**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */
103
static inline LVector3i LVector3i::rfu(int right, int fwd, int up, CoordinateSystem cs = ::CS_default);

2560 8 __repr__ 0 4 3540 19 LVector3i::__repr__ 0 1 678 0
51
inline std::string LVector3i::__repr__(void) const;

2561 14 get_class_type 0 4 3540 25 LVector3i::get_class_type 0 1 679 0
50
static TypeHandle LVector3i::get_class_type(void);

2562 10 ~LVector3i 0 4 3540 21 LVector3i::~LVector3i 0 0 0
28
LVector3i::~LVector3i(void);

2563 8 LPoint3f 0 4 3541 18 LPoint3f::LPoint3f 0 6 680 681 682 683 684 685 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
307
inline LPoint3f::LPoint3f(void) = default;
inline LPoint3f::LPoint3f(LVecBase3f const &copy);
inline LPoint3f::LPoint3f(float fill_value);
inline LPoint3f::LPoint3f(float x, float y, float z);
inline LPoint3f::LPoint3f(LVecBase2f const &copy, float z);
inline LPoint3f::LPoint3f(LPoint3f const &) = default;

2564 11 __getattr__ 0 4 3541 21 LPoint3f::__getattr__ 0 1 686 0
91
inline PyObject *LPoint3f::__getattr__(PyObject *self, std::string const &attr_name) const;

2565 11 __setattr__ 0 4 3541 21 LPoint3f::__setattr__ 0 1 687 0
97
inline int LPoint3f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2566 4 zero 0 4 3541 14 LPoint3f::zero 0 1 688 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint3f const &LPoint3f::zero(void);

2567 6 unit_x 0 4 3541 16 LPoint3f::unit_x 0 1 689 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint3f const &LPoint3f::unit_x(void);

2568 6 unit_y 0 4 3541 16 LPoint3f::unit_y 0 1 690 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint3f const &LPoint3f::unit_y(void);

2569 6 unit_z 0 4 3541 16 LPoint3f::unit_z 0 1 691 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint3f const &LPoint3f::unit_z(void);

2570 6 get_xy 0 4 3541 16 LPoint3f::get_xy 0 1 692 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
45
inline LPoint2f LPoint3f::get_xy(void) const;

2571 6 get_xz 0 4 3541 16 LPoint3f::get_xz 0 1 693 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
45
inline LPoint2f LPoint3f::get_xz(void) const;

2572 6 get_yz 0 4 3541 16 LPoint3f::get_yz 0 1 694 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
45
inline LPoint2f LPoint3f::get_yz(void) const;

2573 10 operator - 0 68 3541 20 LPoint3f::operator - 0 1 695 0
49
inline LPoint3f LPoint3f::operator -(void) const;

2574 10 operator + 0 4 3541 20 LPoint3f::operator + 0 2 696 697 0
138
inline LVecBase3f LPoint3f::operator +(LVecBase3f const &other) const;
inline LPoint3f LPoint3f::operator +(LVector3f const &other) const;

2575 10 operator - 0 4 3541 20 LPoint3f::operator - 0 3 698 699 700 0
206
inline LVecBase3f LPoint3f::operator -(LVecBase3f const &other) const;
inline LVector3f LPoint3f::operator -(LPoint3f const &other) const;
inline LPoint3f LPoint3f::operator -(LVector3f const &other) const;

2576 5 cross 0 4 3541 15 LPoint3f::cross 0 1 701 10
/**
 *
 */
63
inline LPoint3f LPoint3f::cross(LVecBase3f const &other) const;

2577 10 normalized 0 4 3541 20 LPoint3f::normalized 0 1 702 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint3f LPoint3f::normalized(void) const;

2578 7 project 0 4 3541 17 LPoint3f::project 0 1 703 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint3f LPoint3f::project(LVecBase3f const &onto) const;

2579 10 operator * 0 4 3541 20 LPoint3f::operator * 0 1 704 0
57
inline LPoint3f LPoint3f::operator *(float scalar) const;

2580 10 operator / 0 4 3541 20 LPoint3f::operator / 0 1 705 0
57
inline LPoint3f LPoint3f::operator /(float scalar) const;

2581 6 origin 0 4 3541 16 LPoint3f::origin 0 1 706 186
/**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */
83
static inline LPoint3f const &LPoint3f::origin(CoordinateSystem cs = ::CS_default);

2582 3 rfu 0 4 3541 13 LPoint3f::rfu 0 1 707 146
/**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */
107
static inline LPoint3f LPoint3f::rfu(float right, float fwd, float up, CoordinateSystem cs = ::CS_default);

2583 8 __repr__ 0 4 3541 18 LPoint3f::__repr__ 0 1 708 0
50
inline std::string LPoint3f::__repr__(void) const;

2584 14 get_class_type 0 4 3541 24 LPoint3f::get_class_type 0 1 709 0
49
static TypeHandle LPoint3f::get_class_type(void);

2585 9 ~LPoint3f 0 4 3541 19 LPoint3f::~LPoint3f 0 0 0
26
LPoint3f::~LPoint3f(void);

2586 8 LPoint3d 0 4 3542 18 LPoint3d::LPoint3d 0 6 710 711 712 713 714 715 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
312
inline LPoint3d::LPoint3d(void) = default;
inline LPoint3d::LPoint3d(LVecBase3d const &copy);
inline LPoint3d::LPoint3d(double fill_value);
inline LPoint3d::LPoint3d(double x, double y, double z);
inline LPoint3d::LPoint3d(LVecBase2d const &copy, double z);
inline LPoint3d::LPoint3d(LPoint3d const &) = default;

2587 11 __getattr__ 0 4 3542 21 LPoint3d::__getattr__ 0 1 716 0
91
inline PyObject *LPoint3d::__getattr__(PyObject *self, std::string const &attr_name) const;

2588 11 __setattr__ 0 4 3542 21 LPoint3d::__setattr__ 0 1 717 0
97
inline int LPoint3d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2589 4 zero 0 4 3542 14 LPoint3d::zero 0 1 718 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint3d const &LPoint3d::zero(void);

2590 6 unit_x 0 4 3542 16 LPoint3d::unit_x 0 1 719 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint3d const &LPoint3d::unit_x(void);

2591 6 unit_y 0 4 3542 16 LPoint3d::unit_y 0 1 720 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint3d const &LPoint3d::unit_y(void);

2592 6 unit_z 0 4 3542 16 LPoint3d::unit_z 0 1 721 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint3d const &LPoint3d::unit_z(void);

2593 6 get_xy 0 4 3542 16 LPoint3d::get_xy 0 1 722 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
45
inline LPoint2d LPoint3d::get_xy(void) const;

2594 6 get_xz 0 4 3542 16 LPoint3d::get_xz 0 1 723 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
45
inline LPoint2d LPoint3d::get_xz(void) const;

2595 6 get_yz 0 4 3542 16 LPoint3d::get_yz 0 1 724 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
45
inline LPoint2d LPoint3d::get_yz(void) const;

2596 10 operator - 0 68 3542 20 LPoint3d::operator - 0 1 725 0
49
inline LPoint3d LPoint3d::operator -(void) const;

2597 10 operator + 0 4 3542 20 LPoint3d::operator + 0 2 726 727 0
138
inline LVecBase3d LPoint3d::operator +(LVecBase3d const &other) const;
inline LPoint3d LPoint3d::operator +(LVector3d const &other) const;

2598 10 operator - 0 4 3542 20 LPoint3d::operator - 0 3 728 729 730 0
206
inline LVecBase3d LPoint3d::operator -(LVecBase3d const &other) const;
inline LVector3d LPoint3d::operator -(LPoint3d const &other) const;
inline LPoint3d LPoint3d::operator -(LVector3d const &other) const;

2599 5 cross 0 4 3542 15 LPoint3d::cross 0 1 731 10
/**
 *
 */
63
inline LPoint3d LPoint3d::cross(LVecBase3d const &other) const;

2600 10 normalized 0 4 3542 20 LPoint3d::normalized 0 1 732 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint3d LPoint3d::normalized(void) const;

2601 7 project 0 4 3542 17 LPoint3d::project 0 1 733 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint3d LPoint3d::project(LVecBase3d const &onto) const;

2602 10 operator * 0 4 3542 20 LPoint3d::operator * 0 1 734 0
58
inline LPoint3d LPoint3d::operator *(double scalar) const;

2603 10 operator / 0 4 3542 20 LPoint3d::operator / 0 1 735 0
58
inline LPoint3d LPoint3d::operator /(double scalar) const;

2604 6 origin 0 4 3542 16 LPoint3d::origin 0 1 736 186
/**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */
83
static inline LPoint3d const &LPoint3d::origin(CoordinateSystem cs = ::CS_default);

2605 3 rfu 0 4 3542 13 LPoint3d::rfu 0 1 737 146
/**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */
110
static inline LPoint3d LPoint3d::rfu(double right, double fwd, double up, CoordinateSystem cs = ::CS_default);

2606 8 __repr__ 0 4 3542 18 LPoint3d::__repr__ 0 1 738 0
50
inline std::string LPoint3d::__repr__(void) const;

2607 14 get_class_type 0 4 3542 24 LPoint3d::get_class_type 0 1 739 0
49
static TypeHandle LPoint3d::get_class_type(void);

2608 9 ~LPoint3d 0 4 3542 19 LPoint3d::~LPoint3d 0 0 0
26
LPoint3d::~LPoint3d(void);

2609 8 LPoint3i 0 4 3543 18 LPoint3i::LPoint3i 0 6 740 741 742 743 744 745 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
297
inline LPoint3i::LPoint3i(void) = default;
inline LPoint3i::LPoint3i(LVecBase3i const &copy);
inline LPoint3i::LPoint3i(int fill_value);
inline LPoint3i::LPoint3i(int x, int y, int z);
inline LPoint3i::LPoint3i(LVecBase2i const &copy, int z);
inline LPoint3i::LPoint3i(LPoint3i const &) = default;

2610 11 __getattr__ 0 4 3543 21 LPoint3i::__getattr__ 0 1 746 0
91
inline PyObject *LPoint3i::__getattr__(PyObject *self, std::string const &attr_name) const;

2611 11 __setattr__ 0 4 3543 21 LPoint3i::__setattr__ 0 1 747 0
97
inline int LPoint3i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2612 4 zero 0 4 3543 14 LPoint3i::zero 0 1 748 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint3i const &LPoint3i::zero(void);

2613 6 unit_x 0 4 3543 16 LPoint3i::unit_x 0 1 749 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint3i const &LPoint3i::unit_x(void);

2614 6 unit_y 0 4 3543 16 LPoint3i::unit_y 0 1 750 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint3i const &LPoint3i::unit_y(void);

2615 6 unit_z 0 4 3543 16 LPoint3i::unit_z 0 1 751 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint3i const &LPoint3i::unit_z(void);

2616 6 get_xy 0 4 3543 16 LPoint3i::get_xy 0 1 752 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
45
inline LPoint2i LPoint3i::get_xy(void) const;

2617 6 get_xz 0 4 3543 16 LPoint3i::get_xz 0 1 753 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
45
inline LPoint2i LPoint3i::get_xz(void) const;

2618 6 get_yz 0 4 3543 16 LPoint3i::get_yz 0 1 754 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
45
inline LPoint2i LPoint3i::get_yz(void) const;

2619 10 operator - 0 68 3543 20 LPoint3i::operator - 0 1 755 0
49
inline LPoint3i LPoint3i::operator -(void) const;

2620 10 operator + 0 4 3543 20 LPoint3i::operator + 0 2 756 757 0
138
inline LVecBase3i LPoint3i::operator +(LVecBase3i const &other) const;
inline LPoint3i LPoint3i::operator +(LVector3i const &other) const;

2621 10 operator - 0 4 3543 20 LPoint3i::operator - 0 3 758 759 760 0
206
inline LVecBase3i LPoint3i::operator -(LVecBase3i const &other) const;
inline LVector3i LPoint3i::operator -(LPoint3i const &other) const;
inline LPoint3i LPoint3i::operator -(LVector3i const &other) const;

2622 5 cross 0 4 3543 15 LPoint3i::cross 0 1 761 10
/**
 *
 */
63
inline LPoint3i LPoint3i::cross(LVecBase3i const &other) const;

2623 10 operator * 0 4 3543 20 LPoint3i::operator * 0 1 762 0
55
inline LPoint3i LPoint3i::operator *(int scalar) const;

2624 10 operator / 0 4 3543 20 LPoint3i::operator / 0 1 763 0
55
inline LPoint3i LPoint3i::operator /(int scalar) const;

2625 6 origin 0 4 3543 16 LPoint3i::origin 0 1 764 186
/**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */
83
static inline LPoint3i const &LPoint3i::origin(CoordinateSystem cs = ::CS_default);

2626 3 rfu 0 4 3543 13 LPoint3i::rfu 0 1 765 146
/**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */
101
static inline LPoint3i LPoint3i::rfu(int right, int fwd, int up, CoordinateSystem cs = ::CS_default);

2627 8 __repr__ 0 4 3543 18 LPoint3i::__repr__ 0 1 766 0
50
inline std::string LPoint3i::__repr__(void) const;

2628 14 get_class_type 0 4 3543 24 LPoint3i::get_class_type 0 1 767 0
49
static TypeHandle LPoint3i::get_class_type(void);

2629 9 ~LPoint3i 0 4 3543 19 LPoint3i::~LPoint3i 0 0 0
26
LPoint3i::~LPoint3i(void);

2630 10 LVecBase4f 0 4 3544 22 LVecBase4f::LVecBase4f 0 8 768 769 770 771 772 773 774 775 219
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */

/**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */
461
inline LVecBase4f::LVecBase4f(void) = default;
inline LVecBase4f::LVecBase4f(float fill_value);
inline LVecBase4f::LVecBase4f(float x, float y, float z, float w);
inline LVecBase4f::LVecBase4f(UnalignedLVecBase4f const &copy);
inline LVecBase4f::LVecBase4f(LVecBase3f const &copy, float w);
inline LVecBase4f::LVecBase4f(LPoint3f const &point);
inline LVecBase4f::LVecBase4f(LVector3f const &vector);
inline LVecBase4f::LVecBase4f(LVecBase4f const &) = default;

2631 12 operator new 0 4 3544 24 LVecBase4f::operator new 0 1 776 0
124
inline void *LVecBase4f::operator new(std::size_t size);
inline void *LVecBase4f::operator new(std::size_t size, void *ptr);

2632 15 operator delete 0 4 3544 27 LVecBase4f::operator delete 0 0 0
108
inline void LVecBase4f::operator delete(void *ptr);
inline void LVecBase4f::operator delete(void *, void *);

2633 12 validate_ptr 0 4 3544 24 LVecBase4f::validate_ptr 0 0 0
61
static inline bool LVecBase4f::validate_ptr(void const *ptr);

2634 10 operator = 0 4 3544 22 LVecBase4f::operator = 0 2 777 778 0
119
void LVecBase4f::operator =(LVecBase4f const &copy) = default;
void LVecBase4f::operator =(float fill_value) = default;

2635 4 zero 0 4 3544 16 LVecBase4f::zero 0 1 779 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase4f const &LVecBase4f::zero(void);

2636 6 unit_x 0 4 3544 18 LVecBase4f::unit_x 0 1 780 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_x(void);

2637 6 unit_y 0 4 3544 18 LVecBase4f::unit_y 0 1 781 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_y(void);

2638 6 unit_z 0 4 3544 18 LVecBase4f::unit_z 0 1 782 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_z(void);

2639 6 unit_w 0 4 3544 18 LVecBase4f::unit_w 0 1 783 35
/**
 * Returns a unit W vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_w(void);

2640 10 __reduce__ 0 4 3544 22 LVecBase4f::__reduce__ 0 1 784 0
62
inline PyObject *LVecBase4f::__reduce__(PyObject *self) const;

2641 11 __getattr__ 0 4 3544 23 LVecBase4f::__getattr__ 0 1 785 0
93
inline PyObject *LVecBase4f::__getattr__(PyObject *self, std::string const &attr_name) const;

2642 11 __setattr__ 0 4 3544 23 LVecBase4f::__setattr__ 0 1 786 0
99
inline int LVecBase4f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2643 11 operator [] 0 4 3544 23 LVecBase4f::operator [] 0 2 787 788 10
/**
 *
 */
96
inline float LVecBase4f::operator [](int i) const;
inline float &LVecBase4f::operator [](int i);

2644 4 size 0 4 3544 16 LVecBase4f::size 0 1 789 0
44
static constexpr int LVecBase4f::size(void);

2645 6 is_nan 0 4 3544 18 LVecBase4f::is_nan 0 1 790 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase4f::is_nan(void) const;

2646 8 get_cell 0 4 3544 20 LVecBase4f::get_cell 0 1 791 10
/**
 *
 */
47
inline float LVecBase4f::get_cell(int i) const;

2647 8 set_cell 0 4 3544 20 LVecBase4f::set_cell 0 1 792 10
/**
 *
 */
53
inline void LVecBase4f::set_cell(int i, float value);

2648 5 get_x 0 4 3544 17 LVecBase4f::get_x 0 1 793 10
/**
 *
 */
43
inline float LVecBase4f::get_x(void) const;

2649 5 get_y 0 4 3544 17 LVecBase4f::get_y 0 1 794 10
/**
 *
 */
43
inline float LVecBase4f::get_y(void) const;

2650 5 get_z 0 4 3544 17 LVecBase4f::get_z 0 1 795 10
/**
 *
 */
43
inline float LVecBase4f::get_z(void) const;

2651 5 get_w 0 4 3544 17 LVecBase4f::get_w 0 1 796 10
/**
 *
 */
43
inline float LVecBase4f::get_w(void) const;

2652 7 get_xyz 0 4 3544 19 LVecBase4f::get_xyz 0 1 797 58
/**
 * Returns the x, y and z component of this vector
 */
50
inline LVecBase3f LVecBase4f::get_xyz(void) const;

2653 6 get_xy 0 4 3544 18 LVecBase4f::get_xy 0 1 798 55
/**
 * Returns the x and y component of this vector
 */
49
inline LVecBase2f LVecBase4f::get_xy(void) const;

2654 5 set_x 0 4 3544 17 LVecBase4f::set_x 0 1 799 10
/**
 *
 */
43
inline void LVecBase4f::set_x(float value);

2655 5 set_y 0 4 3544 17 LVecBase4f::set_y 0 1 800 10
/**
 *
 */
43
inline void LVecBase4f::set_y(float value);

2656 5 set_z 0 4 3544 17 LVecBase4f::set_z 0 1 801 10
/**
 *
 */
43
inline void LVecBase4f::set_z(float value);

2657 5 set_w 0 4 3544 17 LVecBase4f::set_w 0 1 802 10
/**
 *
 */
43
inline void LVecBase4f::set_w(float value);

2658 11 add_to_cell 0 4 3544 23 LVecBase4f::add_to_cell 0 1 803 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
56
inline void LVecBase4f::add_to_cell(int i, float value);

2659 5 add_x 0 4 3544 17 LVecBase4f::add_x 0 1 804 10
/**
 *
 */
43
inline void LVecBase4f::add_x(float value);

2660 5 add_y 0 4 3544 17 LVecBase4f::add_y 0 1 805 10
/**
 *
 */
43
inline void LVecBase4f::add_y(float value);

2661 5 add_z 0 4 3544 17 LVecBase4f::add_z 0 1 806 10
/**
 *
 */
43
inline void LVecBase4f::add_z(float value);

2662 5 add_w 0 4 3544 17 LVecBase4f::add_w 0 1 807 10
/**
 *
 */
43
inline void LVecBase4f::add_w(float value);

2663 8 get_data 0 4 3544 20 LVecBase4f::get_data 0 1 808 161
/**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
53
inline float const *LVecBase4f::get_data(void) const;

2664 18 get_num_components 0 4 3544 30 LVecBase4f::get_num_components 0 1 809 0
58
static constexpr int LVecBase4f::get_num_components(void);

2665 12 extract_data 0 4 3544 24 LVecBase4f::extract_data 0 0 0
46
inline void LVecBase4f::extract_data(float *);

2666 4 fill 0 4 3544 16 LVecBase4f::fill 0 1 810 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
47
inline void LVecBase4f::fill(float fill_value);

2667 3 set 0 4 3544 15 LVecBase4f::set 0 1 811 10
/**
 *
 */
64
inline void LVecBase4f::set(float x, float y, float z, float w);

2668 3 dot 0 4 3544 15 LVecBase4f::dot 0 1 812 10
/**
 *
 */
60
inline float LVecBase4f::dot(LVecBase4f const &other) const;

2669 14 length_squared 0 4 3544 26 LVecBase4f::length_squared 0 1 813 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
52
inline float LVecBase4f::length_squared(void) const;

2670 6 length 0 4 3544 18 LVecBase4f::length 0 1 814 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
44
inline float LVecBase4f::length(void) const;

2671 9 normalize 0 4 3544 21 LVecBase4f::normalize 0 1 815 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase4f::normalize(void);

2672 10 normalized 0 4 3544 22 LVecBase4f::normalized 0 1 816 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase4f LVecBase4f::normalized(void) const;

2673 7 project 0 4 3544 19 LVecBase4f::project 0 1 817 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase4f LVecBase4f::project(LVecBase4f const &onto) const;

2674 10 operator < 0 4 3544 22 LVecBase4f::operator < 0 1 818 0
66
inline bool LVecBase4f::operator <(LVecBase4f const &other) const;

2675 11 operator == 0 4 3544 23 LVecBase4f::operator == 0 1 819 0
67
inline bool LVecBase4f::operator ==(LVecBase4f const &other) const;

2676 11 operator != 0 4 3544 23 LVecBase4f::operator != 0 1 820 0
67
inline bool LVecBase4f::operator !=(LVecBase4f const &other) const;

2677 10 compare_to 0 4 3544 22 LVecBase4f::compare_to 0 2 821 822 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
148
inline int LVecBase4f::compare_to(LVecBase4f const &other) const;
inline int LVecBase4f::compare_to(LVecBase4f const &other, float threshold) const;

2678 8 get_hash 0 4 3544 20 LVecBase4f::get_hash 0 2 823 824 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
116
inline std::size_t LVecBase4f::get_hash(void) const;
inline std::size_t LVecBase4f::get_hash(float threshold) const;

2679 8 add_hash 0 4 3544 20 LVecBase4f::add_hash 0 2 825 826 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
146
inline std::size_t LVecBase4f::add_hash(std::size_t hash) const;
inline std::size_t LVecBase4f::add_hash(std::size_t hash, float threshold) const;

2680 13 generate_hash 0 4 3544 25 LVecBase4f::generate_hash 0 2 827 828 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
170
inline void LVecBase4f::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase4f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

2681 10 operator - 0 68 3544 22 LVecBase4f::operator - 0 1 829 0
53
inline LVecBase4f LVecBase4f::operator -(void) const;

2682 10 operator + 0 4 3544 22 LVecBase4f::operator + 0 1 830 0
72
inline LVecBase4f LVecBase4f::operator +(LVecBase4f const &other) const;

2683 10 operator - 0 4 3544 22 LVecBase4f::operator - 0 1 831 0
72
inline LVecBase4f LVecBase4f::operator -(LVecBase4f const &other) const;

2684 10 operator * 0 4 3544 22 LVecBase4f::operator * 0 1 832 0
61
inline LVecBase4f LVecBase4f::operator *(float scalar) const;

2685 10 operator / 0 4 3544 22 LVecBase4f::operator / 0 1 833 0
61
inline LVecBase4f LVecBase4f::operator /(float scalar) const;

2686 11 operator += 0 4 3544 23 LVecBase4f::operator += 0 1 834 0
61
inline void LVecBase4f::operator +=(LVecBase4f const &other);

2687 11 operator -= 0 4 3544 23 LVecBase4f::operator -= 0 1 835 0
61
inline void LVecBase4f::operator -=(LVecBase4f const &other);

2688 11 operator *= 0 4 3544 23 LVecBase4f::operator *= 0 1 836 0
50
inline void LVecBase4f::operator *=(float scalar);

2689 11 operator /= 0 4 3544 23 LVecBase4f::operator /= 0 1 837 0
50
inline void LVecBase4f::operator /=(float scalar);

2690 18 componentwise_mult 0 4 3544 30 LVecBase4f::componentwise_mult 0 1 838 10
/**
 *
 */
68
inline void LVecBase4f::componentwise_mult(LVecBase4f const &other);

2691 7 __pow__ 0 4 3544 19 LVecBase4f::__pow__ 0 1 839 0
60
inline LVecBase4f LVecBase4f::__pow__(float exponent) const;

2692 8 __ipow__ 0 4 3544 20 LVecBase4f::__ipow__ 0 1 840 0
70
inline PyObject *LVecBase4f::__ipow__(PyObject *self, float exponent);

2693 4 fmax 0 4 3544 16 LVecBase4f::fmax 0 1 841 10
/**
 *
 */
66
inline LVecBase4f LVecBase4f::fmax(LVecBase4f const &other) const;

2694 4 fmin 0 4 3544 16 LVecBase4f::fmin 0 1 842 10
/**
 *
 */
66
inline LVecBase4f LVecBase4f::fmin(LVecBase4f const &other) const;

2695 12 almost_equal 0 4 3544 24 LVecBase4f::almost_equal 0 2 843 844 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
154
inline bool LVecBase4f::almost_equal(LVecBase4f const &other, float threshold) const;
inline bool LVecBase4f::almost_equal(LVecBase4f const &other) const;

2696 6 output 0 4 3544 18 LVecBase4f::output 0 1 845 10
/**
 *
 */
56
inline void LVecBase4f::output(std::ostream &out) const;

2697 8 __repr__ 0 4 3544 20 LVecBase4f::__repr__ 0 1 846 0
52
inline std::string LVecBase4f::__repr__(void) const;

2698 20 write_datagram_fixed 0 4 3544 32 LVecBase4f::write_datagram_fixed 0 1 847 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase4f::write_datagram_fixed(Datagram &destination) const;

2699 19 read_datagram_fixed 0 4 3544 31 LVecBase4f::read_datagram_fixed 0 1 848 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase4f::read_datagram_fixed(DatagramIterator &source);

2700 14 write_datagram 0 4 3544 26 LVecBase4f::write_datagram 0 1 849 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase4f::write_datagram(Datagram &destination) const;

2701 13 read_datagram 0 4 3544 25 LVecBase4f::read_datagram 0 1 850 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase4f::read_datagram(DatagramIterator &source);

2702 14 get_class_type 0 4 3544 26 LVecBase4f::get_class_type 0 1 851 0
51
static TypeHandle LVecBase4f::get_class_type(void);

2703 11 ~LVecBase4f 0 4 3544 23 LVecBase4f::~LVecBase4f 0 0 0
30
LVecBase4f::~LVecBase4f(void);

2704 19 UnalignedLVecBase4f 0 4 3546 40 UnalignedLVecBase4f::UnalignedLVecBase4f 0 5 852 853 854 855 856 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
377
inline UnalignedLVecBase4f::UnalignedLVecBase4f(void) = default;
inline UnalignedLVecBase4f::UnalignedLVecBase4f(LVecBase4f const &copy);
inline UnalignedLVecBase4f::UnalignedLVecBase4f(float fill_value);
inline UnalignedLVecBase4f::UnalignedLVecBase4f(float x, float y, float z, float w);
inline UnalignedLVecBase4f::UnalignedLVecBase4f(UnalignedLVecBase4f const &) = default;

2705 4 fill 0 4 3546 25 UnalignedLVecBase4f::fill 0 1 857 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
56
inline void UnalignedLVecBase4f::fill(float fill_value);

2706 3 set 0 4 3546 24 UnalignedLVecBase4f::set 0 1 858 10
/**
 *
 */
73
inline void UnalignedLVecBase4f::set(float x, float y, float z, float w);

2707 11 operator [] 0 4 3546 32 UnalignedLVecBase4f::operator [] 0 2 859 860 10
/**
 *
 */
114
inline float UnalignedLVecBase4f::operator [](int i) const;
inline float &UnalignedLVecBase4f::operator [](int i);

2708 4 size 0 4 3546 25 UnalignedLVecBase4f::size 0 1 861 0
53
static constexpr int UnalignedLVecBase4f::size(void);

2709 8 get_data 0 4 3546 29 UnalignedLVecBase4f::get_data 0 1 862 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
62
inline float const *UnalignedLVecBase4f::get_data(void) const;

2710 18 get_num_components 0 4 3546 39 UnalignedLVecBase4f::get_num_components 0 1 863 0
67
static constexpr int UnalignedLVecBase4f::get_num_components(void);

2711 11 operator == 0 4 3546 32 UnalignedLVecBase4f::operator == 0 1 864 0
85
inline bool UnalignedLVecBase4f::operator ==(UnalignedLVecBase4f const &other) const;

2712 11 operator != 0 4 3546 32 UnalignedLVecBase4f::operator != 0 1 865 0
85
inline bool UnalignedLVecBase4f::operator !=(UnalignedLVecBase4f const &other) const;

2713 14 get_class_type 0 4 3546 35 UnalignedLVecBase4f::get_class_type 0 1 866 0
60
static TypeHandle UnalignedLVecBase4f::get_class_type(void);

2714 20 ~UnalignedLVecBase4f 0 4 3546 41 UnalignedLVecBase4f::~UnalignedLVecBase4f 0 0 0
48
UnalignedLVecBase4f::~UnalignedLVecBase4f(void);

2715 10 LVecBase4d 0 4 3548 22 LVecBase4d::LVecBase4d 0 8 867 868 869 870 871 872 873 874 219
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */

/**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */
467
inline LVecBase4d::LVecBase4d(void) = default;
inline LVecBase4d::LVecBase4d(double fill_value);
inline LVecBase4d::LVecBase4d(double x, double y, double z, double w);
inline LVecBase4d::LVecBase4d(UnalignedLVecBase4d const &copy);
inline LVecBase4d::LVecBase4d(LVecBase3d const &copy, double w);
inline LVecBase4d::LVecBase4d(LPoint3d const &point);
inline LVecBase4d::LVecBase4d(LVector3d const &vector);
inline LVecBase4d::LVecBase4d(LVecBase4d const &) = default;

2716 12 operator new 0 4 3548 24 LVecBase4d::operator new 0 1 875 0
124
inline void *LVecBase4d::operator new(std::size_t size);
inline void *LVecBase4d::operator new(std::size_t size, void *ptr);

2717 15 operator delete 0 4 3548 27 LVecBase4d::operator delete 0 0 0
108
inline void LVecBase4d::operator delete(void *ptr);
inline void LVecBase4d::operator delete(void *, void *);

2718 12 validate_ptr 0 4 3548 24 LVecBase4d::validate_ptr 0 0 0
61
static inline bool LVecBase4d::validate_ptr(void const *ptr);

2719 10 operator = 0 4 3548 22 LVecBase4d::operator = 0 2 876 877 0
120
void LVecBase4d::operator =(LVecBase4d const &copy) = default;
void LVecBase4d::operator =(double fill_value) = default;

2720 4 zero 0 4 3548 16 LVecBase4d::zero 0 1 878 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase4d const &LVecBase4d::zero(void);

2721 6 unit_x 0 4 3548 18 LVecBase4d::unit_x 0 1 879 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_x(void);

2722 6 unit_y 0 4 3548 18 LVecBase4d::unit_y 0 1 880 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_y(void);

2723 6 unit_z 0 4 3548 18 LVecBase4d::unit_z 0 1 881 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_z(void);

2724 6 unit_w 0 4 3548 18 LVecBase4d::unit_w 0 1 882 35
/**
 * Returns a unit W vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_w(void);

2725 10 __reduce__ 0 4 3548 22 LVecBase4d::__reduce__ 0 1 883 0
62
inline PyObject *LVecBase4d::__reduce__(PyObject *self) const;

2726 11 __getattr__ 0 4 3548 23 LVecBase4d::__getattr__ 0 1 884 0
93
inline PyObject *LVecBase4d::__getattr__(PyObject *self, std::string const &attr_name) const;

2727 11 __setattr__ 0 4 3548 23 LVecBase4d::__setattr__ 0 1 885 0
99
inline int LVecBase4d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2728 11 operator [] 0 4 3548 23 LVecBase4d::operator [] 0 2 886 887 10
/**
 *
 */
98
inline double LVecBase4d::operator [](int i) const;
inline double &LVecBase4d::operator [](int i);

2729 4 size 0 4 3548 16 LVecBase4d::size 0 1 888 0
44
static constexpr int LVecBase4d::size(void);

2730 6 is_nan 0 4 3548 18 LVecBase4d::is_nan 0 1 889 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase4d::is_nan(void) const;

2731 8 get_cell 0 4 3548 20 LVecBase4d::get_cell 0 1 890 10
/**
 *
 */
48
inline double LVecBase4d::get_cell(int i) const;

2732 8 set_cell 0 4 3548 20 LVecBase4d::set_cell 0 1 891 10
/**
 *
 */
54
inline void LVecBase4d::set_cell(int i, double value);

2733 5 get_x 0 4 3548 17 LVecBase4d::get_x 0 1 892 10
/**
 *
 */
44
inline double LVecBase4d::get_x(void) const;

2734 5 get_y 0 4 3548 17 LVecBase4d::get_y 0 1 893 10
/**
 *
 */
44
inline double LVecBase4d::get_y(void) const;

2735 5 get_z 0 4 3548 17 LVecBase4d::get_z 0 1 894 10
/**
 *
 */
44
inline double LVecBase4d::get_z(void) const;

2736 5 get_w 0 4 3548 17 LVecBase4d::get_w 0 1 895 10
/**
 *
 */
44
inline double LVecBase4d::get_w(void) const;

2737 7 get_xyz 0 4 3548 19 LVecBase4d::get_xyz 0 1 896 58
/**
 * Returns the x, y and z component of this vector
 */
50
inline LVecBase3d LVecBase4d::get_xyz(void) const;

2738 6 get_xy 0 4 3548 18 LVecBase4d::get_xy 0 1 897 55
/**
 * Returns the x and y component of this vector
 */
49
inline LVecBase2d LVecBase4d::get_xy(void) const;

2739 5 set_x 0 4 3548 17 LVecBase4d::set_x 0 1 898 10
/**
 *
 */
44
inline void LVecBase4d::set_x(double value);

2740 5 set_y 0 4 3548 17 LVecBase4d::set_y 0 1 899 10
/**
 *
 */
44
inline void LVecBase4d::set_y(double value);

2741 5 set_z 0 4 3548 17 LVecBase4d::set_z 0 1 900 10
/**
 *
 */
44
inline void LVecBase4d::set_z(double value);

2742 5 set_w 0 4 3548 17 LVecBase4d::set_w 0 1 901 10
/**
 *
 */
44
inline void LVecBase4d::set_w(double value);

2743 11 add_to_cell 0 4 3548 23 LVecBase4d::add_to_cell 0 1 902 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
57
inline void LVecBase4d::add_to_cell(int i, double value);

2744 5 add_x 0 4 3548 17 LVecBase4d::add_x 0 1 903 10
/**
 *
 */
44
inline void LVecBase4d::add_x(double value);

2745 5 add_y 0 4 3548 17 LVecBase4d::add_y 0 1 904 10
/**
 *
 */
44
inline void LVecBase4d::add_y(double value);

2746 5 add_z 0 4 3548 17 LVecBase4d::add_z 0 1 905 10
/**
 *
 */
44
inline void LVecBase4d::add_z(double value);

2747 5 add_w 0 4 3548 17 LVecBase4d::add_w 0 1 906 10
/**
 *
 */
44
inline void LVecBase4d::add_w(double value);

2748 8 get_data 0 4 3548 20 LVecBase4d::get_data 0 1 907 161
/**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
54
inline double const *LVecBase4d::get_data(void) const;

2749 18 get_num_components 0 4 3548 30 LVecBase4d::get_num_components 0 1 908 0
58
static constexpr int LVecBase4d::get_num_components(void);

2750 12 extract_data 0 4 3548 24 LVecBase4d::extract_data 0 0 0
46
inline void LVecBase4d::extract_data(float *);

2751 4 fill 0 4 3548 16 LVecBase4d::fill 0 1 909 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
48
inline void LVecBase4d::fill(double fill_value);

2752 3 set 0 4 3548 15 LVecBase4d::set 0 1 910 10
/**
 *
 */
68
inline void LVecBase4d::set(double x, double y, double z, double w);

2753 3 dot 0 4 3548 15 LVecBase4d::dot 0 1 911 10
/**
 *
 */
61
inline double LVecBase4d::dot(LVecBase4d const &other) const;

2754 14 length_squared 0 4 3548 26 LVecBase4d::length_squared 0 1 912 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
53
inline double LVecBase4d::length_squared(void) const;

2755 6 length 0 4 3548 18 LVecBase4d::length 0 1 913 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
45
inline double LVecBase4d::length(void) const;

2756 9 normalize 0 4 3548 21 LVecBase4d::normalize 0 1 914 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase4d::normalize(void);

2757 10 normalized 0 4 3548 22 LVecBase4d::normalized 0 1 915 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase4d LVecBase4d::normalized(void) const;

2758 7 project 0 4 3548 19 LVecBase4d::project 0 1 916 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase4d LVecBase4d::project(LVecBase4d const &onto) const;

2759 10 operator < 0 4 3548 22 LVecBase4d::operator < 0 1 917 0
66
inline bool LVecBase4d::operator <(LVecBase4d const &other) const;

2760 11 operator == 0 4 3548 23 LVecBase4d::operator == 0 1 918 0
67
inline bool LVecBase4d::operator ==(LVecBase4d const &other) const;

2761 11 operator != 0 4 3548 23 LVecBase4d::operator != 0 1 919 0
67
inline bool LVecBase4d::operator !=(LVecBase4d const &other) const;

2762 10 compare_to 0 4 3548 22 LVecBase4d::compare_to 0 2 920 921 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
149
inline int LVecBase4d::compare_to(LVecBase4d const &other) const;
inline int LVecBase4d::compare_to(LVecBase4d const &other, double threshold) const;

2763 8 get_hash 0 4 3548 20 LVecBase4d::get_hash 0 2 922 923 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
117
inline std::size_t LVecBase4d::get_hash(void) const;
inline std::size_t LVecBase4d::get_hash(double threshold) const;

2764 8 add_hash 0 4 3548 20 LVecBase4d::add_hash 0 2 924 925 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
147
inline std::size_t LVecBase4d::add_hash(std::size_t hash) const;
inline std::size_t LVecBase4d::add_hash(std::size_t hash, double threshold) const;

2765 13 generate_hash 0 4 3548 25 LVecBase4d::generate_hash 0 2 926 927 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
171
inline void LVecBase4d::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase4d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

2766 10 operator - 0 68 3548 22 LVecBase4d::operator - 0 1 928 0
53
inline LVecBase4d LVecBase4d::operator -(void) const;

2767 10 operator + 0 4 3548 22 LVecBase4d::operator + 0 1 929 0
72
inline LVecBase4d LVecBase4d::operator +(LVecBase4d const &other) const;

2768 10 operator - 0 4 3548 22 LVecBase4d::operator - 0 1 930 0
72
inline LVecBase4d LVecBase4d::operator -(LVecBase4d const &other) const;

2769 10 operator * 0 4 3548 22 LVecBase4d::operator * 0 1 931 0
62
inline LVecBase4d LVecBase4d::operator *(double scalar) const;

2770 10 operator / 0 4 3548 22 LVecBase4d::operator / 0 1 932 0
62
inline LVecBase4d LVecBase4d::operator /(double scalar) const;

2771 11 operator += 0 4 3548 23 LVecBase4d::operator += 0 1 933 0
61
inline void LVecBase4d::operator +=(LVecBase4d const &other);

2772 11 operator -= 0 4 3548 23 LVecBase4d::operator -= 0 1 934 0
61
inline void LVecBase4d::operator -=(LVecBase4d const &other);

2773 11 operator *= 0 4 3548 23 LVecBase4d::operator *= 0 1 935 0
51
inline void LVecBase4d::operator *=(double scalar);

2774 11 operator /= 0 4 3548 23 LVecBase4d::operator /= 0 1 936 0
51
inline void LVecBase4d::operator /=(double scalar);

2775 18 componentwise_mult 0 4 3548 30 LVecBase4d::componentwise_mult 0 1 937 10
/**
 *
 */
68
inline void LVecBase4d::componentwise_mult(LVecBase4d const &other);

2776 7 __pow__ 0 4 3548 19 LVecBase4d::__pow__ 0 1 938 0
61
inline LVecBase4d LVecBase4d::__pow__(double exponent) const;

2777 8 __ipow__ 0 4 3548 20 LVecBase4d::__ipow__ 0 1 939 0
71
inline PyObject *LVecBase4d::__ipow__(PyObject *self, double exponent);

2778 4 fmax 0 4 3548 16 LVecBase4d::fmax 0 1 940 10
/**
 *
 */
66
inline LVecBase4d LVecBase4d::fmax(LVecBase4d const &other) const;

2779 4 fmin 0 4 3548 16 LVecBase4d::fmin 0 1 941 10
/**
 *
 */
66
inline LVecBase4d LVecBase4d::fmin(LVecBase4d const &other) const;

2780 12 almost_equal 0 4 3548 24 LVecBase4d::almost_equal 0 2 942 943 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
155
inline bool LVecBase4d::almost_equal(LVecBase4d const &other, double threshold) const;
inline bool LVecBase4d::almost_equal(LVecBase4d const &other) const;

2781 6 output 0 4 3548 18 LVecBase4d::output 0 1 944 10
/**
 *
 */
56
inline void LVecBase4d::output(std::ostream &out) const;

2782 8 __repr__ 0 4 3548 20 LVecBase4d::__repr__ 0 1 945 0
52
inline std::string LVecBase4d::__repr__(void) const;

2783 20 write_datagram_fixed 0 4 3548 32 LVecBase4d::write_datagram_fixed 0 1 946 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase4d::write_datagram_fixed(Datagram &destination) const;

2784 19 read_datagram_fixed 0 4 3548 31 LVecBase4d::read_datagram_fixed 0 1 947 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase4d::read_datagram_fixed(DatagramIterator &source);

2785 14 write_datagram 0 4 3548 26 LVecBase4d::write_datagram 0 1 948 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase4d::write_datagram(Datagram &destination) const;

2786 13 read_datagram 0 4 3548 25 LVecBase4d::read_datagram 0 1 949 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase4d::read_datagram(DatagramIterator &source);

2787 14 get_class_type 0 4 3548 26 LVecBase4d::get_class_type 0 1 950 0
51
static TypeHandle LVecBase4d::get_class_type(void);

2788 11 ~LVecBase4d 0 4 3548 23 LVecBase4d::~LVecBase4d 0 0 0
30
LVecBase4d::~LVecBase4d(void);

2789 19 UnalignedLVecBase4d 0 4 3550 40 UnalignedLVecBase4d::UnalignedLVecBase4d 0 5 951 952 953 954 955 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
382
inline UnalignedLVecBase4d::UnalignedLVecBase4d(void) = default;
inline UnalignedLVecBase4d::UnalignedLVecBase4d(LVecBase4d const &copy);
inline UnalignedLVecBase4d::UnalignedLVecBase4d(double fill_value);
inline UnalignedLVecBase4d::UnalignedLVecBase4d(double x, double y, double z, double w);
inline UnalignedLVecBase4d::UnalignedLVecBase4d(UnalignedLVecBase4d const &) = default;

2790 4 fill 0 4 3550 25 UnalignedLVecBase4d::fill 0 1 956 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
57
inline void UnalignedLVecBase4d::fill(double fill_value);

2791 3 set 0 4 3550 24 UnalignedLVecBase4d::set 0 1 957 10
/**
 *
 */
77
inline void UnalignedLVecBase4d::set(double x, double y, double z, double w);

2792 11 operator [] 0 4 3550 32 UnalignedLVecBase4d::operator [] 0 2 958 959 10
/**
 *
 */
116
inline double UnalignedLVecBase4d::operator [](int i) const;
inline double &UnalignedLVecBase4d::operator [](int i);

2793 4 size 0 4 3550 25 UnalignedLVecBase4d::size 0 1 960 0
53
static constexpr int UnalignedLVecBase4d::size(void);

2794 8 get_data 0 4 3550 29 UnalignedLVecBase4d::get_data 0 1 961 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
63
inline double const *UnalignedLVecBase4d::get_data(void) const;

2795 18 get_num_components 0 4 3550 39 UnalignedLVecBase4d::get_num_components 0 1 962 0
67
static constexpr int UnalignedLVecBase4d::get_num_components(void);

2796 11 operator == 0 4 3550 32 UnalignedLVecBase4d::operator == 0 1 963 0
85
inline bool UnalignedLVecBase4d::operator ==(UnalignedLVecBase4d const &other) const;

2797 11 operator != 0 4 3550 32 UnalignedLVecBase4d::operator != 0 1 964 0
85
inline bool UnalignedLVecBase4d::operator !=(UnalignedLVecBase4d const &other) const;

2798 14 get_class_type 0 4 3550 35 UnalignedLVecBase4d::get_class_type 0 1 965 0
60
static TypeHandle UnalignedLVecBase4d::get_class_type(void);

2799 20 ~UnalignedLVecBase4d 0 4 3550 41 UnalignedLVecBase4d::~UnalignedLVecBase4d 0 0 0
48
UnalignedLVecBase4d::~UnalignedLVecBase4d(void);

2800 10 LVecBase4i 0 4 3552 22 LVecBase4i::LVecBase4i 0 8 966 967 968 969 970 971 972 973 219
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */

/**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */
449
inline LVecBase4i::LVecBase4i(void) = default;
inline LVecBase4i::LVecBase4i(int fill_value);
inline LVecBase4i::LVecBase4i(int x, int y, int z, int w);
inline LVecBase4i::LVecBase4i(UnalignedLVecBase4i const &copy);
inline LVecBase4i::LVecBase4i(LVecBase3i const &copy, int w);
inline LVecBase4i::LVecBase4i(LPoint3i const &point);
inline LVecBase4i::LVecBase4i(LVector3i const &vector);
inline LVecBase4i::LVecBase4i(LVecBase4i const &) = default;

2801 12 operator new 0 4 3552 24 LVecBase4i::operator new 0 1 974 0
124
inline void *LVecBase4i::operator new(std::size_t size);
inline void *LVecBase4i::operator new(std::size_t size, void *ptr);

2802 15 operator delete 0 4 3552 27 LVecBase4i::operator delete 0 0 0
108
inline void LVecBase4i::operator delete(void *ptr);
inline void LVecBase4i::operator delete(void *, void *);

2803 12 validate_ptr 0 4 3552 24 LVecBase4i::validate_ptr 0 0 0
61
static inline bool LVecBase4i::validate_ptr(void const *ptr);

2804 10 operator = 0 4 3552 22 LVecBase4i::operator = 0 2 975 976 0
117
void LVecBase4i::operator =(LVecBase4i const &copy) = default;
void LVecBase4i::operator =(int fill_value) = default;

2805 4 zero 0 4 3552 16 LVecBase4i::zero 0 1 977 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase4i const &LVecBase4i::zero(void);

2806 6 unit_x 0 4 3552 18 LVecBase4i::unit_x 0 1 978 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_x(void);

2807 6 unit_y 0 4 3552 18 LVecBase4i::unit_y 0 1 979 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_y(void);

2808 6 unit_z 0 4 3552 18 LVecBase4i::unit_z 0 1 980 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_z(void);

2809 6 unit_w 0 4 3552 18 LVecBase4i::unit_w 0 1 981 35
/**
 * Returns a unit W vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_w(void);

2810 10 __reduce__ 0 4 3552 22 LVecBase4i::__reduce__ 0 1 982 0
62
inline PyObject *LVecBase4i::__reduce__(PyObject *self) const;

2811 11 __getattr__ 0 4 3552 23 LVecBase4i::__getattr__ 0 1 983 0
93
inline PyObject *LVecBase4i::__getattr__(PyObject *self, std::string const &attr_name) const;

2812 11 __setattr__ 0 4 3552 23 LVecBase4i::__setattr__ 0 1 984 0
99
inline int LVecBase4i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2813 11 operator [] 0 4 3552 23 LVecBase4i::operator [] 0 2 985 986 10
/**
 *
 */
92
inline int LVecBase4i::operator [](int i) const;
inline int &LVecBase4i::operator [](int i);

2814 4 size 0 4 3552 16 LVecBase4i::size 0 1 987 0
44
static constexpr int LVecBase4i::size(void);

2815 6 is_nan 0 4 3552 18 LVecBase4i::is_nan 0 1 988 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase4i::is_nan(void) const;

2816 8 get_cell 0 4 3552 20 LVecBase4i::get_cell 0 1 989 10
/**
 *
 */
45
inline int LVecBase4i::get_cell(int i) const;

2817 8 set_cell 0 4 3552 20 LVecBase4i::set_cell 0 1 990 10
/**
 *
 */
51
inline void LVecBase4i::set_cell(int i, int value);

2818 5 get_x 0 4 3552 17 LVecBase4i::get_x 0 1 991 10
/**
 *
 */
41
inline int LVecBase4i::get_x(void) const;

2819 5 get_y 0 4 3552 17 LVecBase4i::get_y 0 1 992 10
/**
 *
 */
41
inline int LVecBase4i::get_y(void) const;

2820 5 get_z 0 4 3552 17 LVecBase4i::get_z 0 1 993 10
/**
 *
 */
41
inline int LVecBase4i::get_z(void) const;

2821 5 get_w 0 4 3552 17 LVecBase4i::get_w 0 1 994 10
/**
 *
 */
41
inline int LVecBase4i::get_w(void) const;

2822 7 get_xyz 0 4 3552 19 LVecBase4i::get_xyz 0 1 995 58
/**
 * Returns the x, y and z component of this vector
 */
50
inline LVecBase3i LVecBase4i::get_xyz(void) const;

2823 6 get_xy 0 4 3552 18 LVecBase4i::get_xy 0 1 996 55
/**
 * Returns the x and y component of this vector
 */
49
inline LVecBase2i LVecBase4i::get_xy(void) const;

2824 5 set_x 0 4 3552 17 LVecBase4i::set_x 0 1 997 10
/**
 *
 */
41
inline void LVecBase4i::set_x(int value);

2825 5 set_y 0 4 3552 17 LVecBase4i::set_y 0 1 998 10
/**
 *
 */
41
inline void LVecBase4i::set_y(int value);

2826 5 set_z 0 4 3552 17 LVecBase4i::set_z 0 1 999 10
/**
 *
 */
41
inline void LVecBase4i::set_z(int value);

2827 5 set_w 0 4 3552 17 LVecBase4i::set_w 0 1 1000 10
/**
 *
 */
41
inline void LVecBase4i::set_w(int value);

2828 11 add_to_cell 0 4 3552 23 LVecBase4i::add_to_cell 0 1 1001 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
54
inline void LVecBase4i::add_to_cell(int i, int value);

2829 5 add_x 0 4 3552 17 LVecBase4i::add_x 0 1 1002 10
/**
 *
 */
41
inline void LVecBase4i::add_x(int value);

2830 5 add_y 0 4 3552 17 LVecBase4i::add_y 0 1 1003 10
/**
 *
 */
41
inline void LVecBase4i::add_y(int value);

2831 5 add_z 0 4 3552 17 LVecBase4i::add_z 0 1 1004 10
/**
 *
 */
41
inline void LVecBase4i::add_z(int value);

2832 5 add_w 0 4 3552 17 LVecBase4i::add_w 0 1 1005 10
/**
 *
 */
41
inline void LVecBase4i::add_w(int value);

2833 8 get_data 0 4 3552 20 LVecBase4i::get_data 0 1 1006 161
/**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
51
inline int const *LVecBase4i::get_data(void) const;

2834 18 get_num_components 0 4 3552 30 LVecBase4i::get_num_components 0 1 1007 0
58
static constexpr int LVecBase4i::get_num_components(void);

2835 12 extract_data 0 4 3552 24 LVecBase4i::extract_data 0 0 0
46
inline void LVecBase4i::extract_data(float *);

2836 4 fill 0 4 3552 16 LVecBase4i::fill 0 1 1008 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
45
inline void LVecBase4i::fill(int fill_value);

2837 3 set 0 4 3552 15 LVecBase4i::set 0 1 1009 10
/**
 *
 */
56
inline void LVecBase4i::set(int x, int y, int z, int w);

2838 3 dot 0 4 3552 15 LVecBase4i::dot 0 1 1010 10
/**
 *
 */
58
inline int LVecBase4i::dot(LVecBase4i const &other) const;

2839 14 length_squared 0 4 3552 26 LVecBase4i::length_squared 0 1 1011 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
50
inline int LVecBase4i::length_squared(void) const;

2840 10 operator < 0 4 3552 22 LVecBase4i::operator < 0 1 1012 0
66
inline bool LVecBase4i::operator <(LVecBase4i const &other) const;

2841 11 operator == 0 4 3552 23 LVecBase4i::operator == 0 1 1013 0
67
inline bool LVecBase4i::operator ==(LVecBase4i const &other) const;

2842 11 operator != 0 4 3552 23 LVecBase4i::operator != 0 1 1014 0
67
inline bool LVecBase4i::operator !=(LVecBase4i const &other) const;

2843 10 compare_to 0 4 3552 22 LVecBase4i::compare_to 0 1 1015 97
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */
65
inline int LVecBase4i::compare_to(LVecBase4i const &other) const;

2844 8 get_hash 0 4 3552 20 LVecBase4i::get_hash 0 1 1016 49
/**
 * Returns a suitable hash for phash_map.
 */
52
inline std::size_t LVecBase4i::get_hash(void) const;

2845 8 add_hash 0 4 3552 20 LVecBase4i::add_hash 0 1 1017 49
/**
 * Adds the vector into the running hash.
 */
64
inline std::size_t LVecBase4i::add_hash(std::size_t hash) const;

2846 13 generate_hash 0 4 3552 25 LVecBase4i::generate_hash 0 1 1018 59
/**
 * Adds the vector to the indicated hash generator.
 */
76
inline void LVecBase4i::generate_hash(ChecksumHashGenerator &hashgen) const;

2847 10 operator - 0 68 3552 22 LVecBase4i::operator - 0 1 1019 0
53
inline LVecBase4i LVecBase4i::operator -(void) const;

2848 10 operator + 0 4 3552 22 LVecBase4i::operator + 0 1 1020 0
72
inline LVecBase4i LVecBase4i::operator +(LVecBase4i const &other) const;

2849 10 operator - 0 4 3552 22 LVecBase4i::operator - 0 1 1021 0
72
inline LVecBase4i LVecBase4i::operator -(LVecBase4i const &other) const;

2850 10 operator * 0 4 3552 22 LVecBase4i::operator * 0 1 1022 0
59
inline LVecBase4i LVecBase4i::operator *(int scalar) const;

2851 10 operator / 0 4 3552 22 LVecBase4i::operator / 0 1 1023 0
59
inline LVecBase4i LVecBase4i::operator /(int scalar) const;

2852 11 operator += 0 4 3552 23 LVecBase4i::operator += 0 1 1024 0
61
inline void LVecBase4i::operator +=(LVecBase4i const &other);

2853 11 operator -= 0 4 3552 23 LVecBase4i::operator -= 0 1 1025 0
61
inline void LVecBase4i::operator -=(LVecBase4i const &other);

2854 11 operator *= 0 4 3552 23 LVecBase4i::operator *= 0 1 1026 0
48
inline void LVecBase4i::operator *=(int scalar);

2855 11 operator /= 0 4 3552 23 LVecBase4i::operator /= 0 1 1027 0
48
inline void LVecBase4i::operator /=(int scalar);

2856 18 componentwise_mult 0 4 3552 30 LVecBase4i::componentwise_mult 0 1 1028 10
/**
 *
 */
68
inline void LVecBase4i::componentwise_mult(LVecBase4i const &other);

2857 7 __pow__ 0 4 3552 19 LVecBase4i::__pow__ 0 1 1029 0
58
inline LVecBase4i LVecBase4i::__pow__(int exponent) const;

2858 8 __ipow__ 0 4 3552 20 LVecBase4i::__ipow__ 0 1 1030 0
68
inline PyObject *LVecBase4i::__ipow__(PyObject *self, int exponent);

2859 4 fmax 0 4 3552 16 LVecBase4i::fmax 0 1 1031 10
/**
 *
 */
66
inline LVecBase4i LVecBase4i::fmax(LVecBase4i const &other) const;

2860 4 fmin 0 4 3552 16 LVecBase4i::fmin 0 1 1032 10
/**
 *
 */
66
inline LVecBase4i LVecBase4i::fmin(LVecBase4i const &other) const;

2861 12 almost_equal 0 4 3552 24 LVecBase4i::almost_equal 0 2 1033 1034 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
152
inline bool LVecBase4i::almost_equal(LVecBase4i const &other, int threshold) const;
inline bool LVecBase4i::almost_equal(LVecBase4i const &other) const;

2862 6 output 0 4 3552 18 LVecBase4i::output 0 1 1035 10
/**
 *
 */
56
inline void LVecBase4i::output(std::ostream &out) const;

2863 8 __repr__ 0 4 3552 20 LVecBase4i::__repr__ 0 1 1036 0
52
inline std::string LVecBase4i::__repr__(void) const;

2864 20 write_datagram_fixed 0 4 3552 32 LVecBase4i::write_datagram_fixed 0 1 1037 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase4i::write_datagram_fixed(Datagram &destination) const;

2865 19 read_datagram_fixed 0 4 3552 31 LVecBase4i::read_datagram_fixed 0 1 1038 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase4i::read_datagram_fixed(DatagramIterator &source);

2866 14 write_datagram 0 4 3552 26 LVecBase4i::write_datagram 0 1 1039 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase4i::write_datagram(Datagram &destination) const;

2867 13 read_datagram 0 4 3552 25 LVecBase4i::read_datagram 0 1 1040 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase4i::read_datagram(DatagramIterator &source);

2868 14 get_class_type 0 4 3552 26 LVecBase4i::get_class_type 0 1 1041 0
51
static TypeHandle LVecBase4i::get_class_type(void);

2869 11 ~LVecBase4i 0 4 3552 23 LVecBase4i::~LVecBase4i 0 0 0
30
LVecBase4i::~LVecBase4i(void);

2870 19 UnalignedLVecBase4i 0 4 3554 40 UnalignedLVecBase4i::UnalignedLVecBase4i 0 5 1042 1043 1044 1045 1046 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
367
inline UnalignedLVecBase4i::UnalignedLVecBase4i(void) = default;
inline UnalignedLVecBase4i::UnalignedLVecBase4i(LVecBase4i const &copy);
inline UnalignedLVecBase4i::UnalignedLVecBase4i(int fill_value);
inline UnalignedLVecBase4i::UnalignedLVecBase4i(int x, int y, int z, int w);
inline UnalignedLVecBase4i::UnalignedLVecBase4i(UnalignedLVecBase4i const &) = default;

2871 4 fill 0 4 3554 25 UnalignedLVecBase4i::fill 0 1 1047 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
54
inline void UnalignedLVecBase4i::fill(int fill_value);

2872 3 set 0 4 3554 24 UnalignedLVecBase4i::set 0 1 1048 10
/**
 *
 */
65
inline void UnalignedLVecBase4i::set(int x, int y, int z, int w);

2873 11 operator [] 0 4 3554 32 UnalignedLVecBase4i::operator [] 0 2 1049 1050 10
/**
 *
 */
110
inline int UnalignedLVecBase4i::operator [](int i) const;
inline int &UnalignedLVecBase4i::operator [](int i);

2874 4 size 0 4 3554 25 UnalignedLVecBase4i::size 0 1 1051 0
53
static constexpr int UnalignedLVecBase4i::size(void);

2875 8 get_data 0 4 3554 29 UnalignedLVecBase4i::get_data 0 1 1052 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
60
inline int const *UnalignedLVecBase4i::get_data(void) const;

2876 18 get_num_components 0 4 3554 39 UnalignedLVecBase4i::get_num_components 0 1 1053 0
67
static constexpr int UnalignedLVecBase4i::get_num_components(void);

2877 11 operator == 0 4 3554 32 UnalignedLVecBase4i::operator == 0 1 1054 0
85
inline bool UnalignedLVecBase4i::operator ==(UnalignedLVecBase4i const &other) const;

2878 11 operator != 0 4 3554 32 UnalignedLVecBase4i::operator != 0 1 1055 0
85
inline bool UnalignedLVecBase4i::operator !=(UnalignedLVecBase4i const &other) const;

2879 14 get_class_type 0 4 3554 35 UnalignedLVecBase4i::get_class_type 0 1 1056 0
60
static TypeHandle UnalignedLVecBase4i::get_class_type(void);

2880 20 ~UnalignedLVecBase4i 0 4 3554 41 UnalignedLVecBase4i::~UnalignedLVecBase4i 0 0 0
48
UnalignedLVecBase4i::~UnalignedLVecBase4i(void);

2881 9 LVector4f 0 4 3556 20 LVector4f::LVector4f 0 6 1057 1058 1059 1060 1061 1062 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
329
inline LVector4f::LVector4f(void) = default;
inline LVector4f::LVector4f(LVecBase4f const &copy);
inline LVector4f::LVector4f(float fill_value);
inline LVector4f::LVector4f(float x, float y, float z, float w);
inline LVector4f::LVector4f(LVecBase3f const &copy, float w);
inline LVector4f::LVector4f(LVector4f const &) = default;

2882 11 __getattr__ 0 4 3556 22 LVector4f::__getattr__ 0 1 1063 0
92
inline PyObject *LVector4f::__getattr__(PyObject *self, std::string const &attr_name) const;

2883 11 __setattr__ 0 4 3556 22 LVector4f::__setattr__ 0 1 1064 0
98
inline int LVector4f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2884 4 zero 0 4 3556 15 LVector4f::zero 0 1 1065 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector4f const &LVector4f::zero(void);

2885 6 unit_x 0 4 3556 17 LVector4f::unit_x 0 1 1066 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector4f const &LVector4f::unit_x(void);

2886 6 unit_y 0 4 3556 17 LVector4f::unit_y 0 1 1067 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector4f const &LVector4f::unit_y(void);

2887 6 unit_z 0 4 3556 17 LVector4f::unit_z 0 1 1068 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector4f const &LVector4f::unit_z(void);

2888 6 unit_w 0 4 3556 17 LVector4f::unit_w 0 1 1069 35
/**
 * Returns a unit W vector.
 */
55
static inline LVector4f const &LVector4f::unit_w(void);

2889 7 get_xyz 0 4 3556 18 LVector4f::get_xyz 0 1 1070 58
/**
 * Returns the x, y and z component of this vector
 */
48
inline LVector3f LVector4f::get_xyz(void) const;

2890 6 get_xy 0 4 3556 17 LVector4f::get_xy 0 1 1071 55
/**
 * Returns the x and y component of this vector
 */
47
inline LVector2f LVector4f::get_xy(void) const;

2891 10 operator - 0 68 3556 21 LVector4f::operator - 0 1 1072 0
51
inline LVector4f LVector4f::operator -(void) const;

2892 10 operator + 0 4 3556 21 LVector4f::operator + 0 2 1073 1074 0
141
inline LVecBase4f LVector4f::operator +(LVecBase4f const &other) const;
inline LVector4f LVector4f::operator +(LVector4f const &other) const;

2893 10 operator - 0 4 3556 21 LVector4f::operator - 0 2 1075 1076 0
141
inline LVecBase4f LVector4f::operator -(LVecBase4f const &other) const;
inline LVector4f LVector4f::operator -(LVector4f const &other) const;

2894 10 operator * 0 4 3556 21 LVector4f::operator * 0 1 1077 0
59
inline LVector4f LVector4f::operator *(float scalar) const;

2895 10 operator / 0 4 3556 21 LVector4f::operator / 0 1 1078 0
59
inline LVector4f LVector4f::operator /(float scalar) const;

2896 10 normalized 0 4 3556 21 LVector4f::normalized 0 1 1079 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector4f LVector4f::normalized(void) const;

2897 7 project 0 4 3556 18 LVector4f::project 0 1 1080 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector4f LVector4f::project(LVecBase4f const &onto) const;

2898 8 __repr__ 0 4 3556 19 LVector4f::__repr__ 0 1 1081 0
51
inline std::string LVector4f::__repr__(void) const;

2899 14 get_class_type 0 4 3556 25 LVector4f::get_class_type 0 1 1082 0
50
static TypeHandle LVector4f::get_class_type(void);

2900 10 ~LVector4f 0 4 3556 21 LVector4f::~LVector4f 0 0 0
28
LVector4f::~LVector4f(void);

2901 9 LVector4d 0 4 3557 20 LVector4d::LVector4d 0 6 1083 1084 1085 1086 1087 1088 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
335
inline LVector4d::LVector4d(void) = default;
inline LVector4d::LVector4d(LVecBase4d const &copy);
inline LVector4d::LVector4d(double fill_value);
inline LVector4d::LVector4d(double x, double y, double z, double w);
inline LVector4d::LVector4d(LVecBase3d const &copy, double w);
inline LVector4d::LVector4d(LVector4d const &) = default;

2902 11 __getattr__ 0 4 3557 22 LVector4d::__getattr__ 0 1 1089 0
92
inline PyObject *LVector4d::__getattr__(PyObject *self, std::string const &attr_name) const;

2903 11 __setattr__ 0 4 3557 22 LVector4d::__setattr__ 0 1 1090 0
98
inline int LVector4d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2904 4 zero 0 4 3557 15 LVector4d::zero 0 1 1091 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector4d const &LVector4d::zero(void);

2905 6 unit_x 0 4 3557 17 LVector4d::unit_x 0 1 1092 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector4d const &LVector4d::unit_x(void);

2906 6 unit_y 0 4 3557 17 LVector4d::unit_y 0 1 1093 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector4d const &LVector4d::unit_y(void);

2907 6 unit_z 0 4 3557 17 LVector4d::unit_z 0 1 1094 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector4d const &LVector4d::unit_z(void);

2908 6 unit_w 0 4 3557 17 LVector4d::unit_w 0 1 1095 35
/**
 * Returns a unit W vector.
 */
55
static inline LVector4d const &LVector4d::unit_w(void);

2909 7 get_xyz 0 4 3557 18 LVector4d::get_xyz 0 1 1096 58
/**
 * Returns the x, y and z component of this vector
 */
48
inline LVector3d LVector4d::get_xyz(void) const;

2910 6 get_xy 0 4 3557 17 LVector4d::get_xy 0 1 1097 55
/**
 * Returns the x and y component of this vector
 */
47
inline LVector2d LVector4d::get_xy(void) const;

2911 10 operator - 0 68 3557 21 LVector4d::operator - 0 1 1098 0
51
inline LVector4d LVector4d::operator -(void) const;

2912 10 operator + 0 4 3557 21 LVector4d::operator + 0 2 1099 1100 0
141
inline LVecBase4d LVector4d::operator +(LVecBase4d const &other) const;
inline LVector4d LVector4d::operator +(LVector4d const &other) const;

2913 10 operator - 0 4 3557 21 LVector4d::operator - 0 2 1101 1102 0
141
inline LVecBase4d LVector4d::operator -(LVecBase4d const &other) const;
inline LVector4d LVector4d::operator -(LVector4d const &other) const;

2914 10 operator * 0 4 3557 21 LVector4d::operator * 0 1 1103 0
60
inline LVector4d LVector4d::operator *(double scalar) const;

2915 10 operator / 0 4 3557 21 LVector4d::operator / 0 1 1104 0
60
inline LVector4d LVector4d::operator /(double scalar) const;

2916 10 normalized 0 4 3557 21 LVector4d::normalized 0 1 1105 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector4d LVector4d::normalized(void) const;

2917 7 project 0 4 3557 18 LVector4d::project 0 1 1106 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector4d LVector4d::project(LVecBase4d const &onto) const;

2918 8 __repr__ 0 4 3557 19 LVector4d::__repr__ 0 1 1107 0
51
inline std::string LVector4d::__repr__(void) const;

2919 14 get_class_type 0 4 3557 25 LVector4d::get_class_type 0 1 1108 0
50
static TypeHandle LVector4d::get_class_type(void);

2920 10 ~LVector4d 0 4 3557 21 LVector4d::~LVector4d 0 0 0
28
LVector4d::~LVector4d(void);

2921 9 LVector4i 0 4 3558 20 LVector4i::LVector4i 0 6 1109 1110 1111 1112 1113 1114 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
317
inline LVector4i::LVector4i(void) = default;
inline LVector4i::LVector4i(LVecBase4i const &copy);
inline LVector4i::LVector4i(int fill_value);
inline LVector4i::LVector4i(int x, int y, int z, int w);
inline LVector4i::LVector4i(LVecBase3i const &copy, int w);
inline LVector4i::LVector4i(LVector4i const &) = default;

2922 11 __getattr__ 0 4 3558 22 LVector4i::__getattr__ 0 1 1115 0
92
inline PyObject *LVector4i::__getattr__(PyObject *self, std::string const &attr_name) const;

2923 11 __setattr__ 0 4 3558 22 LVector4i::__setattr__ 0 1 1116 0
98
inline int LVector4i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2924 4 zero 0 4 3558 15 LVector4i::zero 0 1 1117 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector4i const &LVector4i::zero(void);

2925 6 unit_x 0 4 3558 17 LVector4i::unit_x 0 1 1118 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector4i const &LVector4i::unit_x(void);

2926 6 unit_y 0 4 3558 17 LVector4i::unit_y 0 1 1119 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector4i const &LVector4i::unit_y(void);

2927 6 unit_z 0 4 3558 17 LVector4i::unit_z 0 1 1120 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector4i const &LVector4i::unit_z(void);

2928 6 unit_w 0 4 3558 17 LVector4i::unit_w 0 1 1121 35
/**
 * Returns a unit W vector.
 */
55
static inline LVector4i const &LVector4i::unit_w(void);

2929 7 get_xyz 0 4 3558 18 LVector4i::get_xyz 0 1 1122 58
/**
 * Returns the x, y and z component of this vector
 */
48
inline LVector3i LVector4i::get_xyz(void) const;

2930 6 get_xy 0 4 3558 17 LVector4i::get_xy 0 1 1123 55
/**
 * Returns the x and y component of this vector
 */
47
inline LVector2i LVector4i::get_xy(void) const;

2931 10 operator - 0 68 3558 21 LVector4i::operator - 0 1 1124 0
51
inline LVector4i LVector4i::operator -(void) const;

2932 10 operator + 0 4 3558 21 LVector4i::operator + 0 2 1125 1126 0
141
inline LVecBase4i LVector4i::operator +(LVecBase4i const &other) const;
inline LVector4i LVector4i::operator +(LVector4i const &other) const;

2933 10 operator - 0 4 3558 21 LVector4i::operator - 0 2 1127 1128 0
141
inline LVecBase4i LVector4i::operator -(LVecBase4i const &other) const;
inline LVector4i LVector4i::operator -(LVector4i const &other) const;

2934 10 operator * 0 4 3558 21 LVector4i::operator * 0 1 1129 0
57
inline LVector4i LVector4i::operator *(int scalar) const;

2935 10 operator / 0 4 3558 21 LVector4i::operator / 0 1 1130 0
57
inline LVector4i LVector4i::operator /(int scalar) const;

2936 8 __repr__ 0 4 3558 19 LVector4i::__repr__ 0 1 1131 0
51
inline std::string LVector4i::__repr__(void) const;

2937 14 get_class_type 0 4 3558 25 LVector4i::get_class_type 0 1 1132 0
50
static TypeHandle LVector4i::get_class_type(void);

2938 10 ~LVector4i 0 4 3558 21 LVector4i::~LVector4i 0 0 0
28
LVector4i::~LVector4i(void);

2939 8 LPoint4f 0 4 3559 18 LPoint4f::LPoint4f 0 6 1133 1134 1135 1136 1137 1138 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
316
inline LPoint4f::LPoint4f(void) = default;
inline LPoint4f::LPoint4f(LVecBase4f const &copy);
inline LPoint4f::LPoint4f(float fill_value);
inline LPoint4f::LPoint4f(float x, float y, float z, float w);
inline LPoint4f::LPoint4f(LVecBase3f const &copy, float w);
inline LPoint4f::LPoint4f(LPoint4f const &) = default;

2940 11 __getattr__ 0 4 3559 21 LPoint4f::__getattr__ 0 1 1139 0
91
inline PyObject *LPoint4f::__getattr__(PyObject *self, std::string const &attr_name) const;

2941 11 __setattr__ 0 4 3559 21 LPoint4f::__setattr__ 0 1 1140 0
97
inline int LPoint4f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2942 4 zero 0 4 3559 14 LPoint4f::zero 0 1 1141 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint4f const &LPoint4f::zero(void);

2943 6 unit_x 0 4 3559 16 LPoint4f::unit_x 0 1 1142 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint4f const &LPoint4f::unit_x(void);

2944 6 unit_y 0 4 3559 16 LPoint4f::unit_y 0 1 1143 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint4f const &LPoint4f::unit_y(void);

2945 6 unit_z 0 4 3559 16 LPoint4f::unit_z 0 1 1144 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint4f const &LPoint4f::unit_z(void);

2946 6 unit_w 0 4 3559 16 LPoint4f::unit_w 0 1 1145 34
/**
 * Returns a unit W point.
 */
53
static inline LPoint4f const &LPoint4f::unit_w(void);

2947 7 get_xyz 0 4 3559 17 LPoint4f::get_xyz 0 1 1146 58
/**
 * Returns the x, y and z component of this vector
 */
46
inline LPoint3f LPoint4f::get_xyz(void) const;

2948 6 get_xy 0 4 3559 16 LPoint4f::get_xy 0 1 1147 55
/**
 * Returns the x and y component of this vector
 */
45
inline LPoint2f LPoint4f::get_xy(void) const;

2949 10 operator - 0 68 3559 20 LPoint4f::operator - 0 1 1148 0
49
inline LPoint4f LPoint4f::operator -(void) const;

2950 10 operator + 0 4 3559 20 LPoint4f::operator + 0 2 1149 1150 0
138
inline LVecBase4f LPoint4f::operator +(LVecBase4f const &other) const;
inline LPoint4f LPoint4f::operator +(LVector4f const &other) const;

2951 10 operator - 0 4 3559 20 LPoint4f::operator - 0 3 1151 1152 1153 0
206
inline LVecBase4f LPoint4f::operator -(LVecBase4f const &other) const;
inline LVector4f LPoint4f::operator -(LPoint4f const &other) const;
inline LPoint4f LPoint4f::operator -(LVector4f const &other) const;

2952 10 operator * 0 4 3559 20 LPoint4f::operator * 0 1 1154 0
57
inline LPoint4f LPoint4f::operator *(float scalar) const;

2953 10 operator / 0 4 3559 20 LPoint4f::operator / 0 1 1155 0
57
inline LPoint4f LPoint4f::operator /(float scalar) const;

2954 10 normalized 0 4 3559 20 LPoint4f::normalized 0 1 1156 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint4f LPoint4f::normalized(void) const;

2955 7 project 0 4 3559 17 LPoint4f::project 0 1 1157 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint4f LPoint4f::project(LVecBase4f const &onto) const;

2956 8 __repr__ 0 4 3559 18 LPoint4f::__repr__ 0 1 1158 0
50
inline std::string LPoint4f::__repr__(void) const;

2957 14 get_class_type 0 4 3559 24 LPoint4f::get_class_type 0 1 1159 0
49
static TypeHandle LPoint4f::get_class_type(void);

2958 9 ~LPoint4f 0 4 3559 19 LPoint4f::~LPoint4f 0 0 0
26
LPoint4f::~LPoint4f(void);

2959 8 LPoint4d 0 4 3560 18 LPoint4d::LPoint4d 0 6 1160 1161 1162 1163 1164 1165 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
322
inline LPoint4d::LPoint4d(void) = default;
inline LPoint4d::LPoint4d(LVecBase4d const &copy);
inline LPoint4d::LPoint4d(double fill_value);
inline LPoint4d::LPoint4d(double x, double y, double z, double w);
inline LPoint4d::LPoint4d(LVecBase3d const &copy, double w);
inline LPoint4d::LPoint4d(LPoint4d const &) = default;

2960 11 __getattr__ 0 4 3560 21 LPoint4d::__getattr__ 0 1 1166 0
91
inline PyObject *LPoint4d::__getattr__(PyObject *self, std::string const &attr_name) const;

2961 11 __setattr__ 0 4 3560 21 LPoint4d::__setattr__ 0 1 1167 0
97
inline int LPoint4d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2962 4 zero 0 4 3560 14 LPoint4d::zero 0 1 1168 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint4d const &LPoint4d::zero(void);

2963 6 unit_x 0 4 3560 16 LPoint4d::unit_x 0 1 1169 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint4d const &LPoint4d::unit_x(void);

2964 6 unit_y 0 4 3560 16 LPoint4d::unit_y 0 1 1170 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint4d const &LPoint4d::unit_y(void);

2965 6 unit_z 0 4 3560 16 LPoint4d::unit_z 0 1 1171 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint4d const &LPoint4d::unit_z(void);

2966 6 unit_w 0 4 3560 16 LPoint4d::unit_w 0 1 1172 34
/**
 * Returns a unit W point.
 */
53
static inline LPoint4d const &LPoint4d::unit_w(void);

2967 7 get_xyz 0 4 3560 17 LPoint4d::get_xyz 0 1 1173 58
/**
 * Returns the x, y and z component of this vector
 */
46
inline LPoint3d LPoint4d::get_xyz(void) const;

2968 6 get_xy 0 4 3560 16 LPoint4d::get_xy 0 1 1174 55
/**
 * Returns the x and y component of this vector
 */
45
inline LPoint2d LPoint4d::get_xy(void) const;

2969 10 operator - 0 68 3560 20 LPoint4d::operator - 0 1 1175 0
49
inline LPoint4d LPoint4d::operator -(void) const;

2970 10 operator + 0 4 3560 20 LPoint4d::operator + 0 2 1176 1177 0
138
inline LVecBase4d LPoint4d::operator +(LVecBase4d const &other) const;
inline LPoint4d LPoint4d::operator +(LVector4d const &other) const;

2971 10 operator - 0 4 3560 20 LPoint4d::operator - 0 3 1178 1179 1180 0
206
inline LVecBase4d LPoint4d::operator -(LVecBase4d const &other) const;
inline LVector4d LPoint4d::operator -(LPoint4d const &other) const;
inline LPoint4d LPoint4d::operator -(LVector4d const &other) const;

2972 10 operator * 0 4 3560 20 LPoint4d::operator * 0 1 1181 0
58
inline LPoint4d LPoint4d::operator *(double scalar) const;

2973 10 operator / 0 4 3560 20 LPoint4d::operator / 0 1 1182 0
58
inline LPoint4d LPoint4d::operator /(double scalar) const;

2974 10 normalized 0 4 3560 20 LPoint4d::normalized 0 1 1183 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint4d LPoint4d::normalized(void) const;

2975 7 project 0 4 3560 17 LPoint4d::project 0 1 1184 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint4d LPoint4d::project(LVecBase4d const &onto) const;

2976 8 __repr__ 0 4 3560 18 LPoint4d::__repr__ 0 1 1185 0
50
inline std::string LPoint4d::__repr__(void) const;

2977 14 get_class_type 0 4 3560 24 LPoint4d::get_class_type 0 1 1186 0
49
static TypeHandle LPoint4d::get_class_type(void);

2978 9 ~LPoint4d 0 4 3560 19 LPoint4d::~LPoint4d 0 0 0
26
LPoint4d::~LPoint4d(void);

2979 8 LPoint4i 0 4 3561 18 LPoint4i::LPoint4i 0 6 1187 1188 1189 1190 1191 1192 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
304
inline LPoint4i::LPoint4i(void) = default;
inline LPoint4i::LPoint4i(LVecBase4i const &copy);
inline LPoint4i::LPoint4i(int fill_value);
inline LPoint4i::LPoint4i(int x, int y, int z, int w);
inline LPoint4i::LPoint4i(LVecBase3i const &copy, int w);
inline LPoint4i::LPoint4i(LPoint4i const &) = default;

2980 11 __getattr__ 0 4 3561 21 LPoint4i::__getattr__ 0 1 1193 0
91
inline PyObject *LPoint4i::__getattr__(PyObject *self, std::string const &attr_name) const;

2981 11 __setattr__ 0 4 3561 21 LPoint4i::__setattr__ 0 1 1194 0
97
inline int LPoint4i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2982 4 zero 0 4 3561 14 LPoint4i::zero 0 1 1195 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint4i const &LPoint4i::zero(void);

2983 6 unit_x 0 4 3561 16 LPoint4i::unit_x 0 1 1196 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint4i const &LPoint4i::unit_x(void);

2984 6 unit_y 0 4 3561 16 LPoint4i::unit_y 0 1 1197 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint4i const &LPoint4i::unit_y(void);

2985 6 unit_z 0 4 3561 16 LPoint4i::unit_z 0 1 1198 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint4i const &LPoint4i::unit_z(void);

2986 6 unit_w 0 4 3561 16 LPoint4i::unit_w 0 1 1199 34
/**
 * Returns a unit W point.
 */
53
static inline LPoint4i const &LPoint4i::unit_w(void);

2987 7 get_xyz 0 4 3561 17 LPoint4i::get_xyz 0 1 1200 58
/**
 * Returns the x, y and z component of this vector
 */
46
inline LPoint3i LPoint4i::get_xyz(void) const;

2988 6 get_xy 0 4 3561 16 LPoint4i::get_xy 0 1 1201 55
/**
 * Returns the x and y component of this vector
 */
45
inline LPoint2i LPoint4i::get_xy(void) const;

2989 10 operator - 0 68 3561 20 LPoint4i::operator - 0 1 1202 0
49
inline LPoint4i LPoint4i::operator -(void) const;

2990 10 operator + 0 4 3561 20 LPoint4i::operator + 0 2 1203 1204 0
138
inline LVecBase4i LPoint4i::operator +(LVecBase4i const &other) const;
inline LPoint4i LPoint4i::operator +(LVector4i const &other) const;

2991 10 operator - 0 4 3561 20 LPoint4i::operator - 0 3 1205 1206 1207 0
206
inline LVecBase4i LPoint4i::operator -(LVecBase4i const &other) const;
inline LVector4i LPoint4i::operator -(LPoint4i const &other) const;
inline LPoint4i LPoint4i::operator -(LVector4i const &other) const;

2992 10 operator * 0 4 3561 20 LPoint4i::operator * 0 1 1208 0
55
inline LPoint4i LPoint4i::operator *(int scalar) const;

2993 10 operator / 0 4 3561 20 LPoint4i::operator / 0 1 1209 0
55
inline LPoint4i LPoint4i::operator /(int scalar) const;

2994 8 __repr__ 0 4 3561 18 LPoint4i::__repr__ 0 1 1210 0
50
inline std::string LPoint4i::__repr__(void) const;

2995 14 get_class_type 0 4 3561 24 LPoint4i::get_class_type 0 1 1211 0
49
static TypeHandle LPoint4i::get_class_type(void);

2996 9 ~LPoint4i 0 4 3561 19 LPoint4i::~LPoint4i 0 0 0
26
LPoint4i::~LPoint4i(void);

2997 11 operator [] 0 4 3564 27 LMatrix3f::Row::operator [] 0 2 1314 1315 10
/**
 *
 */
104
inline float LMatrix3f::Row::operator [](int i) const;
inline float &LMatrix3f::Row::operator [](int i);

2998 4 size 0 4 3564 20 LMatrix3f::Row::size 0 1 1316 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
45
static inline int LMatrix3f::Row::size(void);

2999 17 operator typecast 0 132 3564 33 LMatrix3f::Row::operator typecast 0 1 1317 0
47
inline operator LVecBase3f const &(void) const;

3000 3 Row 0 4 3564 19 LMatrix3f::Row::Row 0 1 1313 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix3f::Row::Row(LMatrix3f::Row const &) = default;

3001 4 ~Row 0 4 3564 20 LMatrix3f::Row::~Row 0 0 0
27
LMatrix3f::Row::~Row(void);

3002 11 operator [] 0 4 3565 28 LMatrix3f::CRow::operator [] 0 1 1319 0
55
inline float LMatrix3f::CRow::operator [](int i) const;

3003 4 size 0 4 3565 21 LMatrix3f::CRow::size 0 1 1320 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
46
static inline int LMatrix3f::CRow::size(void);

3004 17 operator typecast 0 132 3565 34 LMatrix3f::CRow::operator typecast 0 1 1321 0
47
inline operator LVecBase3f const &(void) const;

3005 4 CRow 0 4 3565 21 LMatrix3f::CRow::CRow 0 1 1318 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix3f::CRow::CRow(LMatrix3f::CRow const &) = default;

3006 5 ~CRow 0 4 3565 22 LMatrix3f::CRow::~CRow 0 0 0
29
LMatrix3f::CRow::~CRow(void);

3007 9 LMatrix3f 0 4 3562 20 LMatrix3f::LMatrix3f 0 4 1212 1213 1214 1215 96
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs the matrix from three individual rows.
 */
277
inline LMatrix3f::LMatrix3f(void);
inline LMatrix3f::LMatrix3f(LMatrix3f const &other);
inline LMatrix3f::LMatrix3f(float , float , float , float , float , float , float , float , float );
inline LMatrix3f::LMatrix3f(LVecBase3f const &, LVecBase3f const &, LVecBase3f const &);

3008 10 operator = 0 4 3562 21 LMatrix3f::operator = 0 2 1216 1217 22
/**
 *
 */

/**
 *
 */
111
inline void LMatrix3f::operator =(LMatrix3f const &other);
inline void LMatrix3f::operator =(float fill_value);

3009 12 operator new 0 4 3562 23 LMatrix3f::operator new 0 1 1218 0
122
inline void *LMatrix3f::operator new(std::size_t size);
inline void *LMatrix3f::operator new(std::size_t size, void *ptr);

3010 15 operator delete 0 4 3562 26 LMatrix3f::operator delete 0 0 0
106
inline void LMatrix3f::operator delete(void *ptr);
inline void LMatrix3f::operator delete(void *, void *);

3011 12 validate_ptr 0 4 3562 23 LMatrix3f::validate_ptr 0 0 0
60
static inline bool LMatrix3f::validate_ptr(void const *ptr);

3012 10 __reduce__ 0 4 3562 21 LMatrix3f::__reduce__ 0 1 1219 0
61
inline PyObject *LMatrix3f::__reduce__(PyObject *self) const;

3013 4 fill 0 4 3562 15 LMatrix3f::fill 0 1 1220 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
39
void LMatrix3f::fill(float fill_value);

3014 3 set 0 4 3562 14 LMatrix3f::set 0 1 1221 10
/**
 *
 */
126
inline void LMatrix3f::set(float e00, float e01, float e02, float e10, float e11, float e12, float e20, float e21, float e22);

3015 11 operator [] 0 4 3562 22 LMatrix3f::operator [] 0 2 1222 1223 0
112
inline LMatrix3f::CRow LMatrix3f::operator [](int i) const;
inline LMatrix3f::Row LMatrix3f::operator [](int i);

3016 4 size 0 4 3562 15 LMatrix3f::size 0 1 1224 55
/**
 * Returns 3: the number of rows of a LMatrix3.
 */
40
static inline int LMatrix3f::size(void);

3017 7 set_row 0 4 3562 18 LMatrix3f::set_row 0 2 1225 1226 193
/**
 * Replaces the indicated row of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */
123
inline void LMatrix3f::set_row(int row, LVecBase3f const &v);
inline void LMatrix3f::set_row(int row, LVecBase2f const &v);

3018 7 set_col 0 4 3562 18 LMatrix3f::set_col 0 2 1227 1228 196
/**
 * Replaces the indicated column of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */
123
inline void LMatrix3f::set_col(int col, LVecBase3f const &v);
inline void LMatrix3f::set_col(int col, LVecBase2f const &v);

3019 7 get_row 0 4 3562 18 LMatrix3f::get_row 0 2 1229 1230 192
// these versions inline better

/**
 * Returns the indicated row of the matrix as a three-component vector.
 */

/**
 * Stores the indicated row of the matrix as a three-component vector.
 */
123
inline LVecBase3f LMatrix3f::get_row(int row) const;
inline void LMatrix3f::get_row(LVecBase3f &result_vec, int row) const;

3020 7 get_col 0 4 3562 18 LMatrix3f::get_col 0 1 1231 82
/**
 * Returns the indicated column of the matrix as a three-component vector.
 */
52
inline LVecBase3f LMatrix3f::get_col(int col) const;

3021 8 get_row2 0 4 3562 19 LMatrix3f::get_row2 0 1 1232 106
/**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */
53
inline LVecBase2f LMatrix3f::get_row2(int row) const;

3022 8 get_col2 0 4 3562 19 LMatrix3f::get_col2 0 1 1233 106
/**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */
53
inline LVecBase2f LMatrix3f::get_col2(int col) const;

3023 11 operator () 0 4 3562 22 LMatrix3f::operator () 0 2 1234 1235 10
/**
 *
 */
116
inline float &LMatrix3f::operator ()(int row, int col);
inline float LMatrix3f::operator ()(int row, int col) const;

3024 6 is_nan 0 4 3562 17 LMatrix3f::is_nan 0 1 1236 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix3f::is_nan(void) const;

3025 11 is_identity 0 4 3562 22 LMatrix3f::is_identity 0 1 1237 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix3f::is_identity(void) const;

3026 8 get_cell 0 4 3562 19 LMatrix3f::get_cell 0 1 1238 54
/**
 * Returns a particular element of the matrix.
 */
57
inline float LMatrix3f::get_cell(int row, int col) const;

3027 8 set_cell 0 4 3562 19 LMatrix3f::set_cell 0 1 1239 54
/**
 * Changes a particular element of the matrix.
 */
63
inline void LMatrix3f::set_cell(int row, int col, float value);

3028 8 get_data 0 4 3562 19 LMatrix3f::get_data 0 1 1240 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
52
inline float const *LMatrix3f::get_data(void) const;

3029 18 get_num_components 0 4 3562 29 LMatrix3f::get_num_components 0 1 1241 62
/**
 * Returns the number of elements in the matrix, nine.
 */
53
inline int LMatrix3f::get_num_components(void) const;

3030 10 operator < 0 4 3562 21 LMatrix3f::operator < 0 1 1242 0
64
inline bool LMatrix3f::operator <(LMatrix3f const &other) const;

3031 11 operator == 0 4 3562 22 LMatrix3f::operator == 0 1 1243 0
65
inline bool LMatrix3f::operator ==(LMatrix3f const &other) const;

3032 11 operator != 0 4 3562 22 LMatrix3f::operator != 0 1 1244 0
65
inline bool LMatrix3f::operator !=(LMatrix3f const &other) const;

3033 10 compare_to 0 4 3562 21 LMatrix3f::compare_to 0 2 1245 1246 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
137
inline int LMatrix3f::compare_to(LMatrix3f const &other) const;
int LMatrix3f::compare_to(LMatrix3f const &other, float threshold) const;

3034 8 get_hash 0 4 3562 19 LMatrix3f::get_hash 0 2 1247 1248 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
114
inline std::size_t LMatrix3f::get_hash(void) const;
inline std::size_t LMatrix3f::get_hash(float threshold) const;

3035 8 add_hash 0 4 3562 19 LMatrix3f::add_hash 0 2 1249 1250 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
144
inline std::size_t LMatrix3f::add_hash(std::size_t hash) const;
inline std::size_t LMatrix3f::add_hash(std::size_t hash, float threshold) const;

3036 5 xform 0 4 3562 16 LMatrix3f::xform 0 1 1251 52
/**
 * 3-component vector or point times matrix.
 */
62
inline LVecBase3f LMatrix3f::xform(LVecBase3f const &v) const;

3037 11 xform_point 0 4 3562 22 LMatrix3f::xform_point 0 1 1252 162
/**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase2f LMatrix3f::xform_point(LVecBase2f const &v) const;

3038 9 xform_vec 0 4 3562 20 LMatrix3f::xform_vec 0 2 1253 1254 357
/**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
133
inline LVecBase2f LMatrix3f::xform_vec(LVecBase2f const &v) const;
inline LVecBase3f LMatrix3f::xform_vec(LVecBase3f const &v) const;

3039 17 xform_vec_general 0 4 3562 28 LMatrix3f::xform_vec_general 0 1 1255 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3f LMatrix3f::xform_vec_general(LVecBase3f const &v) const;

3040 14 xform_in_place 0 4 3562 25 LMatrix3f::xform_in_place 0 1 1256 52
/**
 * 3-component vector or point times matrix.
 */
59
inline void LMatrix3f::xform_in_place(LVecBase3f &v) const;

3041 20 xform_point_in_place 0 4 3562 31 LMatrix3f::xform_point_in_place 0 1 1257 139
/**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix3f::xform_point_in_place(LVecBase2f &v) const;

3042 18 xform_vec_in_place 0 4 3562 29 LMatrix3f::xform_vec_in_place 0 2 1258 1259 310
/**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
127
inline void LMatrix3f::xform_vec_in_place(LVecBase2f &v) const;
inline void LMatrix3f::xform_vec_in_place(LVecBase3f &v) const;

3043 26 xform_vec_general_in_place 0 4 3562 37 LMatrix3f::xform_vec_general_in_place 0 1 1260 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix3f::xform_vec_general_in_place(LVecBase3f &v) const;

3044 8 multiply 0 4 3562 19 LMatrix3f::multiply 0 1 1261 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix3f::multiply(LMatrix3f const &other1, LMatrix3f const &other2);

3045 10 operator * 0 4 3562 21 LMatrix3f::operator * 0 2 1262 1263 0
129
inline LMatrix3f LMatrix3f::operator *(LMatrix3f const &other) const;
inline LMatrix3f LMatrix3f::operator *(float scalar) const;

3046 10 operator / 0 4 3562 21 LMatrix3f::operator / 0 1 1264 0
59
inline LMatrix3f LMatrix3f::operator /(float scalar) const;

3047 11 operator += 0 4 3562 22 LMatrix3f::operator += 0 1 1265 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix3f &LMatrix3f::operator +=(LMatrix3f const &other);

3048 11 operator -= 0 4 3562 22 LMatrix3f::operator -= 0 1 1266 66
/**
 * Performs a memberwise subtraction between two matrices.
 */
65
inline LMatrix3f &LMatrix3f::operator -=(LMatrix3f const &other);

3049 11 operator *= 0 4 3562 22 LMatrix3f::operator *= 0 2 1267 1268 51
/**
 *
 */

/**
 * Performs a memberwise scale.
 */
121
inline LMatrix3f &LMatrix3f::operator *=(LMatrix3f const &other);
inline LMatrix3f &LMatrix3f::operator *=(float scalar);

3050 11 operator /= 0 4 3562 22 LMatrix3f::operator /= 0 1 1269 39
/**
 * Performs a memberwise scale.
 */
55
inline LMatrix3f &LMatrix3f::operator /=(float scalar);

3051 18 componentwise_mult 0 4 3562 29 LMatrix3f::componentwise_mult 0 1 1270 10
/**
 *
 */
66
inline void LMatrix3f::componentwise_mult(LMatrix3f const &other);

3052 11 determinant 0 4 3562 22 LMatrix3f::determinant 0 1 1271 49
/**
 * Returns the determinant of the matrix.
 */
48
inline float LMatrix3f::determinant(void) const;

3053 14 transpose_from 0 4 3562 25 LMatrix3f::transpose_from 0 1 1272 10
/**
 *
 */
62
inline void LMatrix3f::transpose_from(LMatrix3f const &other);

3054 18 transpose_in_place 0 4 3562 29 LMatrix3f::transpose_in_place 0 1 1273 10
/**
 *
 */
48
inline void LMatrix3f::transpose_in_place(void);

3055 11 invert_from 0 4 3562 22 LMatrix3f::invert_from 0 1 1274 463
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */
59
inline bool LMatrix3f::invert_from(LMatrix3f const &other);

3056 15 invert_in_place 0 4 3562 26 LMatrix3f::invert_in_place 0 1 1275 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix3f::invert_in_place(void);

3057 21 invert_transpose_from 0 4 3562 32 LMatrix3f::invert_transpose_from 0 2 1276 1277 230
/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */

/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */
139
inline bool LMatrix3f::invert_transpose_from(LMatrix3f const &other);
inline bool LMatrix3f::invert_transpose_from(LMatrix4f const &other);

3058 9 ident_mat 0 4 3562 20 LMatrix3f::ident_mat 0 1 1278 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix3f const &LMatrix3f::ident_mat(void);

3059 17 set_translate_mat 0 4 3562 28 LMatrix3f::set_translate_mat 0 1 1279 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix3f::set_translate_mat(LVecBase2f const &trans);

3060 14 set_rotate_mat 0 4 3562 25 LMatrix3f::set_rotate_mat 0 2 1280 1281 225
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
156
inline void LMatrix3f::set_rotate_mat(float angle);
void LMatrix3f::set_rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3061 13 set_scale_mat 0 4 3562 24 LMatrix3f::set_scale_mat 0 2 1282 1283 194
/**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */

/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
125
inline void LMatrix3f::set_scale_mat(LVecBase2f const &scale);
inline void LMatrix3f::set_scale_mat(LVecBase3f const &scale);

3062 13 translate_mat 0 4 3562 24 LMatrix3f::translate_mat 0 2 1284 1285 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
144
static inline LMatrix3f LMatrix3f::translate_mat(LVecBase2f const &trans);
static inline LMatrix3f LMatrix3f::translate_mat(float tx, float ty);

3063 10 rotate_mat 0 4 3562 21 LMatrix3f::rotate_mat 0 2 1286 1287 211
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
179
static inline LMatrix3f LMatrix3f::rotate_mat(float angle);
static inline LMatrix3f LMatrix3f::rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3064 9 scale_mat 0 4 3562 20 LMatrix3f::scale_mat 0 4 1288 1289 1290 1291 356
/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */
283
static inline LMatrix3f LMatrix3f::scale_mat(LVecBase2f const &scale);
static inline LMatrix3f LMatrix3f::scale_mat(float sx, float sy);
static inline LMatrix3f LMatrix3f::scale_mat(LVecBase3f const &scale);
static inline LMatrix3f LMatrix3f::scale_mat(float sx, float sy, float sz);

3065 23 set_rotate_mat_normaxis 0 4 3562 34 LMatrix3f::set_rotate_mat_normaxis 0 1 1292 163
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
113
void LMatrix3f::set_rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3066 19 rotate_mat_normaxis 0 4 3562 30 LMatrix3f::rotate_mat_normaxis 0 1 1293 156
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
128
static inline LMatrix3f LMatrix3f::rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3067 13 set_shear_mat 0 4 3562 24 LMatrix3f::set_shear_mat 0 1 1294 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix3f::set_shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

3068 9 shear_mat 0 4 3562 20 LMatrix3f::shear_mat 0 2 1295 1296 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
224
static inline LMatrix3f LMatrix3f::shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3f LMatrix3f::shear_mat(float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

3069 19 set_scale_shear_mat 0 4 3562 30 LMatrix3f::set_scale_shear_mat 0 1 1297 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
122
void LMatrix3f::set_scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

3070 15 scale_shear_mat 0 4 3562 26 LMatrix3f::scale_shear_mat 0 2 1298 1299 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
291
static inline LMatrix3f LMatrix3f::scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3f LMatrix3f::scale_shear_mat(float sx, float sy, float sz, float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

3071 11 convert_mat 0 4 3562 22 LMatrix3f::convert_mat 0 1 1300 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix3f const &LMatrix3f::convert_mat(CoordinateSystem from, CoordinateSystem to);

3072 12 almost_equal 0 4 3562 23 LMatrix3f::almost_equal 0 2 1301 1302 212
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */
143
bool LMatrix3f::almost_equal(LMatrix3f const &other, float threshold) const;
inline bool LMatrix3f::almost_equal(LMatrix3f const &other) const;

3073 6 output 0 4 3562 17 LMatrix3f::output 0 1 1303 10
/**
 *
 */
48
void LMatrix3f::output(std::ostream &out) const;

3074 5 write 0 4 3562 16 LMatrix3f::write 0 1 1304 10
/**
 *
 */
69
void LMatrix3f::write(std::ostream &out, int indent_level = 0) const;

3075 8 __repr__ 0 4 3562 19 LMatrix3f::__repr__ 0 1 1305 0
51
inline std::string LMatrix3f::__repr__(void) const;

3076 13 generate_hash 0 4 3562 24 LMatrix3f::generate_hash 0 2 1306 1307 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
161
inline void LMatrix3f::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix3f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

3077 20 write_datagram_fixed 0 4 3562 31 LMatrix3f::write_datagram_fixed 0 1 1308 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix3f::write_datagram_fixed(Datagram &destination) const;

3078 19 read_datagram_fixed 0 4 3562 30 LMatrix3f::read_datagram_fixed 0 1 1309 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix3f::read_datagram_fixed(DatagramIterator &scan);

3079 14 write_datagram 0 4 3562 25 LMatrix3f::write_datagram 0 1 1310 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix3f::write_datagram(Datagram &destination) const;

3080 13 read_datagram 0 4 3562 24 LMatrix3f::read_datagram 0 1 1311 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix3f::read_datagram(DatagramIterator &source);

3081 14 get_class_type 0 4 3562 25 LMatrix3f::get_class_type 0 1 1312 0
50
static TypeHandle LMatrix3f::get_class_type(void);

3082 10 ~LMatrix3f 0 4 3562 21 LMatrix3f::~LMatrix3f 0 0 0
28
LMatrix3f::~LMatrix3f(void);

3083 9 transpose 0 1 0 9 transpose 0 4 1884 1885 1886 1887 0
191
inline LMatrix3f transpose(LMatrix3f const &a);
inline LMatrix4f transpose(LMatrix4f const &a);
inline LMatrix3d transpose(LMatrix3d const &a);
inline LMatrix4d transpose(LMatrix4d const &a);

3084 6 invert 0 1 0 6 invert 0 6 1888 1889 1890 1891 1892 1893 0
281
inline LMatrix3f invert(LMatrix3f const &a);
inline LMatrix4f invert(LMatrix4f const &a);
inline LMatrix3d invert(LMatrix3d const &a);
inline LMatrix4d invert(LMatrix4d const &a);
inline LQuaternionf invert(LQuaternionf const &a);
inline LQuaterniond invert(LQuaterniond const &a);

3085 11 operator [] 0 4 3568 27 LMatrix4f::Row::operator [] 0 2 1434 1435 10
/**
 *
 */
104
inline float LMatrix4f::Row::operator [](int i) const;
inline float &LMatrix4f::Row::operator [](int i);

3086 4 size 0 4 3568 20 LMatrix4f::Row::size 0 1 1436 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
45
static inline int LMatrix4f::Row::size(void);

3087 17 operator typecast 0 132 3568 33 LMatrix4f::Row::operator typecast 0 1 1437 0
47
inline operator LVecBase4f const &(void) const;

3088 3 Row 0 4 3568 19 LMatrix4f::Row::Row 0 1 1433 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix4f::Row::Row(LMatrix4f::Row const &) = default;

3089 4 ~Row 0 4 3568 20 LMatrix4f::Row::~Row 0 0 0
27
LMatrix4f::Row::~Row(void);

3090 11 operator [] 0 4 3569 28 LMatrix4f::CRow::operator [] 0 1 1439 0
55
inline float LMatrix4f::CRow::operator [](int i) const;

3091 4 size 0 4 3569 21 LMatrix4f::CRow::size 0 1 1440 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
46
static inline int LMatrix4f::CRow::size(void);

3092 17 operator typecast 0 132 3569 34 LMatrix4f::CRow::operator typecast 0 1 1441 0
47
inline operator LVecBase4f const &(void) const;

3093 4 CRow 0 4 3569 21 LMatrix4f::CRow::CRow 0 1 1438 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix4f::CRow::CRow(LMatrix4f::CRow const &) = default;

3094 5 ~CRow 0 4 3569 22 LMatrix4f::CRow::~CRow 0 0 0
29
LMatrix4f::CRow::~CRow(void);

3095 9 LMatrix4f 0 4 3566 20 LMatrix4f::LMatrix4f 0 7 1322 1323 1324 1325 1326 1327 1328 228
// Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component.

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs the matrix from four individual rows.
 */

/**
 *
 */

/**
 *
 */
548
inline LMatrix4f::LMatrix4f(void);
inline LMatrix4f::LMatrix4f(LMatrix4f const &other);
inline LMatrix4f::LMatrix4f(UnalignedLMatrix4f const &other);
inline LMatrix4f::LMatrix4f(float , float , float , float , float , float , float , float , float , float , float , float , float , float , float , float );
inline LMatrix4f::LMatrix4f(LVecBase4f const &, LVecBase4f const &, LVecBase4f const &, LVecBase4f const &);
inline LMatrix4f::LMatrix4f(LMatrix3f const &upper3);
inline LMatrix4f::LMatrix4f(LMatrix3f const &upper3, LVecBase3f const &trans);

3096 10 operator = 0 4 3566 21 LMatrix4f::operator = 0 3 1329 1330 1331 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
179
inline void LMatrix4f::operator =(LMatrix4f const &other);
inline void LMatrix4f::operator =(UnalignedLMatrix4f const &other);
inline void LMatrix4f::operator =(float fill_value);

3097 12 operator new 0 4 3566 23 LMatrix4f::operator new 0 1 1332 0
122
inline void *LMatrix4f::operator new(std::size_t size);
inline void *LMatrix4f::operator new(std::size_t size, void *ptr);

3098 15 operator delete 0 4 3566 26 LMatrix4f::operator delete 0 0 0
106
inline void LMatrix4f::operator delete(void *ptr);
inline void LMatrix4f::operator delete(void *, void *);

3099 12 validate_ptr 0 4 3566 23 LMatrix4f::validate_ptr 0 0 0
60
static inline bool LMatrix4f::validate_ptr(void const *ptr);

3100 10 __reduce__ 0 4 3566 21 LMatrix4f::__reduce__ 0 1 1333 0
61
inline PyObject *LMatrix4f::__reduce__(PyObject *self) const;

3101 4 fill 0 4 3566 15 LMatrix4f::fill 0 1 1334 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
46
inline void LMatrix4f::fill(float fill_value);

3102 3 set 0 4 3566 14 LMatrix4f::set 0 1 1335 10
/**
 *
 */
203
inline void LMatrix4f::set(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33);

3103 11 set_upper_3 0 4 3566 22 LMatrix4f::set_upper_3 0 1 1336 87
// Get and set the upper 3x3 rotation matrix.

/**
 * Sets the upper 3x3 submatrix.
 */
60
inline void LMatrix4f::set_upper_3(LMatrix3f const &upper3);

3104 11 get_upper_3 0 4 3566 22 LMatrix4f::get_upper_3 0 1 1337 45
/**
 * Retrieves the upper 3x3 submatrix.
 */
52
inline LMatrix3f LMatrix4f::get_upper_3(void) const;

3105 11 operator [] 0 4 3566 22 LMatrix4f::operator [] 0 2 1338 1339 0
112
inline LMatrix4f::CRow LMatrix4f::operator [](int i) const;
inline LMatrix4f::Row LMatrix4f::operator [](int i);

3106 4 size 0 4 3566 15 LMatrix4f::size 0 1 1340 55
/**
 * Returns 4: the number of rows of a LMatrix4.
 */
40
static inline int LMatrix4f::size(void);

3107 7 set_row 0 4 3566 18 LMatrix4f::set_row 0 2 1341 1342 173
/**
 * Replaces the indicated row of the matrix.
 */

/**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */
123
inline void LMatrix4f::set_row(int row, LVecBase4f const &v);
inline void LMatrix4f::set_row(int row, LVecBase3f const &v);

3108 7 set_col 0 4 3566 18 LMatrix4f::set_col 0 2 1343 1344 176
/**
 * Replaces the indicated column of the matrix.
 */

/**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */
123
inline void LMatrix4f::set_col(int col, LVecBase4f const &v);
inline void LMatrix4f::set_col(int col, LVecBase3f const &v);

3109 7 get_row 0 4 3566 18 LMatrix4f::get_row 0 2 1345 1346 186
// these versions inline better

/**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */

/**
 * Stores the indicated row of the matrix as a 4-component vector.
 */
123
inline LVecBase4f LMatrix4f::get_row(int row) const;
inline void LMatrix4f::get_row(LVecBase4f &result_vec, int row) const;

3110 7 get_col 0 4 3566 18 LMatrix4f::get_col 0 1 1347 80
/**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */
52
inline LVecBase4f LMatrix4f::get_col(int col) const;

3111 8 get_row3 0 4 3566 19 LMatrix4f::get_row3 0 2 1348 1349 205
/**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */

/**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */
125
inline LVecBase3f LMatrix4f::get_row3(int row) const;
inline void LMatrix4f::get_row3(LVecBase3f &result_vec, int row) const;

3112 8 get_col3 0 4 3566 19 LMatrix4f::get_col3 0 1 1350 106
/**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */
53
inline LVecBase3f LMatrix4f::get_col3(int col) const;

3113 11 operator () 0 4 3566 22 LMatrix4f::operator () 0 2 1351 1352 10
/**
 *
 */
116
inline float &LMatrix4f::operator ()(int row, int col);
inline float LMatrix4f::operator ()(int row, int col) const;

3114 6 is_nan 0 4 3566 17 LMatrix4f::is_nan 0 1 1353 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix4f::is_nan(void) const;

3115 11 is_identity 0 4 3566 22 LMatrix4f::is_identity 0 1 1354 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix4f::is_identity(void) const;

3116 8 get_cell 0 4 3566 19 LMatrix4f::get_cell 0 1 1355 54
/**
 * Returns a particular element of the matrix.
 */
57
inline float LMatrix4f::get_cell(int row, int col) const;

3117 8 set_cell 0 4 3566 19 LMatrix4f::set_cell 0 1 1356 54
/**
 * Changes a particular element of the matrix.
 */
63
inline void LMatrix4f::set_cell(int row, int col, float value);

3118 8 get_data 0 4 3566 19 LMatrix4f::get_data 0 1 1357 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
52
inline float const *LMatrix4f::get_data(void) const;

3119 18 get_num_components 0 4 3566 29 LMatrix4f::get_num_components 0 1 1358 60
/**
 * Returns the number of elements in the matrix, 16.
 */
53
inline int LMatrix4f::get_num_components(void) const;

3120 5 begin 0 4 3566 16 LMatrix4f::begin 0 2 1359 1360 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
113
inline LMatrix4f::iterator LMatrix4f::begin(void);
inline LMatrix4f::const_iterator LMatrix4f::begin(void) const;

3121 3 end 0 4 3566 14 LMatrix4f::end 0 2 1361 1362 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
109
inline LMatrix4f::iterator LMatrix4f::end(void);
inline LMatrix4f::const_iterator LMatrix4f::end(void) const;

3122 10 operator < 0 4 3566 21 LMatrix4f::operator < 0 1 1363 0
64
inline bool LMatrix4f::operator <(LMatrix4f const &other) const;

3123 11 operator == 0 4 3566 22 LMatrix4f::operator == 0 1 1364 0
65
inline bool LMatrix4f::operator ==(LMatrix4f const &other) const;

3124 11 operator != 0 4 3566 22 LMatrix4f::operator != 0 1 1365 0
65
inline bool LMatrix4f::operator !=(LMatrix4f const &other) const;

3125 10 compare_to 0 4 3566 21 LMatrix4f::compare_to 0 2 1366 1367 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
137
inline int LMatrix4f::compare_to(LMatrix4f const &other) const;
int LMatrix4f::compare_to(LMatrix4f const &other, float threshold) const;

3126 8 get_hash 0 4 3566 19 LMatrix4f::get_hash 0 2 1368 1369 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
114
inline std::size_t LMatrix4f::get_hash(void) const;
inline std::size_t LMatrix4f::get_hash(float threshold) const;

3127 8 add_hash 0 4 3566 19 LMatrix4f::add_hash 0 2 1370 1371 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
144
inline std::size_t LMatrix4f::add_hash(std::size_t hash) const;
inline std::size_t LMatrix4f::add_hash(std::size_t hash, float threshold) const;

3128 5 xform 0 4 3566 16 LMatrix4f::xform 0 1 1372 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
62
inline LVecBase4f LMatrix4f::xform(LVecBase4f const &v) const;

3129 11 xform_point 0 4 3566 22 LMatrix4f::xform_point 0 1 1373 162
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase3f LMatrix4f::xform_point(LVecBase3f const &v) const;

3130 19 xform_point_general 0 4 3566 30 LMatrix4f::xform_point_general 0 1 1374 143
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */
76
inline LVecBase3f LMatrix4f::xform_point_general(LVecBase3f const &v) const;

3131 9 xform_vec 0 4 3566 20 LMatrix4f::xform_vec 0 1 1375 169
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */
66
inline LVecBase3f LMatrix4f::xform_vec(LVecBase3f const &v) const;

3132 17 xform_vec_general 0 4 3566 28 LMatrix4f::xform_vec_general 0 1 1376 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3f LMatrix4f::xform_vec_general(LVecBase3f const &v) const;

3133 14 xform_in_place 0 4 3566 25 LMatrix4f::xform_in_place 0 1 1377 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
59
inline void LMatrix4f::xform_in_place(LVecBase4f &v) const;

3134 20 xform_point_in_place 0 4 3566 31 LMatrix4f::xform_point_in_place 0 1 1378 139
/**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix4f::xform_point_in_place(LVecBase3f &v) const;

3135 28 xform_point_general_in_place 0 4 3566 39 LMatrix4f::xform_point_general_in_place 0 1 1379 120
/**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */
73
inline void LMatrix4f::xform_point_general_in_place(LVecBase3f &v) const;

3136 18 xform_vec_in_place 0 4 3566 29 LMatrix4f::xform_vec_in_place 0 1 1380 142
/**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */
63
inline void LMatrix4f::xform_vec_in_place(LVecBase3f &v) const;

3137 26 xform_vec_general_in_place 0 4 3566 37 LMatrix4f::xform_vec_general_in_place 0 1 1381 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix4f::xform_vec_general_in_place(LVecBase3f &v) const;

3138 8 multiply 0 4 3566 19 LMatrix4f::multiply 0 1 1382 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix4f::multiply(LMatrix4f const &other1, LMatrix4f const &other2);

3139 10 operator * 0 4 3566 21 LMatrix4f::operator * 0 2 1383 1384 0
129
inline LMatrix4f LMatrix4f::operator *(LMatrix4f const &other) const;
inline LMatrix4f LMatrix4f::operator *(float scalar) const;

3140 10 operator / 0 4 3566 21 LMatrix4f::operator / 0 1 1385 0
59
inline LMatrix4f LMatrix4f::operator /(float scalar) const;

3141 11 operator += 0 4 3566 22 LMatrix4f::operator += 0 1 1386 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix4f &LMatrix4f::operator +=(LMatrix4f const &other);

3142 11 operator -= 0 4 3566 22 LMatrix4f::operator -= 0 1 1387 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix4f &LMatrix4f::operator -=(LMatrix4f const &other);

3143 11 operator *= 0 4 3566 22 LMatrix4f::operator *= 0 2 1388 1389 22
/**
 *
 */

/**
 *
 */
121
inline LMatrix4f &LMatrix4f::operator *=(LMatrix4f const &other);
inline LMatrix4f &LMatrix4f::operator *=(float scalar);

3144 11 operator /= 0 4 3566 22 LMatrix4f::operator /= 0 1 1390 10
/**
 *
 */
55
inline LMatrix4f &LMatrix4f::operator /=(float scalar);

3145 18 componentwise_mult 0 4 3566 29 LMatrix4f::componentwise_mult 0 1 1391 10
/**
 *
 */
66
inline void LMatrix4f::componentwise_mult(LMatrix4f const &other);

3146 14 transpose_from 0 4 3566 25 LMatrix4f::transpose_from 0 1 1392 10
/**
 *
 */
62
inline void LMatrix4f::transpose_from(LMatrix4f const &other);

3147 18 transpose_in_place 0 4 3566 29 LMatrix4f::transpose_in_place 0 1 1393 10
/**
 *
 */
48
inline void LMatrix4f::transpose_in_place(void);

3148 11 invert_from 0 4 3566 22 LMatrix4f::invert_from 0 1 1394 461
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */
59
inline bool LMatrix4f::invert_from(LMatrix4f const &other);

3149 18 invert_affine_from 0 4 3566 29 LMatrix4f::invert_affine_from 0 1 1395 139
// bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component)
66
inline bool LMatrix4f::invert_affine_from(LMatrix4f const &other);

3150 15 invert_in_place 0 4 3566 26 LMatrix4f::invert_in_place 0 1 1396 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix4f::invert_in_place(void);

3151 10 accumulate 0 4 3566 21 LMatrix4f::accumulate 0 1 1397 46
/**
 * Computes (*this) += other * weight.
 */
72
inline void LMatrix4f::accumulate(LMatrix4f const &other, float weight);

3152 9 ident_mat 0 4 3566 20 LMatrix4f::ident_mat 0 1 1398 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix4f const &LMatrix4f::ident_mat(void);

3153 8 ones_mat 0 4 3566 19 LMatrix4f::ones_mat 0 1 1399 46
/**
 * Returns an matrix filled with ones.
 */
57
static inline LMatrix4f const &LMatrix4f::ones_mat(void);

3154 9 zeros_mat 0 4 3566 20 LMatrix4f::zeros_mat 0 1 1400 47
/**
 * Returns an matrix filled with zeros.
 */
58
static inline LMatrix4f const &LMatrix4f::zeros_mat(void);

3155 17 set_translate_mat 0 4 3566 28 LMatrix4f::set_translate_mat 0 1 1401 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix4f::set_translate_mat(LVecBase3f const &trans);

3156 14 set_rotate_mat 0 4 3566 25 LMatrix4f::set_rotate_mat 0 1 1402 122
/**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
104
void LMatrix4f::set_rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3157 23 set_rotate_mat_normaxis 0 4 3566 34 LMatrix4f::set_rotate_mat_normaxis 0 1 1403 166
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
113
void LMatrix4f::set_rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3158 13 set_scale_mat 0 4 3566 24 LMatrix4f::set_scale_mat 0 1 1404 97
/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
62
inline void LMatrix4f::set_scale_mat(LVecBase3f const &scale);

3159 13 set_shear_mat 0 4 3566 24 LMatrix4f::set_shear_mat 0 1 1405 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix4f::set_shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

3160 19 set_scale_shear_mat 0 4 3566 30 LMatrix4f::set_scale_shear_mat 0 1 1406 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
129
inline void LMatrix4f::set_scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

3161 13 translate_mat 0 4 3566 24 LMatrix4f::translate_mat 0 2 1407 1408 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
154
static inline LMatrix4f LMatrix4f::translate_mat(LVecBase3f const &trans);
static inline LMatrix4f LMatrix4f::translate_mat(float tx, float ty, float tz);

3162 10 rotate_mat 0 4 3566 21 LMatrix4f::rotate_mat 0 1 1409 118
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
119
static inline LMatrix4f LMatrix4f::rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3163 19 rotate_mat_normaxis 0 4 3566 30 LMatrix4f::rotate_mat_normaxis 0 1 1410 159
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
128
static inline LMatrix4f LMatrix4f::rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3164 9 scale_mat 0 4 3566 20 LMatrix4f::scale_mat 0 3 1411 1412 1413 253
/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated uniform scale.
 */
205
static inline LMatrix4f LMatrix4f::scale_mat(LVecBase3f const &scale);
static inline LMatrix4f LMatrix4f::scale_mat(float sx, float sy, float sz);
static inline LMatrix4f LMatrix4f::scale_mat(float scale);

3165 9 shear_mat 0 4 3566 20 LMatrix4f::shear_mat 0 2 1414 1415 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
224
static inline LMatrix4f LMatrix4f::shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4f LMatrix4f::shear_mat(float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

3166 15 scale_shear_mat 0 4 3566 26 LMatrix4f::scale_shear_mat 0 2 1416 1417 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
291
static inline LMatrix4f LMatrix4f::scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4f LMatrix4f::scale_shear_mat(float sx, float sy, float sz, float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

3167 13 y_to_z_up_mat 0 4 3566 24 LMatrix4f::y_to_z_up_mat 0 1 1418 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4f const &LMatrix4f::y_to_z_up_mat(void);

3168 13 z_to_y_up_mat 0 4 3566 24 LMatrix4f::z_to_y_up_mat 0 1 1419 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4f const &LMatrix4f::z_to_y_up_mat(void);

3169 11 convert_mat 0 4 3566 22 LMatrix4f::convert_mat 0 1 1420 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix4f const &LMatrix4f::convert_mat(CoordinateSystem from, CoordinateSystem to);

3170 12 almost_equal 0 4 3566 23 LMatrix4f::almost_equal 0 2 1421 1422 318
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */
143
bool LMatrix4f::almost_equal(LMatrix4f const &other, float threshold) const;
inline bool LMatrix4f::almost_equal(LMatrix4f const &other) const;

3171 6 output 0 4 3566 17 LMatrix4f::output 0 1 1423 10
/**
 *
 */
48
void LMatrix4f::output(std::ostream &out) const;

3172 5 write 0 4 3566 16 LMatrix4f::write 0 1 1424 10
/**
 *
 */
69
void LMatrix4f::write(std::ostream &out, int indent_level = 0) const;

3173 8 __repr__ 0 4 3566 19 LMatrix4f::__repr__ 0 1 1425 0
51
inline std::string LMatrix4f::__repr__(void) const;

3174 13 generate_hash 0 4 3566 24 LMatrix4f::generate_hash 0 2 1426 1427 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
157
inline void LMatrix4f::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix4f::generate_hash(ChecksumHashGenerator &hashgen, float scale) const;

3175 20 write_datagram_fixed 0 4 3566 31 LMatrix4f::write_datagram_fixed 0 1 1428 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix4f::write_datagram_fixed(Datagram &destination) const;

3176 19 read_datagram_fixed 0 4 3566 30 LMatrix4f::read_datagram_fixed 0 1 1429 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix4f::read_datagram_fixed(DatagramIterator &scan);

3177 14 write_datagram 0 4 3566 25 LMatrix4f::write_datagram 0 1 1430 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix4f::write_datagram(Datagram &destination) const;

3178 13 read_datagram 0 4 3566 24 LMatrix4f::read_datagram 0 1 1431 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix4f::read_datagram(DatagramIterator &source);

3179 14 get_class_type 0 4 3566 25 LMatrix4f::get_class_type 0 1 1432 0
50
static TypeHandle LMatrix4f::get_class_type(void);

3180 10 ~LMatrix4f 0 4 3566 21 LMatrix4f::~LMatrix4f 0 0 0
28
LMatrix4f::~LMatrix4f(void);

3181 18 UnalignedLMatrix4f 0 4 3570 38 UnalignedLMatrix4f::UnalignedLMatrix4f 0 4 1442 1443 1444 1445 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
424
inline UnalignedLMatrix4f::UnalignedLMatrix4f(void);
inline UnalignedLMatrix4f::UnalignedLMatrix4f(LMatrix4f const &copy);
inline UnalignedLMatrix4f::UnalignedLMatrix4f(UnalignedLMatrix4f const &copy);
inline UnalignedLMatrix4f::UnalignedLMatrix4f(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33);

3182 10 operator = 0 4 3570 30 UnalignedLMatrix4f::operator = 0 2 1446 1447 22
/**
 *
 */

/**
 *
 */
142
inline void UnalignedLMatrix4f::operator =(LMatrix4f const &copy);
inline void UnalignedLMatrix4f::operator =(UnalignedLMatrix4f const &copy);

3183 3 set 0 4 3570 23 UnalignedLMatrix4f::set 0 1 1448 10
/**
 *
 */
212
inline void UnalignedLMatrix4f::set(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33);

3184 11 operator () 0 4 3570 31 UnalignedLMatrix4f::operator () 0 2 1449 1450 10
/**
 *
 */
134
inline float &UnalignedLMatrix4f::operator ()(int row, int col);
inline float UnalignedLMatrix4f::operator ()(int row, int col) const;

3185 8 get_data 0 4 3570 28 UnalignedLMatrix4f::get_data 0 1 1451 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
61
inline float const *UnalignedLMatrix4f::get_data(void) const;

3186 18 get_num_components 0 4 3570 38 UnalignedLMatrix4f::get_num_components 0 1 1452 65
/**
 * Returns the number of elements in the matrix, sixteen.
 */
62
inline int UnalignedLMatrix4f::get_num_components(void) const;

3187 11 operator == 0 4 3570 31 UnalignedLMatrix4f::operator == 0 1 1453 0
83
inline bool UnalignedLMatrix4f::operator ==(UnalignedLMatrix4f const &other) const;

3188 11 operator != 0 4 3570 31 UnalignedLMatrix4f::operator != 0 1 1454 0
83
inline bool UnalignedLMatrix4f::operator !=(UnalignedLMatrix4f const &other) const;

3189 14 get_class_type 0 4 3570 34 UnalignedLMatrix4f::get_class_type 0 1 1455 0
59
static TypeHandle UnalignedLMatrix4f::get_class_type(void);

3190 19 ~UnalignedLMatrix4f 0 4 3570 39 UnalignedLMatrix4f::~UnalignedLMatrix4f 0 0 0
46
UnalignedLMatrix4f::~UnalignedLMatrix4f(void);

3191 11 operator [] 0 4 3574 27 LMatrix3d::Row::operator [] 0 2 1558 1559 10
/**
 *
 */
106
inline double LMatrix3d::Row::operator [](int i) const;
inline double &LMatrix3d::Row::operator [](int i);

3192 4 size 0 4 3574 20 LMatrix3d::Row::size 0 1 1560 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
45
static inline int LMatrix3d::Row::size(void);

3193 17 operator typecast 0 132 3574 33 LMatrix3d::Row::operator typecast 0 1 1561 0
47
inline operator LVecBase3d const &(void) const;

3194 3 Row 0 4 3574 19 LMatrix3d::Row::Row 0 1 1557 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix3d::Row::Row(LMatrix3d::Row const &) = default;

3195 4 ~Row 0 4 3574 20 LMatrix3d::Row::~Row 0 0 0
27
LMatrix3d::Row::~Row(void);

3196 11 operator [] 0 4 3575 28 LMatrix3d::CRow::operator [] 0 1 1563 0
56
inline double LMatrix3d::CRow::operator [](int i) const;

3197 4 size 0 4 3575 21 LMatrix3d::CRow::size 0 1 1564 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
46
static inline int LMatrix3d::CRow::size(void);

3198 17 operator typecast 0 132 3575 34 LMatrix3d::CRow::operator typecast 0 1 1565 0
47
inline operator LVecBase3d const &(void) const;

3199 4 CRow 0 4 3575 21 LMatrix3d::CRow::CRow 0 1 1562 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix3d::CRow::CRow(LMatrix3d::CRow const &) = default;

3200 5 ~CRow 0 4 3575 22 LMatrix3d::CRow::~CRow 0 0 0
29
LMatrix3d::CRow::~CRow(void);

3201 9 LMatrix3d 0 4 3572 20 LMatrix3d::LMatrix3d 0 4 1456 1457 1458 1459 96
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs the matrix from three individual rows.
 */
286
inline LMatrix3d::LMatrix3d(void);
inline LMatrix3d::LMatrix3d(LMatrix3d const &other);
inline LMatrix3d::LMatrix3d(double , double , double , double , double , double , double , double , double );
inline LMatrix3d::LMatrix3d(LVecBase3d const &, LVecBase3d const &, LVecBase3d const &);

3202 10 operator = 0 4 3572 21 LMatrix3d::operator = 0 2 1460 1461 22
/**
 *
 */

/**
 *
 */
112
inline void LMatrix3d::operator =(LMatrix3d const &other);
inline void LMatrix3d::operator =(double fill_value);

3203 12 operator new 0 4 3572 23 LMatrix3d::operator new 0 1 1462 0
122
inline void *LMatrix3d::operator new(std::size_t size);
inline void *LMatrix3d::operator new(std::size_t size, void *ptr);

3204 15 operator delete 0 4 3572 26 LMatrix3d::operator delete 0 0 0
106
inline void LMatrix3d::operator delete(void *ptr);
inline void LMatrix3d::operator delete(void *, void *);

3205 12 validate_ptr 0 4 3572 23 LMatrix3d::validate_ptr 0 0 0
60
static inline bool LMatrix3d::validate_ptr(void const *ptr);

3206 10 __reduce__ 0 4 3572 21 LMatrix3d::__reduce__ 0 1 1463 0
61
inline PyObject *LMatrix3d::__reduce__(PyObject *self) const;

3207 4 fill 0 4 3572 15 LMatrix3d::fill 0 1 1464 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
40
void LMatrix3d::fill(double fill_value);

3208 3 set 0 4 3572 14 LMatrix3d::set 0 1 1465 10
/**
 *
 */
135
inline void LMatrix3d::set(double e00, double e01, double e02, double e10, double e11, double e12, double e20, double e21, double e22);

3209 11 operator [] 0 4 3572 22 LMatrix3d::operator [] 0 2 1466 1467 0
112
inline LMatrix3d::CRow LMatrix3d::operator [](int i) const;
inline LMatrix3d::Row LMatrix3d::operator [](int i);

3210 4 size 0 4 3572 15 LMatrix3d::size 0 1 1468 55
/**
 * Returns 3: the number of rows of a LMatrix3.
 */
40
static inline int LMatrix3d::size(void);

3211 7 set_row 0 4 3572 18 LMatrix3d::set_row 0 2 1469 1470 193
/**
 * Replaces the indicated row of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */
123
inline void LMatrix3d::set_row(int row, LVecBase3d const &v);
inline void LMatrix3d::set_row(int row, LVecBase2d const &v);

3212 7 set_col 0 4 3572 18 LMatrix3d::set_col 0 2 1471 1472 196
/**
 * Replaces the indicated column of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */
123
inline void LMatrix3d::set_col(int col, LVecBase3d const &v);
inline void LMatrix3d::set_col(int col, LVecBase2d const &v);

3213 7 get_row 0 4 3572 18 LMatrix3d::get_row 0 2 1473 1474 192
// these versions inline better

/**
 * Returns the indicated row of the matrix as a three-component vector.
 */

/**
 * Stores the indicated row of the matrix as a three-component vector.
 */
123
inline LVecBase3d LMatrix3d::get_row(int row) const;
inline void LMatrix3d::get_row(LVecBase3d &result_vec, int row) const;

3214 7 get_col 0 4 3572 18 LMatrix3d::get_col 0 1 1475 82
/**
 * Returns the indicated column of the matrix as a three-component vector.
 */
52
inline LVecBase3d LMatrix3d::get_col(int col) const;

3215 8 get_row2 0 4 3572 19 LMatrix3d::get_row2 0 1 1476 106
/**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */
53
inline LVecBase2d LMatrix3d::get_row2(int row) const;

3216 8 get_col2 0 4 3572 19 LMatrix3d::get_col2 0 1 1477 106
/**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */
53
inline LVecBase2d LMatrix3d::get_col2(int col) const;

3217 11 operator () 0 4 3572 22 LMatrix3d::operator () 0 2 1478 1479 10
/**
 *
 */
118
inline double &LMatrix3d::operator ()(int row, int col);
inline double LMatrix3d::operator ()(int row, int col) const;

3218 6 is_nan 0 4 3572 17 LMatrix3d::is_nan 0 1 1480 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix3d::is_nan(void) const;

3219 11 is_identity 0 4 3572 22 LMatrix3d::is_identity 0 1 1481 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix3d::is_identity(void) const;

3220 8 get_cell 0 4 3572 19 LMatrix3d::get_cell 0 1 1482 54
/**
 * Returns a particular element of the matrix.
 */
58
inline double LMatrix3d::get_cell(int row, int col) const;

3221 8 set_cell 0 4 3572 19 LMatrix3d::set_cell 0 1 1483 54
/**
 * Changes a particular element of the matrix.
 */
64
inline void LMatrix3d::set_cell(int row, int col, double value);

3222 8 get_data 0 4 3572 19 LMatrix3d::get_data 0 1 1484 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
53
inline double const *LMatrix3d::get_data(void) const;

3223 18 get_num_components 0 4 3572 29 LMatrix3d::get_num_components 0 1 1485 62
/**
 * Returns the number of elements in the matrix, nine.
 */
53
inline int LMatrix3d::get_num_components(void) const;

3224 10 operator < 0 4 3572 21 LMatrix3d::operator < 0 1 1486 0
64
inline bool LMatrix3d::operator <(LMatrix3d const &other) const;

3225 11 operator == 0 4 3572 22 LMatrix3d::operator == 0 1 1487 0
65
inline bool LMatrix3d::operator ==(LMatrix3d const &other) const;

3226 11 operator != 0 4 3572 22 LMatrix3d::operator != 0 1 1488 0
65
inline bool LMatrix3d::operator !=(LMatrix3d const &other) const;

3227 10 compare_to 0 4 3572 21 LMatrix3d::compare_to 0 2 1489 1490 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
138
inline int LMatrix3d::compare_to(LMatrix3d const &other) const;
int LMatrix3d::compare_to(LMatrix3d const &other, double threshold) const;

3228 8 get_hash 0 4 3572 19 LMatrix3d::get_hash 0 2 1491 1492 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
115
inline std::size_t LMatrix3d::get_hash(void) const;
inline std::size_t LMatrix3d::get_hash(double threshold) const;

3229 8 add_hash 0 4 3572 19 LMatrix3d::add_hash 0 2 1493 1494 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
145
inline std::size_t LMatrix3d::add_hash(std::size_t hash) const;
inline std::size_t LMatrix3d::add_hash(std::size_t hash, double threshold) const;

3230 5 xform 0 4 3572 16 LMatrix3d::xform 0 1 1495 52
/**
 * 3-component vector or point times matrix.
 */
62
inline LVecBase3d LMatrix3d::xform(LVecBase3d const &v) const;

3231 11 xform_point 0 4 3572 22 LMatrix3d::xform_point 0 1 1496 162
/**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase2d LMatrix3d::xform_point(LVecBase2d const &v) const;

3232 9 xform_vec 0 4 3572 20 LMatrix3d::xform_vec 0 2 1497 1498 357
/**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
133
inline LVecBase2d LMatrix3d::xform_vec(LVecBase2d const &v) const;
inline LVecBase3d LMatrix3d::xform_vec(LVecBase3d const &v) const;

3233 17 xform_vec_general 0 4 3572 28 LMatrix3d::xform_vec_general 0 1 1499 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3d LMatrix3d::xform_vec_general(LVecBase3d const &v) const;

3234 14 xform_in_place 0 4 3572 25 LMatrix3d::xform_in_place 0 1 1500 52
/**
 * 3-component vector or point times matrix.
 */
59
inline void LMatrix3d::xform_in_place(LVecBase3d &v) const;

3235 20 xform_point_in_place 0 4 3572 31 LMatrix3d::xform_point_in_place 0 1 1501 139
/**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix3d::xform_point_in_place(LVecBase2d &v) const;

3236 18 xform_vec_in_place 0 4 3572 29 LMatrix3d::xform_vec_in_place 0 2 1502 1503 310
/**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
127
inline void LMatrix3d::xform_vec_in_place(LVecBase2d &v) const;
inline void LMatrix3d::xform_vec_in_place(LVecBase3d &v) const;

3237 26 xform_vec_general_in_place 0 4 3572 37 LMatrix3d::xform_vec_general_in_place 0 1 1504 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix3d::xform_vec_general_in_place(LVecBase3d &v) const;

3238 8 multiply 0 4 3572 19 LMatrix3d::multiply 0 1 1505 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix3d::multiply(LMatrix3d const &other1, LMatrix3d const &other2);

3239 10 operator * 0 4 3572 21 LMatrix3d::operator * 0 2 1506 1507 0
130
inline LMatrix3d LMatrix3d::operator *(LMatrix3d const &other) const;
inline LMatrix3d LMatrix3d::operator *(double scalar) const;

3240 10 operator / 0 4 3572 21 LMatrix3d::operator / 0 1 1508 0
60
inline LMatrix3d LMatrix3d::operator /(double scalar) const;

3241 11 operator += 0 4 3572 22 LMatrix3d::operator += 0 1 1509 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix3d &LMatrix3d::operator +=(LMatrix3d const &other);

3242 11 operator -= 0 4 3572 22 LMatrix3d::operator -= 0 1 1510 66
/**
 * Performs a memberwise subtraction between two matrices.
 */
65
inline LMatrix3d &LMatrix3d::operator -=(LMatrix3d const &other);

3243 11 operator *= 0 4 3572 22 LMatrix3d::operator *= 0 2 1511 1512 51
/**
 *
 */

/**
 * Performs a memberwise scale.
 */
122
inline LMatrix3d &LMatrix3d::operator *=(LMatrix3d const &other);
inline LMatrix3d &LMatrix3d::operator *=(double scalar);

3244 11 operator /= 0 4 3572 22 LMatrix3d::operator /= 0 1 1513 39
/**
 * Performs a memberwise scale.
 */
56
inline LMatrix3d &LMatrix3d::operator /=(double scalar);

3245 18 componentwise_mult 0 4 3572 29 LMatrix3d::componentwise_mult 0 1 1514 10
/**
 *
 */
66
inline void LMatrix3d::componentwise_mult(LMatrix3d const &other);

3246 11 determinant 0 4 3572 22 LMatrix3d::determinant 0 1 1515 49
/**
 * Returns the determinant of the matrix.
 */
49
inline double LMatrix3d::determinant(void) const;

3247 14 transpose_from 0 4 3572 25 LMatrix3d::transpose_from 0 1 1516 10
/**
 *
 */
62
inline void LMatrix3d::transpose_from(LMatrix3d const &other);

3248 18 transpose_in_place 0 4 3572 29 LMatrix3d::transpose_in_place 0 1 1517 10
/**
 *
 */
48
inline void LMatrix3d::transpose_in_place(void);

3249 11 invert_from 0 4 3572 22 LMatrix3d::invert_from 0 1 1518 463
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */
59
inline bool LMatrix3d::invert_from(LMatrix3d const &other);

3250 15 invert_in_place 0 4 3572 26 LMatrix3d::invert_in_place 0 1 1519 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix3d::invert_in_place(void);

3251 21 invert_transpose_from 0 4 3572 32 LMatrix3d::invert_transpose_from 0 2 1520 1521 230
/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */

/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */
139
inline bool LMatrix3d::invert_transpose_from(LMatrix3d const &other);
inline bool LMatrix3d::invert_transpose_from(LMatrix4d const &other);

3252 9 ident_mat 0 4 3572 20 LMatrix3d::ident_mat 0 1 1522 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix3d const &LMatrix3d::ident_mat(void);

3253 17 set_translate_mat 0 4 3572 28 LMatrix3d::set_translate_mat 0 1 1523 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix3d::set_translate_mat(LVecBase2d const &trans);

3254 14 set_rotate_mat 0 4 3572 25 LMatrix3d::set_rotate_mat 0 2 1524 1525 225
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
158
inline void LMatrix3d::set_rotate_mat(double angle);
void LMatrix3d::set_rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3255 13 set_scale_mat 0 4 3572 24 LMatrix3d::set_scale_mat 0 2 1526 1527 194
/**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */

/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
125
inline void LMatrix3d::set_scale_mat(LVecBase2d const &scale);
inline void LMatrix3d::set_scale_mat(LVecBase3d const &scale);

3256 13 translate_mat 0 4 3572 24 LMatrix3d::translate_mat 0 2 1528 1529 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
146
static inline LMatrix3d LMatrix3d::translate_mat(LVecBase2d const &trans);
static inline LMatrix3d LMatrix3d::translate_mat(double tx, double ty);

3257 10 rotate_mat 0 4 3572 21 LMatrix3d::rotate_mat 0 2 1530 1531 211
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
181
static inline LMatrix3d LMatrix3d::rotate_mat(double angle);
static inline LMatrix3d LMatrix3d::rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3258 9 scale_mat 0 4 3572 20 LMatrix3d::scale_mat 0 4 1532 1533 1534 1535 356
/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */
288
static inline LMatrix3d LMatrix3d::scale_mat(LVecBase2d const &scale);
static inline LMatrix3d LMatrix3d::scale_mat(double sx, double sy);
static inline LMatrix3d LMatrix3d::scale_mat(LVecBase3d const &scale);
static inline LMatrix3d LMatrix3d::scale_mat(double sx, double sy, double sz);

3259 23 set_rotate_mat_normaxis 0 4 3572 34 LMatrix3d::set_rotate_mat_normaxis 0 1 1536 163
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
114
void LMatrix3d::set_rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3260 19 rotate_mat_normaxis 0 4 3572 30 LMatrix3d::rotate_mat_normaxis 0 1 1537 156
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
129
static inline LMatrix3d LMatrix3d::rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3261 13 set_shear_mat 0 4 3572 24 LMatrix3d::set_shear_mat 0 1 1538 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix3d::set_shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3262 9 shear_mat 0 4 3572 20 LMatrix3d::shear_mat 0 2 1539 1540 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
227
static inline LMatrix3d LMatrix3d::shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3d LMatrix3d::shear_mat(double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3263 19 set_scale_shear_mat 0 4 3572 30 LMatrix3d::set_scale_shear_mat 0 1 1541 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
122
void LMatrix3d::set_scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3264 15 scale_shear_mat 0 4 3572 26 LMatrix3d::scale_shear_mat 0 2 1542 1543 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
297
static inline LMatrix3d LMatrix3d::scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3d LMatrix3d::scale_shear_mat(double sx, double sy, double sz, double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3265 11 convert_mat 0 4 3572 22 LMatrix3d::convert_mat 0 1 1544 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix3d const &LMatrix3d::convert_mat(CoordinateSystem from, CoordinateSystem to);

3266 12 almost_equal 0 4 3572 23 LMatrix3d::almost_equal 0 2 1545 1546 212
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */
144
bool LMatrix3d::almost_equal(LMatrix3d const &other, double threshold) const;
inline bool LMatrix3d::almost_equal(LMatrix3d const &other) const;

3267 6 output 0 4 3572 17 LMatrix3d::output 0 1 1547 10
/**
 *
 */
48
void LMatrix3d::output(std::ostream &out) const;

3268 5 write 0 4 3572 16 LMatrix3d::write 0 1 1548 10
/**
 *
 */
69
void LMatrix3d::write(std::ostream &out, int indent_level = 0) const;

3269 8 __repr__ 0 4 3572 19 LMatrix3d::__repr__ 0 1 1549 0
51
inline std::string LMatrix3d::__repr__(void) const;

3270 13 generate_hash 0 4 3572 24 LMatrix3d::generate_hash 0 2 1550 1551 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
162
inline void LMatrix3d::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix3d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

3271 20 write_datagram_fixed 0 4 3572 31 LMatrix3d::write_datagram_fixed 0 1 1552 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix3d::write_datagram_fixed(Datagram &destination) const;

3272 19 read_datagram_fixed 0 4 3572 30 LMatrix3d::read_datagram_fixed 0 1 1553 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix3d::read_datagram_fixed(DatagramIterator &scan);

3273 14 write_datagram 0 4 3572 25 LMatrix3d::write_datagram 0 1 1554 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix3d::write_datagram(Datagram &destination) const;

3274 13 read_datagram 0 4 3572 24 LMatrix3d::read_datagram 0 1 1555 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix3d::read_datagram(DatagramIterator &source);

3275 14 get_class_type 0 4 3572 25 LMatrix3d::get_class_type 0 1 1556 0
50
static TypeHandle LMatrix3d::get_class_type(void);

3276 10 ~LMatrix3d 0 4 3572 21 LMatrix3d::~LMatrix3d 0 0 0
28
LMatrix3d::~LMatrix3d(void);

3277 11 operator [] 0 4 3578 27 LMatrix4d::Row::operator [] 0 2 1678 1679 10
/**
 *
 */
106
inline double LMatrix4d::Row::operator [](int i) const;
inline double &LMatrix4d::Row::operator [](int i);

3278 4 size 0 4 3578 20 LMatrix4d::Row::size 0 1 1680 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
45
static inline int LMatrix4d::Row::size(void);

3279 17 operator typecast 0 132 3578 33 LMatrix4d::Row::operator typecast 0 1 1681 0
47
inline operator LVecBase4d const &(void) const;

3280 3 Row 0 4 3578 19 LMatrix4d::Row::Row 0 1 1677 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix4d::Row::Row(LMatrix4d::Row const &) = default;

3281 4 ~Row 0 4 3578 20 LMatrix4d::Row::~Row 0 0 0
27
LMatrix4d::Row::~Row(void);

3282 11 operator [] 0 4 3579 28 LMatrix4d::CRow::operator [] 0 1 1683 0
56
inline double LMatrix4d::CRow::operator [](int i) const;

3283 4 size 0 4 3579 21 LMatrix4d::CRow::size 0 1 1684 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
46
static inline int LMatrix4d::CRow::size(void);

3284 17 operator typecast 0 132 3579 34 LMatrix4d::CRow::operator typecast 0 1 1685 0
47
inline operator LVecBase4d const &(void) const;

3285 4 CRow 0 4 3579 21 LMatrix4d::CRow::CRow 0 1 1682 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix4d::CRow::CRow(LMatrix4d::CRow const &) = default;

3286 5 ~CRow 0 4 3579 22 LMatrix4d::CRow::~CRow 0 0 0
29
LMatrix4d::CRow::~CRow(void);

3287 9 LMatrix4d 0 4 3576 20 LMatrix4d::LMatrix4d 0 7 1566 1567 1568 1569 1570 1571 1572 228
// Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component.

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs the matrix from four individual rows.
 */

/**
 *
 */

/**
 *
 */
564
inline LMatrix4d::LMatrix4d(void);
inline LMatrix4d::LMatrix4d(LMatrix4d const &other);
inline LMatrix4d::LMatrix4d(UnalignedLMatrix4d const &other);
inline LMatrix4d::LMatrix4d(double , double , double , double , double , double , double , double , double , double , double , double , double , double , double , double );
inline LMatrix4d::LMatrix4d(LVecBase4d const &, LVecBase4d const &, LVecBase4d const &, LVecBase4d const &);
inline LMatrix4d::LMatrix4d(LMatrix3d const &upper3);
inline LMatrix4d::LMatrix4d(LMatrix3d const &upper3, LVecBase3d const &trans);

3288 10 operator = 0 4 3576 21 LMatrix4d::operator = 0 3 1573 1574 1575 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
180
inline void LMatrix4d::operator =(LMatrix4d const &other);
inline void LMatrix4d::operator =(UnalignedLMatrix4d const &other);
inline void LMatrix4d::operator =(double fill_value);

3289 12 operator new 0 4 3576 23 LMatrix4d::operator new 0 1 1576 0
122
inline void *LMatrix4d::operator new(std::size_t size);
inline void *LMatrix4d::operator new(std::size_t size, void *ptr);

3290 15 operator delete 0 4 3576 26 LMatrix4d::operator delete 0 0 0
106
inline void LMatrix4d::operator delete(void *ptr);
inline void LMatrix4d::operator delete(void *, void *);

3291 12 validate_ptr 0 4 3576 23 LMatrix4d::validate_ptr 0 0 0
60
static inline bool LMatrix4d::validate_ptr(void const *ptr);

3292 10 __reduce__ 0 4 3576 21 LMatrix4d::__reduce__ 0 1 1577 0
61
inline PyObject *LMatrix4d::__reduce__(PyObject *self) const;

3293 4 fill 0 4 3576 15 LMatrix4d::fill 0 1 1578 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
47
inline void LMatrix4d::fill(double fill_value);

3294 3 set 0 4 3576 14 LMatrix4d::set 0 1 1579 10
/**
 *
 */
219
inline void LMatrix4d::set(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33);

3295 11 set_upper_3 0 4 3576 22 LMatrix4d::set_upper_3 0 1 1580 87
// Get and set the upper 3x3 rotation matrix.

/**
 * Sets the upper 3x3 submatrix.
 */
60
inline void LMatrix4d::set_upper_3(LMatrix3d const &upper3);

3296 11 get_upper_3 0 4 3576 22 LMatrix4d::get_upper_3 0 1 1581 45
/**
 * Retrieves the upper 3x3 submatrix.
 */
52
inline LMatrix3d LMatrix4d::get_upper_3(void) const;

3297 11 operator [] 0 4 3576 22 LMatrix4d::operator [] 0 2 1582 1583 0
112
inline LMatrix4d::CRow LMatrix4d::operator [](int i) const;
inline LMatrix4d::Row LMatrix4d::operator [](int i);

3298 4 size 0 4 3576 15 LMatrix4d::size 0 1 1584 55
/**
 * Returns 4: the number of rows of a LMatrix4.
 */
40
static inline int LMatrix4d::size(void);

3299 7 set_row 0 4 3576 18 LMatrix4d::set_row 0 2 1585 1586 173
/**
 * Replaces the indicated row of the matrix.
 */

/**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */
123
inline void LMatrix4d::set_row(int row, LVecBase4d const &v);
inline void LMatrix4d::set_row(int row, LVecBase3d const &v);

3300 7 set_col 0 4 3576 18 LMatrix4d::set_col 0 2 1587 1588 176
/**
 * Replaces the indicated column of the matrix.
 */

/**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */
123
inline void LMatrix4d::set_col(int col, LVecBase4d const &v);
inline void LMatrix4d::set_col(int col, LVecBase3d const &v);

3301 7 get_row 0 4 3576 18 LMatrix4d::get_row 0 2 1589 1590 186
// these versions inline better

/**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */

/**
 * Stores the indicated row of the matrix as a 4-component vector.
 */
123
inline LVecBase4d LMatrix4d::get_row(int row) const;
inline void LMatrix4d::get_row(LVecBase4d &result_vec, int row) const;

3302 7 get_col 0 4 3576 18 LMatrix4d::get_col 0 1 1591 80
/**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */
52
inline LVecBase4d LMatrix4d::get_col(int col) const;

3303 8 get_row3 0 4 3576 19 LMatrix4d::get_row3 0 2 1592 1593 205
/**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */

/**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */
125
inline LVecBase3d LMatrix4d::get_row3(int row) const;
inline void LMatrix4d::get_row3(LVecBase3d &result_vec, int row) const;

3304 8 get_col3 0 4 3576 19 LMatrix4d::get_col3 0 1 1594 106
/**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */
53
inline LVecBase3d LMatrix4d::get_col3(int col) const;

3305 11 operator () 0 4 3576 22 LMatrix4d::operator () 0 2 1595 1596 10
/**
 *
 */
118
inline double &LMatrix4d::operator ()(int row, int col);
inline double LMatrix4d::operator ()(int row, int col) const;

3306 6 is_nan 0 4 3576 17 LMatrix4d::is_nan 0 1 1597 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix4d::is_nan(void) const;

3307 11 is_identity 0 4 3576 22 LMatrix4d::is_identity 0 1 1598 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix4d::is_identity(void) const;

3308 8 get_cell 0 4 3576 19 LMatrix4d::get_cell 0 1 1599 54
/**
 * Returns a particular element of the matrix.
 */
58
inline double LMatrix4d::get_cell(int row, int col) const;

3309 8 set_cell 0 4 3576 19 LMatrix4d::set_cell 0 1 1600 54
/**
 * Changes a particular element of the matrix.
 */
64
inline void LMatrix4d::set_cell(int row, int col, double value);

3310 8 get_data 0 4 3576 19 LMatrix4d::get_data 0 1 1601 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
53
inline double const *LMatrix4d::get_data(void) const;

3311 18 get_num_components 0 4 3576 29 LMatrix4d::get_num_components 0 1 1602 60
/**
 * Returns the number of elements in the matrix, 16.
 */
53
inline int LMatrix4d::get_num_components(void) const;

3312 5 begin 0 4 3576 16 LMatrix4d::begin 0 2 1603 1604 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
113
inline LMatrix4d::iterator LMatrix4d::begin(void);
inline LMatrix4d::const_iterator LMatrix4d::begin(void) const;

3313 3 end 0 4 3576 14 LMatrix4d::end 0 2 1605 1606 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
109
inline LMatrix4d::iterator LMatrix4d::end(void);
inline LMatrix4d::const_iterator LMatrix4d::end(void) const;

3314 10 operator < 0 4 3576 21 LMatrix4d::operator < 0 1 1607 0
64
inline bool LMatrix4d::operator <(LMatrix4d const &other) const;

3315 11 operator == 0 4 3576 22 LMatrix4d::operator == 0 1 1608 0
65
inline bool LMatrix4d::operator ==(LMatrix4d const &other) const;

3316 11 operator != 0 4 3576 22 LMatrix4d::operator != 0 1 1609 0
65
inline bool LMatrix4d::operator !=(LMatrix4d const &other) const;

3317 10 compare_to 0 4 3576 21 LMatrix4d::compare_to 0 2 1610 1611 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
138
inline int LMatrix4d::compare_to(LMatrix4d const &other) const;
int LMatrix4d::compare_to(LMatrix4d const &other, double threshold) const;

3318 8 get_hash 0 4 3576 19 LMatrix4d::get_hash 0 2 1612 1613 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
115
inline std::size_t LMatrix4d::get_hash(void) const;
inline std::size_t LMatrix4d::get_hash(double threshold) const;

3319 8 add_hash 0 4 3576 19 LMatrix4d::add_hash 0 2 1614 1615 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
145
inline std::size_t LMatrix4d::add_hash(std::size_t hash) const;
inline std::size_t LMatrix4d::add_hash(std::size_t hash, double threshold) const;

3320 5 xform 0 4 3576 16 LMatrix4d::xform 0 1 1616 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
62
inline LVecBase4d LMatrix4d::xform(LVecBase4d const &v) const;

3321 11 xform_point 0 4 3576 22 LMatrix4d::xform_point 0 1 1617 162
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase3d LMatrix4d::xform_point(LVecBase3d const &v) const;

3322 19 xform_point_general 0 4 3576 30 LMatrix4d::xform_point_general 0 1 1618 143
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */
76
inline LVecBase3d LMatrix4d::xform_point_general(LVecBase3d const &v) const;

3323 9 xform_vec 0 4 3576 20 LMatrix4d::xform_vec 0 1 1619 169
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */
66
inline LVecBase3d LMatrix4d::xform_vec(LVecBase3d const &v) const;

3324 17 xform_vec_general 0 4 3576 28 LMatrix4d::xform_vec_general 0 1 1620 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3d LMatrix4d::xform_vec_general(LVecBase3d const &v) const;

3325 14 xform_in_place 0 4 3576 25 LMatrix4d::xform_in_place 0 1 1621 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
59
inline void LMatrix4d::xform_in_place(LVecBase4d &v) const;

3326 20 xform_point_in_place 0 4 3576 31 LMatrix4d::xform_point_in_place 0 1 1622 139
/**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix4d::xform_point_in_place(LVecBase3d &v) const;

3327 28 xform_point_general_in_place 0 4 3576 39 LMatrix4d::xform_point_general_in_place 0 1 1623 120
/**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */
73
inline void LMatrix4d::xform_point_general_in_place(LVecBase3d &v) const;

3328 18 xform_vec_in_place 0 4 3576 29 LMatrix4d::xform_vec_in_place 0 1 1624 142
/**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */
63
inline void LMatrix4d::xform_vec_in_place(LVecBase3d &v) const;

3329 26 xform_vec_general_in_place 0 4 3576 37 LMatrix4d::xform_vec_general_in_place 0 1 1625 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix4d::xform_vec_general_in_place(LVecBase3d &v) const;

3330 8 multiply 0 4 3576 19 LMatrix4d::multiply 0 1 1626 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix4d::multiply(LMatrix4d const &other1, LMatrix4d const &other2);

3331 10 operator * 0 4 3576 21 LMatrix4d::operator * 0 2 1627 1628 0
130
inline LMatrix4d LMatrix4d::operator *(LMatrix4d const &other) const;
inline LMatrix4d LMatrix4d::operator *(double scalar) const;

3332 10 operator / 0 4 3576 21 LMatrix4d::operator / 0 1 1629 0
60
inline LMatrix4d LMatrix4d::operator /(double scalar) const;

3333 11 operator += 0 4 3576 22 LMatrix4d::operator += 0 1 1630 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix4d &LMatrix4d::operator +=(LMatrix4d const &other);

3334 11 operator -= 0 4 3576 22 LMatrix4d::operator -= 0 1 1631 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix4d &LMatrix4d::operator -=(LMatrix4d const &other);

3335 11 operator *= 0 4 3576 22 LMatrix4d::operator *= 0 2 1632 1633 22
/**
 *
 */

/**
 *
 */
122
inline LMatrix4d &LMatrix4d::operator *=(LMatrix4d const &other);
inline LMatrix4d &LMatrix4d::operator *=(double scalar);

3336 11 operator /= 0 4 3576 22 LMatrix4d::operator /= 0 1 1634 10
/**
 *
 */
56
inline LMatrix4d &LMatrix4d::operator /=(double scalar);

3337 18 componentwise_mult 0 4 3576 29 LMatrix4d::componentwise_mult 0 1 1635 10
/**
 *
 */
66
inline void LMatrix4d::componentwise_mult(LMatrix4d const &other);

3338 14 transpose_from 0 4 3576 25 LMatrix4d::transpose_from 0 1 1636 10
/**
 *
 */
62
inline void LMatrix4d::transpose_from(LMatrix4d const &other);

3339 18 transpose_in_place 0 4 3576 29 LMatrix4d::transpose_in_place 0 1 1637 10
/**
 *
 */
48
inline void LMatrix4d::transpose_in_place(void);

3340 11 invert_from 0 4 3576 22 LMatrix4d::invert_from 0 1 1638 461
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */
59
inline bool LMatrix4d::invert_from(LMatrix4d const &other);

3341 18 invert_affine_from 0 4 3576 29 LMatrix4d::invert_affine_from 0 1 1639 139
// bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component)
66
inline bool LMatrix4d::invert_affine_from(LMatrix4d const &other);

3342 15 invert_in_place 0 4 3576 26 LMatrix4d::invert_in_place 0 1 1640 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix4d::invert_in_place(void);

3343 10 accumulate 0 4 3576 21 LMatrix4d::accumulate 0 1 1641 46
/**
 * Computes (*this) += other * weight.
 */
73
inline void LMatrix4d::accumulate(LMatrix4d const &other, double weight);

3344 9 ident_mat 0 4 3576 20 LMatrix4d::ident_mat 0 1 1642 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix4d const &LMatrix4d::ident_mat(void);

3345 8 ones_mat 0 4 3576 19 LMatrix4d::ones_mat 0 1 1643 46
/**
 * Returns an matrix filled with ones.
 */
57
static inline LMatrix4d const &LMatrix4d::ones_mat(void);

3346 9 zeros_mat 0 4 3576 20 LMatrix4d::zeros_mat 0 1 1644 47
/**
 * Returns an matrix filled with zeros.
 */
58
static inline LMatrix4d const &LMatrix4d::zeros_mat(void);

3347 17 set_translate_mat 0 4 3576 28 LMatrix4d::set_translate_mat 0 1 1645 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix4d::set_translate_mat(LVecBase3d const &trans);

3348 14 set_rotate_mat 0 4 3576 25 LMatrix4d::set_rotate_mat 0 1 1646 122
/**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
105
void LMatrix4d::set_rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3349 23 set_rotate_mat_normaxis 0 4 3576 34 LMatrix4d::set_rotate_mat_normaxis 0 1 1647 166
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
114
void LMatrix4d::set_rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3350 13 set_scale_mat 0 4 3576 24 LMatrix4d::set_scale_mat 0 1 1648 97
/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
62
inline void LMatrix4d::set_scale_mat(LVecBase3d const &scale);

3351 13 set_shear_mat 0 4 3576 24 LMatrix4d::set_shear_mat 0 1 1649 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix4d::set_shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3352 19 set_scale_shear_mat 0 4 3576 30 LMatrix4d::set_scale_shear_mat 0 1 1650 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
129
inline void LMatrix4d::set_scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3353 13 translate_mat 0 4 3576 24 LMatrix4d::translate_mat 0 2 1651 1652 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
157
static inline LMatrix4d LMatrix4d::translate_mat(LVecBase3d const &trans);
static inline LMatrix4d LMatrix4d::translate_mat(double tx, double ty, double tz);

3354 10 rotate_mat 0 4 3576 21 LMatrix4d::rotate_mat 0 1 1653 118
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
120
static inline LMatrix4d LMatrix4d::rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3355 19 rotate_mat_normaxis 0 4 3576 30 LMatrix4d::rotate_mat_normaxis 0 1 1654 159
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
129
static inline LMatrix4d LMatrix4d::rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3356 9 scale_mat 0 4 3576 20 LMatrix4d::scale_mat 0 3 1655 1656 1657 253
/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated uniform scale.
 */
209
static inline LMatrix4d LMatrix4d::scale_mat(LVecBase3d const &scale);
static inline LMatrix4d LMatrix4d::scale_mat(double sx, double sy, double sz);
static inline LMatrix4d LMatrix4d::scale_mat(double scale);

3357 9 shear_mat 0 4 3576 20 LMatrix4d::shear_mat 0 2 1658 1659 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
227
static inline LMatrix4d LMatrix4d::shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4d LMatrix4d::shear_mat(double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3358 15 scale_shear_mat 0 4 3576 26 LMatrix4d::scale_shear_mat 0 2 1660 1661 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
297
static inline LMatrix4d LMatrix4d::scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4d LMatrix4d::scale_shear_mat(double sx, double sy, double sz, double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3359 13 y_to_z_up_mat 0 4 3576 24 LMatrix4d::y_to_z_up_mat 0 1 1662 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4d const &LMatrix4d::y_to_z_up_mat(void);

3360 13 z_to_y_up_mat 0 4 3576 24 LMatrix4d::z_to_y_up_mat 0 1 1663 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4d const &LMatrix4d::z_to_y_up_mat(void);

3361 11 convert_mat 0 4 3576 22 LMatrix4d::convert_mat 0 1 1664 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix4d const &LMatrix4d::convert_mat(CoordinateSystem from, CoordinateSystem to);

3362 12 almost_equal 0 4 3576 23 LMatrix4d::almost_equal 0 2 1665 1666 318
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */
144
bool LMatrix4d::almost_equal(LMatrix4d const &other, double threshold) const;
inline bool LMatrix4d::almost_equal(LMatrix4d const &other) const;

3363 6 output 0 4 3576 17 LMatrix4d::output 0 1 1667 10
/**
 *
 */
48
void LMatrix4d::output(std::ostream &out) const;

3364 5 write 0 4 3576 16 LMatrix4d::write 0 1 1668 10
/**
 *
 */
69
void LMatrix4d::write(std::ostream &out, int indent_level = 0) const;

3365 8 __repr__ 0 4 3576 19 LMatrix4d::__repr__ 0 1 1669 0
51
inline std::string LMatrix4d::__repr__(void) const;

3366 13 generate_hash 0 4 3576 24 LMatrix4d::generate_hash 0 2 1670 1671 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
158
inline void LMatrix4d::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix4d::generate_hash(ChecksumHashGenerator &hashgen, double scale) const;

3367 20 write_datagram_fixed 0 4 3576 31 LMatrix4d::write_datagram_fixed 0 1 1672 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix4d::write_datagram_fixed(Datagram &destination) const;

3368 19 read_datagram_fixed 0 4 3576 30 LMatrix4d::read_datagram_fixed 0 1 1673 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix4d::read_datagram_fixed(DatagramIterator &scan);

3369 14 write_datagram 0 4 3576 25 LMatrix4d::write_datagram 0 1 1674 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix4d::write_datagram(Datagram &destination) const;

3370 13 read_datagram 0 4 3576 24 LMatrix4d::read_datagram 0 1 1675 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix4d::read_datagram(DatagramIterator &source);

3371 14 get_class_type 0 4 3576 25 LMatrix4d::get_class_type 0 1 1676 0
50
static TypeHandle LMatrix4d::get_class_type(void);

3372 10 ~LMatrix4d 0 4 3576 21 LMatrix4d::~LMatrix4d 0 0 0
28
LMatrix4d::~LMatrix4d(void);

3373 18 UnalignedLMatrix4d 0 4 3580 38 UnalignedLMatrix4d::UnalignedLMatrix4d 0 4 1686 1687 1688 1689 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
440
inline UnalignedLMatrix4d::UnalignedLMatrix4d(void);
inline UnalignedLMatrix4d::UnalignedLMatrix4d(LMatrix4d const &copy);
inline UnalignedLMatrix4d::UnalignedLMatrix4d(UnalignedLMatrix4d const &copy);
inline UnalignedLMatrix4d::UnalignedLMatrix4d(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33);

3374 10 operator = 0 4 3580 30 UnalignedLMatrix4d::operator = 0 2 1690 1691 22
/**
 *
 */

/**
 *
 */
142
inline void UnalignedLMatrix4d::operator =(LMatrix4d const &copy);
inline void UnalignedLMatrix4d::operator =(UnalignedLMatrix4d const &copy);

3375 3 set 0 4 3580 23 UnalignedLMatrix4d::set 0 1 1692 10
/**
 *
 */
228
inline void UnalignedLMatrix4d::set(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33);

3376 11 operator () 0 4 3580 31 UnalignedLMatrix4d::operator () 0 2 1693 1694 10
/**
 *
 */
136
inline double &UnalignedLMatrix4d::operator ()(int row, int col);
inline double UnalignedLMatrix4d::operator ()(int row, int col) const;

3377 8 get_data 0 4 3580 28 UnalignedLMatrix4d::get_data 0 1 1695 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
62
inline double const *UnalignedLMatrix4d::get_data(void) const;

3378 18 get_num_components 0 4 3580 38 UnalignedLMatrix4d::get_num_components 0 1 1696 65
/**
 * Returns the number of elements in the matrix, sixteen.
 */
62
inline int UnalignedLMatrix4d::get_num_components(void) const;

3379 11 operator == 0 4 3580 31 UnalignedLMatrix4d::operator == 0 1 1697 0
83
inline bool UnalignedLMatrix4d::operator ==(UnalignedLMatrix4d const &other) const;

3380 11 operator != 0 4 3580 31 UnalignedLMatrix4d::operator != 0 1 1698 0
83
inline bool UnalignedLMatrix4d::operator !=(UnalignedLMatrix4d const &other) const;

3381 14 get_class_type 0 4 3580 34 UnalignedLMatrix4d::get_class_type 0 1 1699 0
59
static TypeHandle UnalignedLMatrix4d::get_class_type(void);

3382 19 ~UnalignedLMatrix4d 0 4 3580 39 UnalignedLMatrix4d::~UnalignedLMatrix4d 0 0 0
46
UnalignedLMatrix4d::~UnalignedLMatrix4d(void);

3383 10 operator * 0 1 0 10 operator * 0 24 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 0
1659
inline LVecBase3f operator *(LVecBase3f const &v, LMatrix3f const &m);
inline LVector3f operator *(LVector3f const &v, LMatrix3f const &m);
inline LPoint3f operator *(LPoint3f const &v, LMatrix3f const &m);
inline LVector2f operator *(LVector2f const &v, LMatrix3f const &m);
inline LPoint2f operator *(LPoint2f const &v, LMatrix3f const &m);
inline LVecBase4f operator *(LVecBase4f const &v, LMatrix4f const &m);
inline LPoint4f operator *(LPoint4f const &v, LMatrix4f const &m);
inline LVector4f operator *(LVector4f const &v, LMatrix4f const &m);
inline LVector3f operator *(LVector3f const &v, LMatrix4f const &m);
inline LPoint3f operator *(LPoint3f const &v, LMatrix4f const &m);
inline LVecBase3d operator *(LVecBase3d const &v, LMatrix3d const &m);
inline LVector3d operator *(LVector3d const &v, LMatrix3d const &m);
inline LPoint3d operator *(LPoint3d const &v, LMatrix3d const &m);
inline LVector2d operator *(LVector2d const &v, LMatrix3d const &m);
inline LPoint2d operator *(LPoint2d const &v, LMatrix3d const &m);
inline LVecBase4d operator *(LVecBase4d const &v, LMatrix4d const &m);
inline LPoint4d operator *(LPoint4d const &v, LMatrix4d const &m);
inline LVector4d operator *(LVector4d const &v, LMatrix4d const &m);
inline LVector3d operator *(LVector3d const &v, LMatrix4d const &m);
inline LPoint3d operator *(LPoint3d const &v, LMatrix4d const &m);
inline LMatrix3f operator *(LMatrix3f const &m, LQuaternionf const &q);
inline LMatrix4f operator *(LMatrix4f const &m, LQuaternionf const &q);
inline LMatrix3d operator *(LMatrix3d const &m, LQuaterniond const &q);
inline LMatrix4d operator *(LMatrix4d const &m, LQuaterniond const &q);

3384 11 operator *= 0 1 0 11 operator *= 0 16 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 0
941
inline void operator *=(LVecBase3f &v, LMatrix3f const &m);
inline void operator *=(LVector3f &v, LMatrix3f const &m);
inline void operator *=(LPoint3f &v, LMatrix3f const &m);
inline void operator *=(LVector2f &v, LMatrix3f const &m);
inline void operator *=(LPoint2f &v, LMatrix3f const &m);
inline void operator *=(LVecBase4f &v, LMatrix4f const &m);
inline void operator *=(LVector3f &v, LMatrix4f const &m);
inline void operator *=(LPoint3f &v, LMatrix4f const &m);
inline void operator *=(LVecBase3d &v, LMatrix3d const &m);
inline void operator *=(LVector3d &v, LMatrix3d const &m);
inline void operator *=(LPoint3d &v, LMatrix3d const &m);
inline void operator *=(LVector2d &v, LMatrix3d const &m);
inline void operator *=(LPoint2d &v, LMatrix3d const &m);
inline void operator *=(LVecBase4d &v, LMatrix4d const &m);
inline void operator *=(LVector3d &v, LMatrix4d const &m);
inline void operator *=(LPoint3d &v, LMatrix4d const &m);

3385 22 generic_write_datagram 0 1 0 22 generic_write_datagram 0 4 1934 1935 1936 1937 0
303
inline void generic_write_datagram(Datagram &dest, LMatrix3f const &value);
inline void generic_write_datagram(Datagram &dest, LMatrix4f const &value);
inline void generic_write_datagram(Datagram &dest, LMatrix3d const &value);
inline void generic_write_datagram(Datagram &dest, LMatrix4d const &value);

3386 21 generic_read_datagram 0 1 0 21 generic_read_datagram 0 4 1938 1939 1940 1941 0
319
inline void generic_read_datagram(LMatrix3f &result, DatagramIterator &source);
inline void generic_read_datagram(LMatrix4f &result, DatagramIterator &source);
inline void generic_read_datagram(LMatrix3d &result, DatagramIterator &source);
inline void generic_read_datagram(LMatrix4d &result, DatagramIterator &source);

3387 14 compose_matrix 0 1 0 14 compose_matrix 0 10 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 0
1484
void compose_matrix(LMatrix3f &mat, LVecBase3f const &scale, LVecBase3f const &shear, LVecBase3f const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4f &mat, LVecBase3f const &scale, LVecBase3f const &shear, LVecBase3f const &hpr, LVecBase3f const &translate, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4f &mat, float const components[::num_matrix_components], CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix3f &mat, LVecBase3f const &scale, LVecBase3f const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4f &mat, LVecBase3f const &scale, LVecBase3f const &hpr, LVecBase3f const &translate, CoordinateSystem cs = ::CS_default);
void compose_matrix(LMatrix3d &mat, LVecBase3d const &scale, LVecBase3d const &shear, LVecBase3d const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4d &mat, LVecBase3d const &scale, LVecBase3d const &shear, LVecBase3d const &hpr, LVecBase3d const &translate, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4d &mat, double const components[::num_matrix_components], CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix3d &mat, LVecBase3d const &scale, LVecBase3d const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4d &mat, LVecBase3d const &scale, LVecBase3d const &hpr, LVecBase3d const &translate, CoordinateSystem cs = ::CS_default);

3388 16 decompose_matrix 0 1 0 16 decompose_matrix 0 10 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 0
1408
bool decompose_matrix(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, LVecBase3f &translate, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4f const &mat, float components[::num_matrix_components], CoordinateSystem CS = ::CS_default);
inline bool decompose_matrix(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4f const &mat, LVecBase3f &scale, LVecBase3f &hpr, LVecBase3f &translate, CoordinateSystem cs = ::CS_default);
bool decompose_matrix(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, LVecBase3d &translate, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4d const &mat, double components[::num_matrix_components], CoordinateSystem CS = ::CS_default);
inline bool decompose_matrix(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4d const &mat, LVecBase3d &scale, LVecBase3d &hpr, LVecBase3d &translate, CoordinateSystem cs = ::CS_default);

3389 24 decompose_matrix_old_hpr 0 1 0 24 decompose_matrix_old_hpr 0 2 1962 1963 0
287
bool decompose_matrix_old_hpr(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, CoordinateSystem cs = ::CS_default);
bool decompose_matrix_old_hpr(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, CoordinateSystem cs = ::CS_default);

3390 14 old_to_new_hpr 0 1 0 14 old_to_new_hpr 0 2 1964 1965 0
107
LVecBase3f old_to_new_hpr(LVecBase3f const &old_hpr);
LVecBase3d old_to_new_hpr(LVecBase3d const &old_hpr);

3391 12 LQuaternionf 0 4 3582 26 LQuaternionf::LQuaternionf 0 5 1700 1701 1702 1703 1704 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
305
inline LQuaternionf::LQuaternionf(void);
inline LQuaternionf::LQuaternionf(LVecBase4f const &copy);
inline LQuaternionf::LQuaternionf(float r, LVecBase3f const &copy);
inline LQuaternionf::LQuaternionf(float r, float i, float j, float k);
inline LQuaternionf::LQuaternionf(LQuaternionf const &) = default;

3392 14 pure_imaginary 0 4 3582 28 LQuaternionf::pure_imaginary 0 1 1705 10
/**
 *
 */
69
static LQuaternionf LQuaternionf::pure_imaginary(LVector3f const &v);

3393 9 conjugate 0 4 3582 23 LQuaternionf::conjugate 0 1 1706 54
/**
 * Returns the complex conjugate of this quat.
 */
56
inline LQuaternionf LQuaternionf::conjugate(void) const;

3394 5 xform 0 4 3582 19 LQuaternionf::xform 0 2 1707 1708 122
/**
 * Transforms a 3-d vector by the indicated rotation
 */

/**
 * Transforms a 4-d vector by the indicated rotation
 */
131
inline LVecBase3f LQuaternionf::xform(LVecBase3f const &v) const;
inline LVecBase4f LQuaternionf::xform(LVecBase4f const &v) const;

3395 8 multiply 0 4 3582 22 LQuaternionf::multiply 0 1 1709 45
/**
 * actual multiply call (non virtual)
 */
74
inline LQuaternionf LQuaternionf::multiply(LQuaternionf const &rhs) const;

3396 10 operator - 0 68 3582 24 LQuaternionf::operator - 0 1 1710 0
57
inline LQuaternionf LQuaternionf::operator -(void) const;

3397 10 operator + 0 4 3582 24 LQuaternionf::operator + 0 1 1711 0
78
inline LQuaternionf LQuaternionf::operator +(LQuaternionf const &other) const;

3398 10 operator - 0 4 3582 24 LQuaternionf::operator - 0 1 1712 0
78
inline LQuaternionf LQuaternionf::operator -(LQuaternionf const &other) const;

3399 9 angle_rad 0 4 3582 23 LQuaternionf::angle_rad 0 1 1713 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */
70
inline float LQuaternionf::angle_rad(LQuaternionf const &other) const;

3400 9 angle_deg 0 4 3582 23 LQuaternionf::angle_deg 0 1 1714 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */
70
inline float LQuaternionf::angle_deg(LQuaternionf const &other) const;

3401 10 operator * 0 4 3582 24 LQuaternionf::operator * 0 4 1715 1716 1717 1718 0
263
inline LQuaternionf LQuaternionf::operator *(float scalar) const;
inline LQuaternionf LQuaternionf::operator *(LQuaternionf const &) const;
inline LMatrix3f LQuaternionf::operator *(LMatrix3f const &);
inline LMatrix4f LQuaternionf::operator *(LMatrix4f const &);

3402 10 operator / 0 4 3582 24 LQuaternionf::operator / 0 1 1719 0
65
inline LQuaternionf LQuaternionf::operator /(float scalar) const;

3403 11 operator *= 0 4 3582 25 LQuaternionf::operator *= 0 1 1720 10
/**
 *
 */
69
inline LQuaternionf &LQuaternionf::operator *=(LQuaternionf const &);

3404 7 __pow__ 0 4 3582 21 LQuaternionf::__pow__ 0 1 1721 97
/**
 * Returns a new quaternion that represents this quaternion raised to the
 * given power.
 */
49
LQuaternionf LQuaternionf::__pow__(float ) const;

3405 12 almost_equal 0 4 3582 26 LQuaternionf::almost_equal 0 2 1722 1723 218
/**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */
162
inline bool LQuaternionf::almost_equal(LQuaternionf const &other) const;
inline bool LQuaternionf::almost_equal(LQuaternionf const &other, float threshold) const;

3406 17 is_same_direction 0 4 3582 31 LQuaternionf::is_same_direction 0 1 1724 127
/**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */
77
inline bool LQuaternionf::is_same_direction(LQuaternionf const &other) const;

3407 21 almost_same_direction 0 4 3582 35 LQuaternionf::almost_same_direction 0 1 1725 103
/**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */
98
inline bool LQuaternionf::almost_same_direction(LQuaternionf const &other, float threshold) const;

3408 6 output 0 4 3582 20 LQuaternionf::output 0 1 1726 10
/**
 *
 */
55
inline void LQuaternionf::output(std::ostream &) const;

3409 17 extract_to_matrix 0 4 3582 31 LQuaternionf::extract_to_matrix 0 2 1727 1728 88
/**
 * Based on the quat lib from VRPN.
 */

/**
 * Based on the quat lib from VRPN.
 */
115
void LQuaternionf::extract_to_matrix(LMatrix3f &m) const;
void LQuaternionf::extract_to_matrix(LMatrix4f &m) const;

3410 15 set_from_matrix 0 4 3582 29 LQuaternionf::set_from_matrix 0 2 1729 1730 238
/**
 *
 */

/**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */
118
void LQuaternionf::set_from_matrix(LMatrix3f const &m);
inline void LQuaternionf::set_from_matrix(LMatrix4f const &m);

3411 7 set_hpr 0 4 3582 21 LQuaternionf::set_hpr 0 1 1731 132
/**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */
86
void LQuaternionf::set_hpr(LVecBase3f const &hpr, CoordinateSystem cs = ::CS_default);

3412 7 get_hpr 0 4 3582 21 LQuaternionf::get_hpr 0 1 1732 73
/**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */
75
LVecBase3f LQuaternionf::get_hpr(CoordinateSystem cs = ::CS_default) const;

3413 8 get_axis 0 4 3582 22 LQuaternionf::get_axis 0 1 1733 180
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */
52
inline LVector3f LQuaternionf::get_axis(void) const;

3414 19 get_axis_normalized 0 4 3582 33 LQuaternionf::get_axis_normalized 0 1 1734 169
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */
63
inline LVector3f LQuaternionf::get_axis_normalized(void) const;

3415 13 get_angle_rad 0 4 3582 27 LQuaternionf::get_angle_rad 0 1 1735 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
53
inline float LQuaternionf::get_angle_rad(void) const;

3416 9 get_angle 0 4 3582 23 LQuaternionf::get_angle 0 1 1736 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
49
inline float LQuaternionf::get_angle(void) const;

3417 23 set_from_axis_angle_rad 0 4 3582 37 LQuaternionf::set_from_axis_angle_rad 0 1 1737 86
/**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */
90
inline void LQuaternionf::set_from_axis_angle_rad(float angle_rad, LVector3f const &axis);

3418 19 set_from_axis_angle 0 4 3582 33 LQuaternionf::set_from_axis_angle 0 1 1738 86
/**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */
86
inline void LQuaternionf::set_from_axis_angle(float angle_deg, LVector3f const &axis);

3419 6 get_up 0 4 3582 20 LQuaternionf::get_up 0 1 1739 96
/**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */
80
inline LVector3f LQuaternionf::get_up(CoordinateSystem cs = ::CS_default) const;

3420 9 get_right 0 4 3582 23 LQuaternionf::get_right 0 1 1740 98
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */
83
inline LVector3f LQuaternionf::get_right(CoordinateSystem cs = ::CS_default) const;

3421 11 get_forward 0 4 3582 25 LQuaternionf::get_forward 0 1 1741 100
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */
85
inline LVector3f LQuaternionf::get_forward(CoordinateSystem cs = ::CS_default) const;

3422 5 get_r 0 4 3582 19 LQuaternionf::get_r 0 1 1742 10
/**
 *
 */
45
inline float LQuaternionf::get_r(void) const;

3423 5 get_i 0 4 3582 19 LQuaternionf::get_i 0 1 1743 10
/**
 *
 */
45
inline float LQuaternionf::get_i(void) const;

3424 5 get_j 0 4 3582 19 LQuaternionf::get_j 0 1 1744 10
/**
 *
 */
45
inline float LQuaternionf::get_j(void) const;

3425 5 get_k 0 4 3582 19 LQuaternionf::get_k 0 1 1745 10
/**
 *
 */
45
inline float LQuaternionf::get_k(void) const;

3426 5 set_r 0 4 3582 19 LQuaternionf::set_r 0 1 1746 10
/**
 *
 */
41
inline void LQuaternionf::set_r(float r);

3427 5 set_i 0 4 3582 19 LQuaternionf::set_i 0 1 1747 10
/**
 *
 */
41
inline void LQuaternionf::set_i(float i);

3428 5 set_j 0 4 3582 19 LQuaternionf::set_j 0 1 1748 10
/**
 *
 */
41
inline void LQuaternionf::set_j(float j);

3429 5 set_k 0 4 3582 19 LQuaternionf::set_k 0 1 1749 10
/**
 *
 */
41
inline void LQuaternionf::set_k(float k);

3430 9 normalize 0 4 3582 23 LQuaternionf::normalize 0 1 1750 10
/**
 *
 */
42
inline bool LQuaternionf::normalize(void);

3431 14 conjugate_from 0 4 3582 28 LQuaternionf::conjugate_from 0 1 1751 466
/**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
68
inline bool LQuaternionf::conjugate_from(LQuaternionf const &other);

3432 18 conjugate_in_place 0 4 3582 32 LQuaternionf::conjugate_in_place 0 1 1752 129
/**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */
51
inline bool LQuaternionf::conjugate_in_place(void);

3433 11 invert_from 0 4 3582 25 LQuaternionf::invert_from 0 1 1753 448
/**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
65
inline bool LQuaternionf::invert_from(LQuaternionf const &other);

3434 15 invert_in_place 0 4 3582 29 LQuaternionf::invert_in_place 0 1 1754 115
/**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */
48
inline bool LQuaternionf::invert_in_place(void);

3435 11 is_identity 0 4 3582 25 LQuaternionf::is_identity 0 1 1755 98
/**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */
50
inline bool LQuaternionf::is_identity(void) const;

3436 18 is_almost_identity 0 4 3582 32 LQuaternionf::is_almost_identity 0 1 1756 110
/**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */
68
inline bool LQuaternionf::is_almost_identity(float tolerance) const;

3437 10 ident_quat 0 4 3582 24 LQuaternionf::ident_quat 0 1 1757 42
/**
 * Returns an identity quaternion.
 */
65
static inline LQuaternionf const &LQuaternionf::ident_quat(void);

3438 14 get_class_type 0 4 3582 28 LQuaternionf::get_class_type 0 1 1758 0
53
static TypeHandle LQuaternionf::get_class_type(void);

3439 13 ~LQuaternionf 0 4 3582 27 LQuaternionf::~LQuaternionf 0 0 0
34
LQuaternionf::~LQuaternionf(void);

3440 12 LQuaterniond 0 4 3583 26 LQuaterniond::LQuaterniond 0 5 1759 1760 1761 1762 1763 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
310
inline LQuaterniond::LQuaterniond(void);
inline LQuaterniond::LQuaterniond(LVecBase4d const &copy);
inline LQuaterniond::LQuaterniond(double r, LVecBase3d const &copy);
inline LQuaterniond::LQuaterniond(double r, double i, double j, double k);
inline LQuaterniond::LQuaterniond(LQuaterniond const &) = default;

3441 14 pure_imaginary 0 4 3583 28 LQuaterniond::pure_imaginary 0 1 1764 10
/**
 *
 */
69
static LQuaterniond LQuaterniond::pure_imaginary(LVector3d const &v);

3442 9 conjugate 0 4 3583 23 LQuaterniond::conjugate 0 1 1765 54
/**
 * Returns the complex conjugate of this quat.
 */
56
inline LQuaterniond LQuaterniond::conjugate(void) const;

3443 5 xform 0 4 3583 19 LQuaterniond::xform 0 2 1766 1767 122
/**
 * Transforms a 3-d vector by the indicated rotation
 */

/**
 * Transforms a 4-d vector by the indicated rotation
 */
131
inline LVecBase3d LQuaterniond::xform(LVecBase3d const &v) const;
inline LVecBase4d LQuaterniond::xform(LVecBase4d const &v) const;

3444 8 multiply 0 4 3583 22 LQuaterniond::multiply 0 1 1768 45
/**
 * actual multiply call (non virtual)
 */
74
inline LQuaterniond LQuaterniond::multiply(LQuaterniond const &rhs) const;

3445 10 operator - 0 68 3583 24 LQuaterniond::operator - 0 1 1769 0
57
inline LQuaterniond LQuaterniond::operator -(void) const;

3446 10 operator + 0 4 3583 24 LQuaterniond::operator + 0 1 1770 0
78
inline LQuaterniond LQuaterniond::operator +(LQuaterniond const &other) const;

3447 10 operator - 0 4 3583 24 LQuaterniond::operator - 0 1 1771 0
78
inline LQuaterniond LQuaterniond::operator -(LQuaterniond const &other) const;

3448 9 angle_rad 0 4 3583 23 LQuaterniond::angle_rad 0 1 1772 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */
71
inline double LQuaterniond::angle_rad(LQuaterniond const &other) const;

3449 9 angle_deg 0 4 3583 23 LQuaterniond::angle_deg 0 1 1773 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */
71
inline double LQuaterniond::angle_deg(LQuaterniond const &other) const;

3450 10 operator * 0 4 3583 24 LQuaterniond::operator * 0 4 1774 1775 1776 1777 0
264
inline LQuaterniond LQuaterniond::operator *(double scalar) const;
inline LQuaterniond LQuaterniond::operator *(LQuaterniond const &) const;
inline LMatrix3d LQuaterniond::operator *(LMatrix3d const &);
inline LMatrix4d LQuaterniond::operator *(LMatrix4d const &);

3451 10 operator / 0 4 3583 24 LQuaterniond::operator / 0 1 1778 0
66
inline LQuaterniond LQuaterniond::operator /(double scalar) const;

3452 11 operator *= 0 4 3583 25 LQuaterniond::operator *= 0 1 1779 10
/**
 *
 */
69
inline LQuaterniond &LQuaterniond::operator *=(LQuaterniond const &);

3453 7 __pow__ 0 4 3583 21 LQuaterniond::__pow__ 0 1 1780 97
/**
 * Returns a new quaternion that represents this quaternion raised to the
 * given power.
 */
50
LQuaterniond LQuaterniond::__pow__(double ) const;

3454 12 almost_equal 0 4 3583 26 LQuaterniond::almost_equal 0 2 1781 1782 218
/**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */
163
inline bool LQuaterniond::almost_equal(LQuaterniond const &other) const;
inline bool LQuaterniond::almost_equal(LQuaterniond const &other, double threshold) const;

3455 17 is_same_direction 0 4 3583 31 LQuaterniond::is_same_direction 0 1 1783 127
/**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */
77
inline bool LQuaterniond::is_same_direction(LQuaterniond const &other) const;

3456 21 almost_same_direction 0 4 3583 35 LQuaterniond::almost_same_direction 0 1 1784 103
/**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */
99
inline bool LQuaterniond::almost_same_direction(LQuaterniond const &other, double threshold) const;

3457 6 output 0 4 3583 20 LQuaterniond::output 0 1 1785 10
/**
 *
 */
55
inline void LQuaterniond::output(std::ostream &) const;

3458 17 extract_to_matrix 0 4 3583 31 LQuaterniond::extract_to_matrix 0 2 1786 1787 88
/**
 * Based on the quat lib from VRPN.
 */

/**
 * Based on the quat lib from VRPN.
 */
115
void LQuaterniond::extract_to_matrix(LMatrix3d &m) const;
void LQuaterniond::extract_to_matrix(LMatrix4d &m) const;

3459 15 set_from_matrix 0 4 3583 29 LQuaterniond::set_from_matrix 0 2 1788 1789 238
/**
 *
 */

/**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */
118
void LQuaterniond::set_from_matrix(LMatrix3d const &m);
inline void LQuaterniond::set_from_matrix(LMatrix4d const &m);

3460 7 set_hpr 0 4 3583 21 LQuaterniond::set_hpr 0 1 1790 132
/**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */
86
void LQuaterniond::set_hpr(LVecBase3d const &hpr, CoordinateSystem cs = ::CS_default);

3461 7 get_hpr 0 4 3583 21 LQuaterniond::get_hpr 0 1 1791 73
/**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */
75
LVecBase3d LQuaterniond::get_hpr(CoordinateSystem cs = ::CS_default) const;

3462 8 get_axis 0 4 3583 22 LQuaterniond::get_axis 0 1 1792 180
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */
52
inline LVector3d LQuaterniond::get_axis(void) const;

3463 19 get_axis_normalized 0 4 3583 33 LQuaterniond::get_axis_normalized 0 1 1793 169
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */
63
inline LVector3d LQuaterniond::get_axis_normalized(void) const;

3464 13 get_angle_rad 0 4 3583 27 LQuaterniond::get_angle_rad 0 1 1794 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
54
inline double LQuaterniond::get_angle_rad(void) const;

3465 9 get_angle 0 4 3583 23 LQuaterniond::get_angle 0 1 1795 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
50
inline double LQuaterniond::get_angle(void) const;

3466 23 set_from_axis_angle_rad 0 4 3583 37 LQuaterniond::set_from_axis_angle_rad 0 1 1796 86
/**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */
91
inline void LQuaterniond::set_from_axis_angle_rad(double angle_rad, LVector3d const &axis);

3467 19 set_from_axis_angle 0 4 3583 33 LQuaterniond::set_from_axis_angle 0 1 1797 86
/**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */
87
inline void LQuaterniond::set_from_axis_angle(double angle_deg, LVector3d const &axis);

3468 6 get_up 0 4 3583 20 LQuaterniond::get_up 0 1 1798 96
/**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */
80
inline LVector3d LQuaterniond::get_up(CoordinateSystem cs = ::CS_default) const;

3469 9 get_right 0 4 3583 23 LQuaterniond::get_right 0 1 1799 98
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */
83
inline LVector3d LQuaterniond::get_right(CoordinateSystem cs = ::CS_default) const;

3470 11 get_forward 0 4 3583 25 LQuaterniond::get_forward 0 1 1800 100
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */
85
inline LVector3d LQuaterniond::get_forward(CoordinateSystem cs = ::CS_default) const;

3471 5 get_r 0 4 3583 19 LQuaterniond::get_r 0 1 1801 10
/**
 *
 */
46
inline double LQuaterniond::get_r(void) const;

3472 5 get_i 0 4 3583 19 LQuaterniond::get_i 0 1 1802 10
/**
 *
 */
46
inline double LQuaterniond::get_i(void) const;

3473 5 get_j 0 4 3583 19 LQuaterniond::get_j 0 1 1803 10
/**
 *
 */
46
inline double LQuaterniond::get_j(void) const;

3474 5 get_k 0 4 3583 19 LQuaterniond::get_k 0 1 1804 10
/**
 *
 */
46
inline double LQuaterniond::get_k(void) const;

3475 5 set_r 0 4 3583 19 LQuaterniond::set_r 0 1 1805 10
/**
 *
 */
42
inline void LQuaterniond::set_r(double r);

3476 5 set_i 0 4 3583 19 LQuaterniond::set_i 0 1 1806 10
/**
 *
 */
42
inline void LQuaterniond::set_i(double i);

3477 5 set_j 0 4 3583 19 LQuaterniond::set_j 0 1 1807 10
/**
 *
 */
42
inline void LQuaterniond::set_j(double j);

3478 5 set_k 0 4 3583 19 LQuaterniond::set_k 0 1 1808 10
/**
 *
 */
42
inline void LQuaterniond::set_k(double k);

3479 9 normalize 0 4 3583 23 LQuaterniond::normalize 0 1 1809 10
/**
 *
 */
42
inline bool LQuaterniond::normalize(void);

3480 14 conjugate_from 0 4 3583 28 LQuaterniond::conjugate_from 0 1 1810 466
/**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
68
inline bool LQuaterniond::conjugate_from(LQuaterniond const &other);

3481 18 conjugate_in_place 0 4 3583 32 LQuaterniond::conjugate_in_place 0 1 1811 129
/**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */
51
inline bool LQuaterniond::conjugate_in_place(void);

3482 11 invert_from 0 4 3583 25 LQuaterniond::invert_from 0 1 1812 448
/**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
65
inline bool LQuaterniond::invert_from(LQuaterniond const &other);

3483 15 invert_in_place 0 4 3583 29 LQuaterniond::invert_in_place 0 1 1813 115
/**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */
48
inline bool LQuaterniond::invert_in_place(void);

3484 11 is_identity 0 4 3583 25 LQuaterniond::is_identity 0 1 1814 98
/**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */
50
inline bool LQuaterniond::is_identity(void) const;

3485 18 is_almost_identity 0 4 3583 32 LQuaterniond::is_almost_identity 0 1 1815 110
/**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */
69
inline bool LQuaterniond::is_almost_identity(double tolerance) const;

3486 10 ident_quat 0 4 3583 24 LQuaterniond::ident_quat 0 1 1816 42
/**
 * Returns an identity quaternion.
 */
65
static inline LQuaterniond const &LQuaterniond::ident_quat(void);

3487 14 get_class_type 0 4 3583 28 LQuaterniond::get_class_type 0 1 1817 0
53
static TypeHandle LQuaterniond::get_class_type(void);

3488 13 ~LQuaterniond 0 4 3583 27 LQuaterniond::~LQuaterniond 0 0 0
34
LQuaterniond::~LQuaterniond(void);

3489 10 LRotationf 0 4 3584 22 LRotationf::LRotationf 0 9 1818 1819 1820 1821 1822 1823 1824 1825 1826 185
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * lmatrix3
 */

/**
 * lmatrix4
 */

/**
 * axis + angle (in degrees)
 */

/**
 * Sets the rotation from the given Euler angles.
 */
500
inline LRotationf::LRotationf(void);
inline LRotationf::LRotationf(LQuaternionf const &c);
inline LRotationf::LRotationf(LVecBase4f const &copy);
inline LRotationf::LRotationf(float r, float i, float j, float k);
inline LRotationf::LRotationf(LVector3f const &axis, float angle);
inline LRotationf::LRotationf(LMatrix3f const &m);
inline LRotationf::LRotationf(LMatrix4f const &m);
inline LRotationf::LRotationf(float h, float p, float r);
inline LRotationf::LRotationf(LRotationf const &) = default;

3490 10 operator * 0 4 3584 22 LRotationf::operator * 0 3 1827 1828 1829 0
211
inline LRotationf LRotationf::operator *(float scalar) const;
inline LRotationf LRotationf::operator *(LRotationf const &other) const;
inline LQuaternionf LRotationf::operator *(LQuaternionf const &other) const;

3491 10 operator / 0 4 3584 22 LRotationf::operator / 0 1 1830 0
61
inline LRotationf LRotationf::operator /(float scalar) const;

3492 14 get_class_type 0 4 3584 26 LRotationf::get_class_type 0 1 1831 0
51
static TypeHandle LRotationf::get_class_type(void);

3493 11 ~LRotationf 0 4 3584 23 LRotationf::~LRotationf 0 0 0
30
LRotationf::~LRotationf(void);

3494 10 LRotationd 0 4 3585 22 LRotationd::LRotationd 0 9 1832 1833 1834 1835 1836 1837 1838 1839 1840 185
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * lmatrix3
 */

/**
 * lmatrix4
 */

/**
 * axis + angle (in degrees)
 */

/**
 * Sets the rotation from the given Euler angles.
 */
508
inline LRotationd::LRotationd(void);
inline LRotationd::LRotationd(LQuaterniond const &c);
inline LRotationd::LRotationd(LVecBase4d const &copy);
inline LRotationd::LRotationd(double r, double i, double j, double k);
inline LRotationd::LRotationd(LVector3d const &axis, double angle);
inline LRotationd::LRotationd(LMatrix3d const &m);
inline LRotationd::LRotationd(LMatrix4d const &m);
inline LRotationd::LRotationd(double h, double p, double r);
inline LRotationd::LRotationd(LRotationd const &) = default;

3495 10 operator * 0 4 3585 22 LRotationd::operator * 0 3 1841 1842 1843 0
212
inline LRotationd LRotationd::operator *(double scalar) const;
inline LRotationd LRotationd::operator *(LRotationd const &other) const;
inline LQuaterniond LRotationd::operator *(LQuaterniond const &other) const;

3496 10 operator / 0 4 3585 22 LRotationd::operator / 0 1 1844 0
62
inline LRotationd LRotationd::operator /(double scalar) const;

3497 14 get_class_type 0 4 3585 26 LRotationd::get_class_type 0 1 1845 0
51
static TypeHandle LRotationd::get_class_type(void);

3498 11 ~LRotationd 0 4 3585 23 LRotationd::~LRotationd 0 0 0
30
LRotationd::~LRotationd(void);

3499 13 LOrientationf 0 4 3586 28 LOrientationf::LOrientationf 0 7 1846 1847 1848 1849 1850 1851 1852 101
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * vector + twist
 */

/**
 * matrix3
 */

/**
 * matrix4
 */
436
inline LOrientationf::LOrientationf(void);
inline LOrientationf::LOrientationf(LQuaternionf const &c);
inline LOrientationf::LOrientationf(float r, float i, float j, float k);
inline LOrientationf::LOrientationf(LVector3f const &point_at, float twist);
inline LOrientationf::LOrientationf(LMatrix3f const &m);
inline LOrientationf::LOrientationf(LMatrix4f const &m);
inline LOrientationf::LOrientationf(LOrientationf const &) = default;

3500 10 operator * 0 4 3586 25 LOrientationf::operator * 0 2 1853 1854 0
159
inline LOrientationf LOrientationf::operator *(LRotationf const &other) const;
inline LOrientationf LOrientationf::operator *(LQuaternionf const &other) const;

3501 14 get_class_type 0 4 3586 29 LOrientationf::get_class_type 0 1 1855 0
54
static TypeHandle LOrientationf::get_class_type(void);

3502 14 ~LOrientationf 0 4 3586 29 LOrientationf::~LOrientationf 0 0 0
36
LOrientationf::~LOrientationf(void);

3503 13 LOrientationd 0 4 3587 28 LOrientationd::LOrientationd 0 7 1856 1857 1858 1859 1860 1861 1862 101
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * vector + twist
 */

/**
 * matrix3
 */

/**
 * matrix4
 */
441
inline LOrientationd::LOrientationd(void);
inline LOrientationd::LOrientationd(LQuaterniond const &c);
inline LOrientationd::LOrientationd(double r, double i, double j, double k);
inline LOrientationd::LOrientationd(LVector3d const &point_at, double twist);
inline LOrientationd::LOrientationd(LMatrix3d const &m);
inline LOrientationd::LOrientationd(LMatrix4d const &m);
inline LOrientationd::LOrientationd(LOrientationd const &) = default;

3504 10 operator * 0 4 3587 25 LOrientationd::operator * 0 2 1863 1864 0
159
inline LOrientationd LOrientationd::operator *(LRotationd const &other) const;
inline LOrientationd LOrientationd::operator *(LQuaterniond const &other) const;

3505 14 get_class_type 0 4 3587 29 LOrientationd::get_class_type 0 1 1865 0
54
static TypeHandle LOrientationd::get_class_type(void);

3506 14 ~LOrientationd 0 4 3587 29 LOrientationd::~LOrientationd 0 0 0
36
LOrientationd::~LOrientationd(void);

3507 19 ConfigVariableColor 0 4 3658 40 ConfigVariableColor::ConfigVariableColor 0 4 1866 1867 1868 1869 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
488
inline ConfigVariableColor::ConfigVariableColor(std::string const &name);
inline ConfigVariableColor::ConfigVariableColor(std::string const &name, LColor const &default_value, std::string const &description = string(), int flags = 0);
inline ConfigVariableColor::ConfigVariableColor(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0);
inline ConfigVariableColor::ConfigVariableColor(ConfigVariableColor const &) = default;

3508 10 operator = 0 4 3658 31 ConfigVariableColor::operator = 0 1 1870 0
65
inline void ConfigVariableColor::operator =(LColor const &value);

3509 17 operator typecast 0 132 3658 38 ConfigVariableColor::operator typecast 0 1 1875 0
43
inline operator LColor const &(void) const;

3510 11 operator [] 0 4 3658 32 ConfigVariableColor::operator [] 0 1 1871 0
65
inline PN_stdfloat ConfigVariableColor::operator [](int n) const;

3511 9 set_value 0 4 3658 30 ConfigVariableColor::set_value 0 1 1872 48
/**
 * Reassigns the variable's local value.
 */
64
inline void ConfigVariableColor::set_value(LColor const &value);

3512 9 get_value 0 4 3658 30 ConfigVariableColor::get_value 0 1 1873 40
/**
 * Returns the variable's value.
 */
64
inline LColor const &ConfigVariableColor::get_value(void) const;

3513 17 get_default_value 0 4 3658 38 ConfigVariableColor::get_default_value 0 1 1874 48
/**
 * Returns the variable's default value.
 */
65
inline LColor ConfigVariableColor::get_default_value(void) const;

3514 20 ~ConfigVariableColor 0 4 3658 41 ConfigVariableColor::~ConfigVariableColor 0 0 0
48
ConfigVariableColor::~ConfigVariableColor(void);

1965
1 0 0 7 2 3660 1967 0 0 0 
2 0 0 7 2 3660 1967 0 0 1 6 param0 0 3661  
3 0 0 7 8 3663 2032 0 0 0 
4 0 0 7 8 3663 2032 0 0 1 6 param0 0 3664  
5 0 0 7 8 3663 2032 0 10 /**
 *
 */ 1 10 fill_value 1 3518  
6 0 0 7 8 3663 2032 0 10 /**
 *
 */ 2 1 x 1 3518  1 y 1 3518  
7 0 0 4 9 3668 0 0 0 2 4 this 3 3663  4 size 1 3666  
8 0 0 6 12 3663 0 0 0 2 4 this 3 3663  4 copy 1 3664  
9 0 0 6 12 3663 0 0 0 2 4 this 3 3663  10 fill_value 1 3518  
10 0 0 6 13 3664 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
11 0 0 6 14 3664 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
12 0 0 6 15 3664 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
13 0 0 6 16 3669 0 0 0 1 4 this 3 3664  
14 0 0 6 17 3669 0 0 0 2 4 this 3 3664  9 attr_name 1 3672  
15 0 0 6 18 3524 0 0 0 3 4 this 3 3663  9 attr_name 1 3672  6 assign 1 3669  
16 0 0 4 19 3668 0 0 10 /**
 *
 */ 3 4 this 3 3663  1 i 1 3524  10 assign_val 1 3518  
17 0 0 6 19 3518 0 0 0 2 4 this 3 3664  1 i 1 3524  
18 0 0 6 20 3524 0 0 0 0 
19 0 0 6 21 3673 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3664  
20 0 0 6 22 3518 0 0 10 /**
 *
 */ 2 4 this 3 3664  1 i 1 3524  
21 0 0 4 23 3668 0 0 10 /**
 *
 */ 3 4 this 3 3663  1 i 1 3524  5 value 1 3518  
22 0 0 6 24 3518 0 0 10 /**
 *
 */ 1 4 this 3 3664  
23 0 0 6 25 3518 0 0 10 /**
 *
 */ 1 4 this 3 3664  
24 0 0 4 26 3668 0 0 10 /**
 *
 */ 2 4 this 3 3663  5 value 1 3518  
25 0 0 4 27 3668 0 0 10 /**
 *
 */ 2 4 this 3 3663  5 value 1 3518  
26 0 0 4 31 3668 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3663  1 i 1 3524  5 value 1 3518  
27 0 0 4 32 3668 0 0 10 /**
 *
 */ 2 4 this 3 3663  5 value 1 3518  
28 0 0 4 33 3668 0 0 10 /**
 *
 */ 2 4 this 3 3663  5 value 1 3518  
29 0 0 4 34 3668 0 0 155 /**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */ 1 4 this 3 3664  
30 0 0 6 35 3524 0 0 0 0 
31 0 0 4 36 3668 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3663  10 fill_value 1 3518  
32 0 0 4 37 3668 0 0 10 /**
 *
 */ 3 4 this 3 3663  1 x 1 3518  1 y 1 3518  
33 0 0 6 38 3518 0 0 10 /**
 *
 */ 2 4 this 3 3664  5 other 1 3664  
34 0 0 6 39 3518 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3664  
35 0 0 6 40 3518 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3664  
36 0 0 6 41 3673 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3663  
37 0 0 7 42 3663 2032 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3664  
38 0 0 7 43 3663 2032 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3664  4 onto 1 3664  
39 0 0 6 44 3673 0 0 0 2 4 this 3 3664  5 other 1 3664  
40 0 0 6 45 3673 0 0 0 2 4 this 3 3664  5 other 1 3664  
41 0 0 6 46 3673 0 0 0 2 4 this 3 3664  5 other 1 3664  
42 0 0 6 47 3524 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3664  5 other 1 3664  
43 0 0 6 47 3524 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3664  5 other 1 3664  9 threshold 1 3518  
44 0 0 6 48 3666 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3664  
45 0 0 6 48 3666 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3664  9 threshold 1 3518  
46 0 0 6 49 3666 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3664  4 hash 1 3666  
47 0 0 6 49 3666 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3664  4 hash 1 3666  9 threshold 1 3518  
48 0 0 4 50 3668 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3664  7 hashgen 1 3674  
49 0 0 4 50 3668 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3664  7 hashgen 1 3674  9 threshold 1 3518  
50 0 0 7 51 3663 2032 0 0 1 4 this 3 3664  
51 0 0 7 52 3663 2032 0 0 2 4 this 3 3664  5 other 1 3664  
52 0 0 7 53 3663 2032 0 0 2 4 this 3 3664  5 other 1 3664  
53 0 0 7 54 3663 2032 0 0 2 4 this 3 3664  6 scalar 1 3518  
54 0 0 7 55 3663 2032 0 0 2 4 this 3 3664  6 scalar 1 3518  
55 0 0 6 56 3663 0 0 0 2 4 this 3 3663  5 other 1 3664  
56 0 0 6 57 3663 0 0 0 2 4 this 3 3663  5 other 1 3664  
57 0 0 6 58 3663 0 0 0 2 4 this 3 3663  6 scalar 1 3518  
58 0 0 6 59 3663 0 0 0 2 4 this 3 3663  6 scalar 1 3518  
59 0 0 4 60 3668 0 0 10 /**
 *
 */ 2 4 this 3 3663  5 other 1 3664  
60 0 0 7 61 3663 2032 0 0 2 4 this 3 3664  8 exponent 1 3518  
61 0 0 6 62 3669 0 0 0 2 4 this 3 3663  8 exponent 1 3518  
62 0 0 7 63 3663 2032 0 10 /**
 *
 */ 2 4 this 3 3664  5 other 1 3664  
63 0 0 7 64 3663 2032 0 10 /**
 *
 */ 2 4 this 3 3664  5 other 1 3664  
64 0 0 6 65 3673 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3664  5 other 1 3664  
65 0 0 6 65 3673 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3664  5 other 1 3664  9 threshold 1 3518  
66 0 0 4 66 3668 0 0 10 /**
 *
 */ 2 4 this 3 3664  3 out 1 3676  
67 0 0 6 67 3672 0 0 0 1 4 this 3 3664  
68 0 0 4 68 3668 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3664  11 destination 1 3678  
69 0 0 4 69 3668 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3663  6 source 1 3680  
70 0 0 4 70 3668 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3664  11 destination 1 3678  
71 0 0 4 71 3668 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3663  6 source 1 3680  
72 0 0 7 72 3683 0 0 0 0 
73 0 0 7 76 3684 2095 0 0 0 
74 0 0 7 76 3684 2095 0 0 1 6 param0 0 3685  
75 0 0 7 76 3684 2095 0 10 /**
 *
 */ 1 10 fill_value 1 3521  
76 0 0 7 76 3684 2095 0 10 /**
 *
 */ 2 1 x 1 3521  1 y 1 3521  
77 0 0 4 77 3668 0 0 0 2 4 this 3 3684  4 size 1 3666  
78 0 0 6 80 3684 0 0 0 2 4 this 3 3684  4 copy 1 3685  
79 0 0 6 80 3684 0 0 0 2 4 this 3 3684  10 fill_value 1 3521  
80 0 0 6 81 3685 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
81 0 0 6 82 3685 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
82 0 0 6 83 3685 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
83 0 0 6 84 3669 0 0 0 1 4 this 3 3685  
84 0 0 6 85 3669 0 0 0 2 4 this 3 3685  9 attr_name 1 3672  
85 0 0 6 86 3524 0 0 0 3 4 this 3 3684  9 attr_name 1 3672  6 assign 1 3669  
86 0 0 4 87 3668 0 0 10 /**
 *
 */ 3 4 this 3 3684  1 i 1 3524  10 assign_val 1 3521  
87 0 0 6 87 3521 0 0 0 2 4 this 3 3685  1 i 1 3524  
88 0 0 6 88 3524 0 0 0 0 
89 0 0 6 89 3673 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3685  
90 0 0 6 90 3521 0 0 10 /**
 *
 */ 2 4 this 3 3685  1 i 1 3524  
91 0 0 4 91 3668 0 0 10 /**
 *
 */ 3 4 this 3 3684  1 i 1 3524  5 value 1 3521  
92 0 0 6 92 3521 0 0 10 /**
 *
 */ 1 4 this 3 3685  
93 0 0 6 93 3521 0 0 10 /**
 *
 */ 1 4 this 3 3685  
94 0 0 4 94 3668 0 0 10 /**
 *
 */ 2 4 this 3 3684  5 value 1 3521  
95 0 0 4 95 3668 0 0 10 /**
 *
 */ 2 4 this 3 3684  5 value 1 3521  
96 0 0 4 99 3668 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3684  1 i 1 3524  5 value 1 3521  
97 0 0 4 100 3668 0 0 10 /**
 *
 */ 2 4 this 3 3684  5 value 1 3521  
98 0 0 4 101 3668 0 0 10 /**
 *
 */ 2 4 this 3 3684  5 value 1 3521  
99 0 0 4 102 3668 0 0 155 /**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */ 1 4 this 3 3685  
100 0 0 6 103 3524 0 0 0 0 
101 0 0 4 104 3668 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3684  10 fill_value 1 3521  
102 0 0 4 105 3668 0 0 10 /**
 *
 */ 3 4 this 3 3684  1 x 1 3521  1 y 1 3521  
103 0 0 6 106 3521 0 0 10 /**
 *
 */ 2 4 this 3 3685  5 other 1 3685  
104 0 0 6 107 3521 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3685  
105 0 0 6 108 3521 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3685  
106 0 0 6 109 3673 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3684  
107 0 0 7 110 3684 2095 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3685  
108 0 0 7 111 3684 2095 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3685  4 onto 1 3685  
109 0 0 6 112 3673 0 0 0 2 4 this 3 3685  5 other 1 3685  
110 0 0 6 113 3673 0 0 0 2 4 this 3 3685  5 other 1 3685  
111 0 0 6 114 3673 0 0 0 2 4 this 3 3685  5 other 1 3685  
112 0 0 6 115 3524 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3685  5 other 1 3685  
113 0 0 6 115 3524 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3685  5 other 1 3685  9 threshold 1 3521  
114 0 0 6 116 3666 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3685  
115 0 0 6 116 3666 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3685  9 threshold 1 3521  
116 0 0 6 117 3666 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3685  4 hash 1 3666  
117 0 0 6 117 3666 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3685  4 hash 1 3666  9 threshold 1 3521  
118 0 0 4 118 3668 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3685  7 hashgen 1 3674  
119 0 0 4 118 3668 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3685  7 hashgen 1 3674  9 threshold 1 3521  
120 0 0 7 119 3684 2095 0 0 1 4 this 3 3685  
121 0 0 7 120 3684 2095 0 0 2 4 this 3 3685  5 other 1 3685  
122 0 0 7 121 3684 2095 0 0 2 4 this 3 3685  5 other 1 3685  
123 0 0 7 122 3684 2095 0 0 2 4 this 3 3685  6 scalar 1 3521  
124 0 0 7 123 3684 2095 0 0 2 4 this 3 3685  6 scalar 1 3521  
125 0 0 6 124 3684 0 0 0 2 4 this 3 3684  5 other 1 3685  
126 0 0 6 125 3684 0 0 0 2 4 this 3 3684  5 other 1 3685  
127 0 0 6 126 3684 0 0 0 2 4 this 3 3684  6 scalar 1 3521  
128 0 0 6 127 3684 0 0 0 2 4 this 3 3684  6 scalar 1 3521  
129 0 0 4 128 3668 0 0 10 /**
 *
 */ 2 4 this 3 3684  5 other 1 3685  
130 0 0 7 129 3684 2095 0 0 2 4 this 3 3685  8 exponent 1 3521  
131 0 0 6 130 3669 0 0 0 2 4 this 3 3684  8 exponent 1 3521  
132 0 0 7 131 3684 2095 0 10 /**
 *
 */ 2 4 this 3 3685  5 other 1 3685  
133 0 0 7 132 3684 2095 0 10 /**
 *
 */ 2 4 this 3 3685  5 other 1 3685  
134 0 0 6 133 3673 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3685  5 other 1 3685  
135 0 0 6 133 3673 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3685  5 other 1 3685  9 threshold 1 3521  
136 0 0 4 134 3668 0 0 10 /**
 *
 */ 2 4 this 3 3685  3 out 1 3676  
137 0 0 6 135 3672 0 0 0 1 4 this 3 3685  
138 0 0 4 136 3668 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3685  11 destination 1 3678  
139 0 0 4 137 3668 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3684  6 source 1 3680  
140 0 0 4 138 3668 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3685  11 destination 1 3678  
141 0 0 4 139 3668 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3684  6 source 1 3680  
142 0 0 7 140 3683 0 0 0 0 
143 0 0 7 144 3687 2154 0 0 0 
144 0 0 7 144 3687 2154 0 0 1 6 param0 0 3688  
145 0 0 7 144 3687 2154 0 10 /**
 *
 */ 1 10 fill_value 1 3524  
146 0 0 7 144 3687 2154 0 10 /**
 *
 */ 2 1 x 1 3524  1 y 1 3524  
147 0 0 4 145 3668 0 0 0 2 4 this 3 3687  4 size 1 3666  
148 0 0 6 148 3687 0 0 0 2 4 this 3 3687  4 copy 1 3688  
149 0 0 6 148 3687 0 0 0 2 4 this 3 3687  10 fill_value 1 3524  
150 0 0 6 149 3688 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
151 0 0 6 150 3688 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
152 0 0 6 151 3688 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
153 0 0 6 152 3669 0 0 0 1 4 this 3 3688  
154 0 0 6 153 3669 0 0 0 2 4 this 3 3688  9 attr_name 1 3672  
155 0 0 6 154 3524 0 0 0 3 4 this 3 3687  9 attr_name 1 3672  6 assign 1 3669  
156 0 0 4 155 3668 0 0 10 /**
 *
 */ 3 4 this 3 3687  1 i 1 3524  10 assign_val 1 3524  
157 0 0 6 155 3524 0 0 0 2 4 this 3 3688  1 i 1 3524  
158 0 0 6 156 3524 0 0 0 0 
159 0 0 6 157 3673 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3688  
160 0 0 6 158 3524 0 0 10 /**
 *
 */ 2 4 this 3 3688  1 i 1 3524  
161 0 0 4 159 3668 0 0 10 /**
 *
 */ 3 4 this 3 3687  1 i 1 3524  5 value 1 3524  
162 0 0 6 160 3524 0 0 10 /**
 *
 */ 1 4 this 3 3688  
163 0 0 6 161 3524 0 0 10 /**
 *
 */ 1 4 this 3 3688  
164 0 0 4 162 3668 0 0 10 /**
 *
 */ 2 4 this 3 3687  5 value 1 3524  
165 0 0 4 163 3668 0 0 10 /**
 *
 */ 2 4 this 3 3687  5 value 1 3524  
166 0 0 4 167 3668 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3687  1 i 1 3524  5 value 1 3524  
167 0 0 4 168 3668 0 0 10 /**
 *
 */ 2 4 this 3 3687  5 value 1 3524  
168 0 0 4 169 3668 0 0 10 /**
 *
 */ 2 4 this 3 3687  5 value 1 3524  
169 0 0 4 170 3668 0 0 155 /**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */ 1 4 this 3 3688  
170 0 0 6 171 3524 0 0 0 0 
171 0 0 4 172 3668 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3687  10 fill_value 1 3524  
172 0 0 4 173 3668 0 0 10 /**
 *
 */ 3 4 this 3 3687  1 x 1 3524  1 y 1 3524  
173 0 0 6 174 3524 0 0 10 /**
 *
 */ 2 4 this 3 3688  5 other 1 3688  
174 0 0 6 175 3524 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3688  
175 0 0 6 176 3673 0 0 0 2 4 this 3 3688  5 other 1 3688  
176 0 0 6 177 3673 0 0 0 2 4 this 3 3688  5 other 1 3688  
177 0 0 6 178 3673 0 0 0 2 4 this 3 3688  5 other 1 3688  
178 0 0 6 179 3524 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3688  5 other 1 3688  
179 0 0 6 180 3666 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3688  
180 0 0 6 181 3666 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3688  4 hash 1 3666  
181 0 0 4 182 3668 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3688  7 hashgen 1 3674  
182 0 0 7 183 3687 2154 0 0 1 4 this 3 3688  
183 0 0 7 184 3687 2154 0 0 2 4 this 3 3688  5 other 1 3688  
184 0 0 7 185 3687 2154 0 0 2 4 this 3 3688  5 other 1 3688  
185 0 0 7 186 3687 2154 0 0 2 4 this 3 3688  6 scalar 1 3524  
186 0 0 7 187 3687 2154 0 0 2 4 this 3 3688  6 scalar 1 3524  
187 0 0 6 188 3687 0 0 0 2 4 this 3 3687  5 other 1 3688  
188 0 0 6 189 3687 0 0 0 2 4 this 3 3687  5 other 1 3688  
189 0 0 6 190 3687 0 0 0 2 4 this 3 3687  6 scalar 1 3524  
190 0 0 6 191 3687 0 0 0 2 4 this 3 3687  6 scalar 1 3524  
191 0 0 4 192 3668 0 0 10 /**
 *
 */ 2 4 this 3 3687  5 other 1 3688  
192 0 0 7 193 3687 2154 0 0 2 4 this 3 3688  8 exponent 1 3524  
193 0 0 6 194 3669 0 0 0 2 4 this 3 3687  8 exponent 1 3524  
194 0 0 7 195 3687 2154 0 10 /**
 *
 */ 2 4 this 3 3688  5 other 1 3688  
195 0 0 7 196 3687 2154 0 10 /**
 *
 */ 2 4 this 3 3688  5 other 1 3688  
196 0 0 6 197 3673 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3688  5 other 1 3688  
197 0 0 6 197 3673 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3688  5 other 1 3688  9 threshold 1 3524  
198 0 0 4 198 3668 0 0 10 /**
 *
 */ 2 4 this 3 3688  3 out 1 3676  
199 0 0 6 199 3672 0 0 0 1 4 this 3 3688  
200 0 0 4 200 3668 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3688  11 destination 1 3678  
201 0 0 4 201 3668 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3687  6 source 1 3680  
202 0 0 4 202 3668 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3688  11 destination 1 3678  
203 0 0 4 203 3668 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3687  6 source 1 3680  
204 0 0 7 204 3683 0 0 0 0 
205 0 0 7 207 3690 2172 0 0 0 
206 0 0 7 207 3690 2172 0 53 /**
 * Constructs a new LVector2 from a LVecBase2
 */ 1 4 copy 1 3664  
207 0 0 7 207 3690 2172 0 0 1 6 param0 0 3691  
208 0 0 7 207 3690 2172 0 79 /**
 * Constructs a new LVector2 with all components set to the fill value.
 */ 1 10 fill_value 1 3518  
209 0 0 7 207 3690 2172 0 10 /**
 *
 */ 2 1 x 1 3518  1 y 1 3518  
210 0 0 6 208 3669 0 0 0 2 4 this 3 3691  9 attr_name 1 3672  
211 0 0 6 209 3524 0 0 0 3 4 this 3 3690  9 attr_name 1 3672  6 assign 1 3669  
212 0 0 6 210 3691 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
213 0 0 6 211 3691 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
214 0 0 6 212 3691 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
215 0 0 7 213 3690 2172 0 0 1 4 this 3 3691  
216 0 0 7 214 3663 2032 0 0 2 4 this 3 3691  5 other 1 3664  
217 0 0 7 214 3690 2172 0 0 2 4 this 3 3691  5 other 1 3691  
218 0 0 7 215 3663 2032 0 0 2 4 this 3 3691  5 other 1 3664  
219 0 0 7 215 3690 2172 0 0 2 4 this 3 3691  5 other 1 3691  
220 0 0 7 216 3690 2172 0 0 2 4 this 3 3691  6 scalar 1 3518  
221 0 0 7 217 3690 2172 0 0 2 4 this 3 3691  6 scalar 1 3518  
222 0 0 7 218 3690 2172 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3691  
223 0 0 7 219 3690 2172 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3691  4 onto 1 3664  
224 0 0 6 220 3518 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3691  5 other 1 3691  
225 0 0 6 221 3518 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3691  5 other 1 3691  
226 0 0 6 222 3672 0 0 0 1 4 this 3 3691  
227 0 0 7 223 3683 0 0 0 0 
228 0 0 7 226 3693 2190 0 0 0 
229 0 0 7 226 3693 2190 0 53 /**
 * Constructs a new LVector2 from a LVecBase2
 */ 1 4 copy 1 3685  
230 0 0 7 226 3693 2190 0 0 1 6 param0 0 3694  
231 0 0 7 226 3693 2190 0 79 /**
 * Constructs a new LVector2 with all components set to the fill value.
 */ 1 10 fill_value 1 3521  
232 0 0 7 226 3693 2190 0 10 /**
 *
 */ 2 1 x 1 3521  1 y 1 3521  
233 0 0 6 227 3669 0 0 0 2 4 this 3 3694  9 attr_name 1 3672  
234 0 0 6 228 3524 0 0 0 3 4 this 3 3693  9 attr_name 1 3672  6 assign 1 3669  
235 0 0 6 229 3694 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
236 0 0 6 230 3694 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
237 0 0 6 231 3694 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
238 0 0 7 232 3693 2190 0 0 1 4 this 3 3694  
239 0 0 7 233 3684 2095 0 0 2 4 this 3 3694  5 other 1 3685  
240 0 0 7 233 3693 2190 0 0 2 4 this 3 3694  5 other 1 3694  
241 0 0 7 234 3684 2095 0 0 2 4 this 3 3694  5 other 1 3685  
242 0 0 7 234 3693 2190 0 0 2 4 this 3 3694  5 other 1 3694  
243 0 0 7 235 3693 2190 0 0 2 4 this 3 3694  6 scalar 1 3521  
244 0 0 7 236 3693 2190 0 0 2 4 this 3 3694  6 scalar 1 3521  
245 0 0 7 237 3693 2190 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3694  
246 0 0 7 238 3693 2190 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3694  4 onto 1 3685  
247 0 0 6 239 3521 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3694  5 other 1 3694  
248 0 0 6 240 3521 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3694  5 other 1 3694  
249 0 0 6 241 3672 0 0 0 1 4 this 3 3694  
250 0 0 7 242 3683 0 0 0 0 
251 0 0 7 245 3696 2204 0 0 0 
252 0 0 7 245 3696 2204 0 53 /**
 * Constructs a new LVector2 from a LVecBase2
 */ 1 4 copy 1 3688  
253 0 0 7 245 3696 2204 0 0 1 6 param0 0 3697  
254 0 0 7 245 3696 2204 0 79 /**
 * Constructs a new LVector2 with all components set to the fill value.
 */ 1 10 fill_value 1 3524  
255 0 0 7 245 3696 2204 0 10 /**
 *
 */ 2 1 x 1 3524  1 y 1 3524  
256 0 0 6 246 3669 0 0 0 2 4 this 3 3697  9 attr_name 1 3672  
257 0 0 6 247 3524 0 0 0 3 4 this 3 3696  9 attr_name 1 3672  6 assign 1 3669  
258 0 0 6 248 3697 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
259 0 0 6 249 3697 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
260 0 0 6 250 3697 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
261 0 0 7 251 3696 2204 0 0 1 4 this 3 3697  
262 0 0 7 252 3687 2154 0 0 2 4 this 3 3697  5 other 1 3688  
263 0 0 7 252 3696 2204 0 0 2 4 this 3 3697  5 other 1 3697  
264 0 0 7 253 3687 2154 0 0 2 4 this 3 3697  5 other 1 3688  
265 0 0 7 253 3696 2204 0 0 2 4 this 3 3697  5 other 1 3697  
266 0 0 7 254 3696 2204 0 0 2 4 this 3 3697  6 scalar 1 3524  
267 0 0 7 255 3696 2204 0 0 2 4 this 3 3697  6 scalar 1 3524  
268 0 0 6 256 3672 0 0 0 1 4 this 3 3697  
269 0 0 7 257 3683 0 0 0 0 
270 0 0 7 260 3699 2220 0 0 0 
271 0 0 7 260 3699 2220 0 0 1 6 param0 0 3700  
272 0 0 7 260 3699 2220 0 52 /**
 * Constructs a new LPoint2 from a LVecBase2
 */ 1 4 copy 1 3664  
273 0 0 7 260 3699 2220 0 73 /**
 * Constructs a new LPoint2 all components set to the fill value.
 */ 1 10 fill_value 1 3518  
274 0 0 7 260 3699 2220 0 61 /**
 * Constructs a new LPoint2 with the given components
 */ 2 1 x 1 3518  1 y 1 3518  
275 0 0 6 261 3669 0 0 0 2 4 this 3 3700  9 attr_name 1 3672  
276 0 0 6 262 3524 0 0 0 3 4 this 3 3699  9 attr_name 1 3672  6 assign 1 3669  
277 0 0 6 263 3700 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
278 0 0 6 264 3700 0 0 34 /**
 * Returns a unit X point.
 */ 0 
279 0 0 6 265 3700 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
280 0 0 7 266 3699 2220 0 0 1 4 this 3 3700  
281 0 0 7 267 3663 2032 0 0 2 4 this 3 3700  5 other 1 3664  
282 0 0 7 267 3699 2220 0 0 2 4 this 3 3700  5 other 1 3691  
283 0 0 7 268 3690 2172 0 0 2 4 this 3 3700  5 other 1 3700  
284 0 0 7 268 3663 2032 0 0 2 4 this 3 3700  5 other 1 3664  
285 0 0 7 268 3699 2220 0 0 2 4 this 3 3700  5 other 1 3691  
286 0 0 7 269 3699 2220 0 0 2 4 this 3 3700  6 scalar 1 3518  
287 0 0 7 270 3699 2220 0 0 2 4 this 3 3700  6 scalar 1 3518  
288 0 0 7 271 3699 2220 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3700  
289 0 0 7 272 3699 2220 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3700  4 onto 1 3664  
290 0 0 6 273 3672 0 0 0 1 4 this 3 3700  
291 0 0 7 274 3683 0 0 0 0 
292 0 0 7 277 3702 2236 0 0 0 
293 0 0 7 277 3702 2236 0 0 1 6 param0 0 3703  
294 0 0 7 277 3702 2236 0 52 /**
 * Constructs a new LPoint2 from a LVecBase2
 */ 1 4 copy 1 3685  
295 0 0 7 277 3702 2236 0 73 /**
 * Constructs a new LPoint2 all components set to the fill value.
 */ 1 10 fill_value 1 3521  
296 0 0 7 277 3702 2236 0 61 /**
 * Constructs a new LPoint2 with the given components
 */ 2 1 x 1 3521  1 y 1 3521  
297 0 0 6 278 3669 0 0 0 2 4 this 3 3703  9 attr_name 1 3672  
298 0 0 6 279 3524 0 0 0 3 4 this 3 3702  9 attr_name 1 3672  6 assign 1 3669  
299 0 0 6 280 3703 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
300 0 0 6 281 3703 0 0 34 /**
 * Returns a unit X point.
 */ 0 
301 0 0 6 282 3703 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
302 0 0 7 283 3702 2236 0 0 1 4 this 3 3703  
303 0 0 7 284 3684 2095 0 0 2 4 this 3 3703  5 other 1 3685  
304 0 0 7 284 3702 2236 0 0 2 4 this 3 3703  5 other 1 3694  
305 0 0 7 285 3693 2190 0 0 2 4 this 3 3703  5 other 1 3703  
306 0 0 7 285 3684 2095 0 0 2 4 this 3 3703  5 other 1 3685  
307 0 0 7 285 3702 2236 0 0 2 4 this 3 3703  5 other 1 3694  
308 0 0 7 286 3702 2236 0 0 2 4 this 3 3703  6 scalar 1 3521  
309 0 0 7 287 3702 2236 0 0 2 4 this 3 3703  6 scalar 1 3521  
310 0 0 7 288 3702 2236 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3703  
311 0 0 7 289 3702 2236 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3703  4 onto 1 3685  
312 0 0 6 290 3672 0 0 0 1 4 this 3 3703  
313 0 0 7 291 3683 0 0 0 0 
314 0 0 7 294 3705 2250 0 0 0 
315 0 0 7 294 3705 2250 0 0 1 6 param0 0 3706  
316 0 0 7 294 3705 2250 0 52 /**
 * Constructs a new LPoint2 from a LVecBase2
 */ 1 4 copy 1 3688  
317 0 0 7 294 3705 2250 0 73 /**
 * Constructs a new LPoint2 all components set to the fill value.
 */ 1 10 fill_value 1 3524  
318 0 0 7 294 3705 2250 0 61 /**
 * Constructs a new LPoint2 with the given components
 */ 2 1 x 1 3524  1 y 1 3524  
319 0 0 6 295 3669 0 0 0 2 4 this 3 3706  9 attr_name 1 3672  
320 0 0 6 296 3524 0 0 0 3 4 this 3 3705  9 attr_name 1 3672  6 assign 1 3669  
321 0 0 6 297 3706 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
322 0 0 6 298 3706 0 0 34 /**
 * Returns a unit X point.
 */ 0 
323 0 0 6 299 3706 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
324 0 0 7 300 3705 2250 0 0 1 4 this 3 3706  
325 0 0 7 301 3687 2154 0 0 2 4 this 3 3706  5 other 1 3688  
326 0 0 7 301 3705 2250 0 0 2 4 this 3 3706  5 other 1 3697  
327 0 0 7 302 3696 2204 0 0 2 4 this 3 3706  5 other 1 3706  
328 0 0 7 302 3687 2154 0 0 2 4 this 3 3706  5 other 1 3688  
329 0 0 7 302 3705 2250 0 0 2 4 this 3 3706  5 other 1 3697  
330 0 0 7 303 3705 2250 0 0 2 4 this 3 3706  6 scalar 1 3524  
331 0 0 7 304 3705 2250 0 0 2 4 this 3 3706  6 scalar 1 3524  
332 0 0 6 305 3672 0 0 0 1 4 this 3 3706  
333 0 0 7 306 3683 0 0 0 0 
334 0 0 7 310 3708 2323 0 0 0 
335 0 0 7 310 3708 2323 0 10 /**
 *
 */ 2 4 copy 1 3664  1 z 1 3518  
336 0 0 7 310 3708 2323 0 0 1 6 param0 0 3709  
337 0 0 7 310 3708 2323 0 10 /**
 *
 */ 1 10 fill_value 1 3518  
338 0 0 7 310 3708 2323 0 10 /**
 *
 */ 3 1 x 1 3518  1 y 1 3518  1 z 1 3518  
339 0 0 4 311 3668 0 0 0 2 4 this 3 3708  4 size 1 3666  
340 0 0 6 314 3708 0 0 0 2 4 this 3 3708  4 copy 1 3709  
341 0 0 6 314 3708 0 0 0 2 4 this 3 3708  10 fill_value 1 3518  
342 0 0 6 315 3709 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
343 0 0 6 316 3709 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
344 0 0 6 317 3709 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
345 0 0 6 318 3709 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
346 0 0 6 319 3669 0 0 0 1 4 this 3 3709  
347 0 0 6 320 3669 0 0 0 2 4 this 3 3709  9 attr_name 1 3672  
348 0 0 6 321 3524 0 0 0 3 4 this 3 3708  9 attr_name 1 3672  6 assign 1 3669  
349 0 0 4 322 3668 0 0 10 /**
 *
 */ 3 4 this 3 3708  1 i 1 3524  10 assign_val 1 3518  
350 0 0 6 322 3518 0 0 0 2 4 this 3 3709  1 i 1 3524  
351 0 0 6 323 3524 0 0 0 0 
352 0 0 6 324 3673 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3709  
353 0 0 6 325 3518 0 0 10 /**
 *
 */ 2 4 this 3 3709  1 i 1 3524  
354 0 0 6 326 3518 0 0 10 /**
 *
 */ 1 4 this 3 3709  
355 0 0 6 327 3518 0 0 10 /**
 *
 */ 1 4 this 3 3709  
356 0 0 6 328 3518 0 0 10 /**
 *
 */ 1 4 this 3 3709  
357 0 0 4 329 3668 0 0 10 /**
 *
 */ 3 4 this 3 3708  1 i 1 3524  5 value 1 3518  
358 0 0 4 330 3668 0 0 10 /**
 *
 */ 2 4 this 3 3708  5 value 1 3518  
359 0 0 4 331 3668 0 0 10 /**
 *
 */ 2 4 this 3 3708  5 value 1 3518  
360 0 0 4 332 3668 0 0 10 /**
 *
 */ 2 4 this 3 3708  5 value 1 3518  
361 0 0 7 333 3663 2032 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3709  
362 0 0 7 334 3663 2032 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3709  
363 0 0 7 335 3663 2032 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3709  
364 0 0 4 342 3668 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3708  1 i 1 3524  5 value 1 3518  
365 0 0 4 343 3668 0 0 10 /**
 *
 */ 2 4 this 3 3708  5 value 1 3518  
366 0 0 4 344 3668 0 0 10 /**
 *
 */ 2 4 this 3 3708  5 value 1 3518  
367 0 0 4 345 3668 0 0 10 /**
 *
 */ 2 4 this 3 3708  5 value 1 3518  
368 0 0 4 346 3668 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3709  
369 0 0 6 347 3524 0 0 0 0 
370 0 0 4 348 3668 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3708  10 fill_value 1 3518  
371 0 0 4 349 3668 0 0 10 /**
 *
 */ 4 4 this 3 3708  1 x 1 3518  1 y 1 3518  1 z 1 3518  
372 0 0 6 350 3518 0 0 10 /**
 *
 */ 2 4 this 3 3709  5 other 1 3709  
373 0 0 6 351 3518 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3709  
374 0 0 6 352 3518 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3709  
375 0 0 6 353 3673 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3708  
376 0 0 7 354 3708 2323 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3709  
377 0 0 7 355 3708 2323 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3709  4 onto 1 3709  
378 0 0 7 356 3708 2323 0 10 /**
 *
 */ 2 4 this 3 3709  5 other 1 3709  
379 0 0 6 357 3673 0 0 0 2 4 this 3 3709  5 other 1 3709  
380 0 0 6 358 3673 0 0 0 2 4 this 3 3709  5 other 1 3709  
381 0 0 6 359 3673 0 0 0 2 4 this 3 3709  5 other 1 3709  
382 0 0 7 360 3708 2323 0 623 /**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */ 1 4 this 3 3709  
383 0 0 6 361 3524 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3709  5 other 1 3709  
384 0 0 6 361 3524 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3709  5 other 1 3709  9 threshold 1 3518  
385 0 0 6 362 3666 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3709  
386 0 0 6 362 3666 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3709  9 threshold 1 3518  
387 0 0 6 363 3666 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3709  4 hash 1 3666  
388 0 0 6 363 3666 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3709  4 hash 1 3666  9 threshold 1 3518  
389 0 0 4 364 3668 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3709  7 hashgen 1 3674  
390 0 0 4 364 3668 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3709  7 hashgen 1 3674  9 threshold 1 3518  
391 0 0 7 365 3708 2323 0 0 1 4 this 3 3709  
392 0 0 7 366 3708 2323 0 0 2 4 this 3 3709  5 other 1 3709  
393 0 0 7 367 3708 2323 0 0 2 4 this 3 3709  5 other 1 3709  
394 0 0 7 368 3708 2323 0 0 2 4 this 3 3709  6 scalar 1 3518  
395 0 0 7 369 3708 2323 0 0 2 4 this 3 3709  6 scalar 1 3518  
396 0 0 6 370 3708 0 0 0 2 4 this 3 3708  5 other 1 3709  
397 0 0 6 371 3708 0 0 0 2 4 this 3 3708  5 other 1 3709  
398 0 0 6 372 3708 0 0 0 2 4 this 3 3708  6 scalar 1 3518  
399 0 0 6 373 3708 0 0 0 2 4 this 3 3708  6 scalar 1 3518  
400 0 0 4 374 3668 0 0 10 /**
 *
 */ 2 4 this 3 3708  5 other 1 3709  
401 0 0 7 375 3708 2323 0 0 2 4 this 3 3709  8 exponent 1 3518  
402 0 0 6 376 3669 0 0 0 2 4 this 3 3708  8 exponent 1 3518  
403 0 0 7 377 3708 2323 0 10 /**
 *
 */ 2 4 this 3 3709  5 other 1 3709  
404 0 0 7 378 3708 2323 0 10 /**
 *
 */ 2 4 this 3 3709  5 other 1 3709  
405 0 0 4 379 3668 0 0 10 /**
 *
 */ 2 4 this 3 3708  5 other 1 3709  
406 0 0 6 380 3673 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3709  5 other 1 3709  
407 0 0 6 380 3673 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3709  5 other 1 3709  9 threshold 1 3518  
408 0 0 4 381 3668 0 0 10 /**
 *
 */ 2 4 this 3 3709  3 out 1 3676  
409 0 0 6 382 3672 0 0 0 1 4 this 3 3709  
410 0 0 4 383 3668 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3709  11 destination 1 3678  
411 0 0 4 384 3668 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3708  6 source 1 3680  
412 0 0 4 385 3668 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3709  11 destination 1 3678  
413 0 0 4 386 3668 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3708  6 source 1 3680  
414 0 0 7 387 3683 0 0 0 0 
415 0 0 7 391 3711 2396 0 0 0 
416 0 0 7 391 3711 2396 0 10 /**
 *
 */ 2 4 copy 1 3685  1 z 1 3521  
417 0 0 7 391 3711 2396 0 0 1 6 param0 0 3712  
418 0 0 7 391 3711 2396 0 10 /**
 *
 */ 1 10 fill_value 1 3521  
419 0 0 7 391 3711 2396 0 10 /**
 *
 */ 3 1 x 1 3521  1 y 1 3521  1 z 1 3521  
420 0 0 4 392 3668 0 0 0 2 4 this 3 3711  4 size 1 3666  
421 0 0 6 395 3711 0 0 0 2 4 this 3 3711  4 copy 1 3712  
422 0 0 6 395 3711 0 0 0 2 4 this 3 3711  10 fill_value 1 3521  
423 0 0 6 396 3712 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
424 0 0 6 397 3712 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
425 0 0 6 398 3712 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
426 0 0 6 399 3712 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
427 0 0 6 400 3669 0 0 0 1 4 this 3 3712  
428 0 0 6 401 3669 0 0 0 2 4 this 3 3712  9 attr_name 1 3672  
429 0 0 6 402 3524 0 0 0 3 4 this 3 3711  9 attr_name 1 3672  6 assign 1 3669  
430 0 0 4 403 3668 0 0 10 /**
 *
 */ 3 4 this 3 3711  1 i 1 3524  10 assign_val 1 3521  
431 0 0 6 403 3521 0 0 0 2 4 this 3 3712  1 i 1 3524  
432 0 0 6 404 3524 0 0 0 0 
433 0 0 6 405 3673 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3712  
434 0 0 6 406 3521 0 0 10 /**
 *
 */ 2 4 this 3 3712  1 i 1 3524  
435 0 0 6 407 3521 0 0 10 /**
 *
 */ 1 4 this 3 3712  
436 0 0 6 408 3521 0 0 10 /**
 *
 */ 1 4 this 3 3712  
437 0 0 6 409 3521 0 0 10 /**
 *
 */ 1 4 this 3 3712  
438 0 0 4 410 3668 0 0 10 /**
 *
 */ 3 4 this 3 3711  1 i 1 3524  5 value 1 3521  
439 0 0 4 411 3668 0 0 10 /**
 *
 */ 2 4 this 3 3711  5 value 1 3521  
440 0 0 4 412 3668 0 0 10 /**
 *
 */ 2 4 this 3 3711  5 value 1 3521  
441 0 0 4 413 3668 0 0 10 /**
 *
 */ 2 4 this 3 3711  5 value 1 3521  
442 0 0 7 414 3684 2095 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3712  
443 0 0 7 415 3684 2095 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3712  
444 0 0 7 416 3684 2095 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3712  
445 0 0 4 423 3668 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3711  1 i 1 3524  5 value 1 3521  
446 0 0 4 424 3668 0 0 10 /**
 *
 */ 2 4 this 3 3711  5 value 1 3521  
447 0 0 4 425 3668 0 0 10 /**
 *
 */ 2 4 this 3 3711  5 value 1 3521  
448 0 0 4 426 3668 0 0 10 /**
 *
 */ 2 4 this 3 3711  5 value 1 3521  
449 0 0 4 427 3668 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3712  
450 0 0 6 428 3524 0 0 0 0 
451 0 0 4 429 3668 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3711  10 fill_value 1 3521  
452 0 0 4 430 3668 0 0 10 /**
 *
 */ 4 4 this 3 3711  1 x 1 3521  1 y 1 3521  1 z 1 3521  
453 0 0 6 431 3521 0 0 10 /**
 *
 */ 2 4 this 3 3712  5 other 1 3712  
454 0 0 6 432 3521 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3712  
455 0 0 6 433 3521 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3712  
456 0 0 6 434 3673 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3711  
457 0 0 7 435 3711 2396 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3712  
458 0 0 7 436 3711 2396 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3712  4 onto 1 3712  
459 0 0 7 437 3711 2396 0 10 /**
 *
 */ 2 4 this 3 3712  5 other 1 3712  
460 0 0 6 438 3673 0 0 0 2 4 this 3 3712  5 other 1 3712  
461 0 0 6 439 3673 0 0 0 2 4 this 3 3712  5 other 1 3712  
462 0 0 6 440 3673 0 0 0 2 4 this 3 3712  5 other 1 3712  
463 0 0 7 441 3711 2396 0 623 /**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */ 1 4 this 3 3712  
464 0 0 6 442 3524 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3712  5 other 1 3712  
465 0 0 6 442 3524 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3712  5 other 1 3712  9 threshold 1 3521  
466 0 0 6 443 3666 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3712  
467 0 0 6 443 3666 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3712  9 threshold 1 3521  
468 0 0 6 444 3666 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3712  4 hash 1 3666  
469 0 0 6 444 3666 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3712  4 hash 1 3666  9 threshold 1 3521  
470 0 0 4 445 3668 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3712  7 hashgen 1 3674  
471 0 0 4 445 3668 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3712  7 hashgen 1 3674  9 threshold 1 3521  
472 0 0 7 446 3711 2396 0 0 1 4 this 3 3712  
473 0 0 7 447 3711 2396 0 0 2 4 this 3 3712  5 other 1 3712  
474 0 0 7 448 3711 2396 0 0 2 4 this 3 3712  5 other 1 3712  
475 0 0 7 449 3711 2396 0 0 2 4 this 3 3712  6 scalar 1 3521  
476 0 0 7 450 3711 2396 0 0 2 4 this 3 3712  6 scalar 1 3521  
477 0 0 6 451 3711 0 0 0 2 4 this 3 3711  5 other 1 3712  
478 0 0 6 452 3711 0 0 0 2 4 this 3 3711  5 other 1 3712  
479 0 0 6 453 3711 0 0 0 2 4 this 3 3711  6 scalar 1 3521  
480 0 0 6 454 3711 0 0 0 2 4 this 3 3711  6 scalar 1 3521  
481 0 0 4 455 3668 0 0 10 /**
 *
 */ 2 4 this 3 3711  5 other 1 3712  
482 0 0 7 456 3711 2396 0 0 2 4 this 3 3712  8 exponent 1 3521  
483 0 0 6 457 3669 0 0 0 2 4 this 3 3711  8 exponent 1 3521  
484 0 0 7 458 3711 2396 0 10 /**
 *
 */ 2 4 this 3 3712  5 other 1 3712  
485 0 0 7 459 3711 2396 0 10 /**
 *
 */ 2 4 this 3 3712  5 other 1 3712  
486 0 0 4 460 3668 0 0 10 /**
 *
 */ 2 4 this 3 3711  5 other 1 3712  
487 0 0 6 461 3673 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3712  5 other 1 3712  
488 0 0 6 461 3673 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3712  5 other 1 3712  9 threshold 1 3521  
489 0 0 4 462 3668 0 0 10 /**
 *
 */ 2 4 this 3 3712  3 out 1 3676  
490 0 0 6 463 3672 0 0 0 1 4 this 3 3712  
491 0 0 4 464 3668 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3712  11 destination 1 3678  
492 0 0 4 465 3668 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3711  6 source 1 3680  
493 0 0 4 466 3668 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3712  11 destination 1 3678  
494 0 0 4 467 3668 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3711  6 source 1 3680  
495 0 0 7 468 3683 0 0 0 0 
496 0 0 7 472 3714 2464 0 0 0 
497 0 0 7 472 3714 2464 0 10 /**
 *
 */ 2 4 copy 1 3688  1 z 1 3524  
498 0 0 7 472 3714 2464 0 0 1 6 param0 0 3715  
499 0 0 7 472 3714 2464 0 10 /**
 *
 */ 1 10 fill_value 1 3524  
500 0 0 7 472 3714 2464 0 10 /**
 *
 */ 3 1 x 1 3524  1 y 1 3524  1 z 1 3524  
501 0 0 4 473 3668 0 0 0 2 4 this 3 3714  4 size 1 3666  
502 0 0 6 476 3714 0 0 0 2 4 this 3 3714  4 copy 1 3715  
503 0 0 6 476 3714 0 0 0 2 4 this 3 3714  10 fill_value 1 3524  
504 0 0 6 477 3715 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
505 0 0 6 478 3715 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
506 0 0 6 479 3715 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
507 0 0 6 480 3715 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
508 0 0 6 481 3669 0 0 0 1 4 this 3 3715  
509 0 0 6 482 3669 0 0 0 2 4 this 3 3715  9 attr_name 1 3672  
510 0 0 6 483 3524 0 0 0 3 4 this 3 3714  9 attr_name 1 3672  6 assign 1 3669  
511 0 0 4 484 3668 0 0 10 /**
 *
 */ 3 4 this 3 3714  1 i 1 3524  10 assign_val 1 3524  
512 0 0 6 484 3524 0 0 0 2 4 this 3 3715  1 i 1 3524  
513 0 0 6 485 3524 0 0 0 0 
514 0 0 6 486 3673 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3715  
515 0 0 6 487 3524 0 0 10 /**
 *
 */ 2 4 this 3 3715  1 i 1 3524  
516 0 0 6 488 3524 0 0 10 /**
 *
 */ 1 4 this 3 3715  
517 0 0 6 489 3524 0 0 10 /**
 *
 */ 1 4 this 3 3715  
518 0 0 6 490 3524 0 0 10 /**
 *
 */ 1 4 this 3 3715  
519 0 0 4 491 3668 0 0 10 /**
 *
 */ 3 4 this 3 3714  1 i 1 3524  5 value 1 3524  
520 0 0 4 492 3668 0 0 10 /**
 *
 */ 2 4 this 3 3714  5 value 1 3524  
521 0 0 4 493 3668 0 0 10 /**
 *
 */ 2 4 this 3 3714  5 value 1 3524  
522 0 0 4 494 3668 0 0 10 /**
 *
 */ 2 4 this 3 3714  5 value 1 3524  
523 0 0 7 495 3687 2154 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3715  
524 0 0 7 496 3687 2154 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3715  
525 0 0 7 497 3687 2154 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3715  
526 0 0 4 504 3668 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3714  1 i 1 3524  5 value 1 3524  
527 0 0 4 505 3668 0 0 10 /**
 *
 */ 2 4 this 3 3714  5 value 1 3524  
528 0 0 4 506 3668 0 0 10 /**
 *
 */ 2 4 this 3 3714  5 value 1 3524  
529 0 0 4 507 3668 0 0 10 /**
 *
 */ 2 4 this 3 3714  5 value 1 3524  
530 0 0 4 508 3668 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3715  
531 0 0 6 509 3524 0 0 0 0 
532 0 0 4 510 3668 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3714  10 fill_value 1 3524  
533 0 0 4 511 3668 0 0 10 /**
 *
 */ 4 4 this 3 3714  1 x 1 3524  1 y 1 3524  1 z 1 3524  
534 0 0 6 512 3524 0 0 10 /**
 *
 */ 2 4 this 3 3715  5 other 1 3715  
535 0 0 6 513 3524 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3715  
536 0 0 7 514 3714 2464 0 10 /**
 *
 */ 2 4 this 3 3715  5 other 1 3715  
537 0 0 6 515 3673 0 0 0 2 4 this 3 3715  5 other 1 3715  
538 0 0 6 516 3673 0 0 0 2 4 this 3 3715  5 other 1 3715  
539 0 0 6 517 3673 0 0 0 2 4 this 3 3715  5 other 1 3715  
540 0 0 6 518 3524 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3715  5 other 1 3715  
541 0 0 6 519 3666 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3715  
542 0 0 6 520 3666 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3715  4 hash 1 3666  
543 0 0 4 521 3668 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3715  7 hashgen 1 3674  
544 0 0 7 522 3714 2464 0 0 1 4 this 3 3715  
545 0 0 7 523 3714 2464 0 0 2 4 this 3 3715  5 other 1 3715  
546 0 0 7 524 3714 2464 0 0 2 4 this 3 3715  5 other 1 3715  
547 0 0 7 525 3714 2464 0 0 2 4 this 3 3715  6 scalar 1 3524  
548 0 0 7 526 3714 2464 0 0 2 4 this 3 3715  6 scalar 1 3524  
549 0 0 6 527 3714 0 0 0 2 4 this 3 3714  5 other 1 3715  
550 0 0 6 528 3714 0 0 0 2 4 this 3 3714  5 other 1 3715  
551 0 0 6 529 3714 0 0 0 2 4 this 3 3714  6 scalar 1 3524  
552 0 0 6 530 3714 0 0 0 2 4 this 3 3714  6 scalar 1 3524  
553 0 0 4 531 3668 0 0 10 /**
 *
 */ 2 4 this 3 3714  5 other 1 3715  
554 0 0 7 532 3714 2464 0 0 2 4 this 3 3715  8 exponent 1 3524  
555 0 0 6 533 3669 0 0 0 2 4 this 3 3714  8 exponent 1 3524  
556 0 0 7 534 3714 2464 0 10 /**
 *
 */ 2 4 this 3 3715  5 other 1 3715  
557 0 0 7 535 3714 2464 0 10 /**
 *
 */ 2 4 this 3 3715  5 other 1 3715  
558 0 0 4 536 3668 0 0 10 /**
 *
 */ 2 4 this 3 3714  5 other 1 3715  
559 0 0 6 537 3673 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3715  5 other 1 3715  
560 0 0 6 537 3673 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3715  5 other 1 3715  9 threshold 1 3524  
561 0 0 4 538 3668 0 0 10 /**
 *
 */ 2 4 this 3 3715  3 out 1 3676  
562 0 0 6 539 3672 0 0 0 1 4 this 3 3715  
563 0 0 4 540 3668 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3715  11 destination 1 3678  
564 0 0 4 541 3668 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3714  6 source 1 3680  
565 0 0 4 542 3668 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3715  11 destination 1 3678  
566 0 0 4 543 3668 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3714  6 source 1 3680  
567 0 0 7 544 3683 0 0 0 0 
568 0 0 7 552 3717 2502 0 0 0 
569 0 0 7 552 3717 2502 0 10 /**
 *
 */ 2 4 copy 1 3664  1 z 1 3518  
570 0 0 7 552 3717 2502 0 10 /**
 *
 */ 1 4 copy 1 3709  
571 0 0 7 552 3717 2502 0 0 1 6 param0 0 3718  
572 0 0 7 552 3717 2502 0 10 /**
 *
 */ 1 10 fill_value 1 3518  
573 0 0 7 552 3717 2502 0 10 /**
 *
 */ 3 1 x 1 3518  1 y 1 3518  1 z 1 3518  
574 0 0 6 553 3669 0 0 0 2 4 this 3 3718  9 attr_name 1 3672  
575 0 0 6 554 3524 0 0 0 3 4 this 3 3717  9 attr_name 1 3672  6 assign 1 3669  
576 0 0 6 555 3718 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
577 0 0 6 556 3718 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
578 0 0 6 557 3718 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
579 0 0 6 558 3718 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
580 0 0 7 559 3690 2172 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3718  
581 0 0 7 560 3690 2172 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3718  
582 0 0 7 561 3690 2172 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3718  
583 0 0 7 565 3717 2502 0 0 1 4 this 3 3718  
584 0 0 7 566 3708 2323 0 0 2 4 this 3 3718  5 other 1 3709  
585 0 0 7 566 3717 2502 0 0 2 4 this 3 3718  5 other 1 3718  
586 0 0 7 567 3708 2323 0 0 2 4 this 3 3718  5 other 1 3709  
587 0 0 7 567 3717 2502 0 0 2 4 this 3 3718  5 other 1 3718  
588 0 0 7 568 3717 2502 0 10 /**
 *
 */ 2 4 this 3 3718  5 other 1 3709  
589 0 0 7 569 3717 2502 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3718  
590 0 0 7 570 3717 2502 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3718  4 onto 1 3709  
591 0 0 6 571 3518 0 0 147 /**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */ 2 4 this 3 3718  5 other 1 3718  
592 0 0 6 572 3518 0 0 138 /**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */ 2 4 this 3 3718  5 other 1 3718  
593 0 0 6 573 3518 0 0 259 /**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3718  5 other 1 3718  3 ref 1 3718  
594 0 0 6 574 3518 0 0 259 /**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3718  5 other 1 3718  3 ref 1 3718  
595 0 0 6 575 3518 0 0 34 /**
 * @deprecated Do not use.
 */ 2 4 this 3 3718  5 other 1 3718  
596 0 0 6 576 3518 0 0 34 /**
 * @deprecated Do not use.
 */ 2 4 this 3 3718  5 other 1 3718  
597 0 0 7 577 3717 2502 0 0 2 4 this 3 3718  6 scalar 1 3518  
598 0 0 7 578 3717 2502 0 0 2 4 this 3 3718  6 scalar 1 3518  
599 0 0 7 579 3717 2502 0 65 /**
 * Returns the up vector for the given coordinate system.
 */ 1 2 cs 1 3537  
600 0 0 7 580 3717 2502 0 68 /**
 * Returns the right vector for the given coordinate system.
 */ 1 2 cs 1 3537  
601 0 0 7 581 3717 2502 0 70 /**
 * Returns the forward vector for the given coordinate system.
 */ 1 2 cs 1 3537  
602 0 0 7 582 3717 2502 0 67 /**
 * Returns the down vector for the given coordinate system.
 */ 1 2 cs 1 3537  
603 0 0 7 583 3717 2502 0 67 /**
 * Returns the left vector for the given coordinate system.
 */ 1 2 cs 1 3537  
604 0 0 7 584 3717 2502 0 67 /**
 * Returns the back vector for the given coordinate system.
 */ 1 2 cs 1 3537  
605 0 0 7 585 3717 2502 0 152 /**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */ 4 5 right 1 3518  3 fwd 1 3518  2 up 1 3518  2 cs 1 3537  
606 0 0 6 586 3672 0 0 0 1 4 this 3 3718  
607 0 0 7 587 3683 0 0 0 0 
608 0 0 7 590 3720 2536 0 0 0 
609 0 0 7 590 3720 2536 0 10 /**
 *
 */ 2 4 copy 1 3685  1 z 1 3521  
610 0 0 7 590 3720 2536 0 10 /**
 *
 */ 1 4 copy 1 3712  
611 0 0 7 590 3720 2536 0 0 1 6 param0 0 3721  
612 0 0 7 590 3720 2536 0 10 /**
 *
 */ 1 10 fill_value 1 3521  
613 0 0 7 590 3720 2536 0 10 /**
 *
 */ 3 1 x 1 3521  1 y 1 3521  1 z 1 3521  
614 0 0 6 591 3669 0 0 0 2 4 this 3 3721  9 attr_name 1 3672  
615 0 0 6 592 3524 0 0 0 3 4 this 3 3720  9 attr_name 1 3672  6 assign 1 3669  
616 0 0 6 593 3721 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
617 0 0 6 594 3721 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
618 0 0 6 595 3721 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
619 0 0 6 596 3721 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
620 0 0 7 597 3693 2190 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3721  
621 0 0 7 598 3693 2190 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3721  
622 0 0 7 599 3693 2190 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3721  
623 0 0 7 603 3720 2536 0 0 1 4 this 3 3721  
624 0 0 7 604 3711 2396 0 0 2 4 this 3 3721  5 other 1 3712  
625 0 0 7 604 3720 2536 0 0 2 4 this 3 3721  5 other 1 3721  
626 0 0 7 605 3711 2396 0 0 2 4 this 3 3721  5 other 1 3712  
627 0 0 7 605 3720 2536 0 0 2 4 this 3 3721  5 other 1 3721  
628 0 0 7 606 3720 2536 0 10 /**
 *
 */ 2 4 this 3 3721  5 other 1 3712  
629 0 0 7 607 3720 2536 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3721  
630 0 0 7 608 3720 2536 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3721  4 onto 1 3712  
631 0 0 6 609 3521 0 0 147 /**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */ 2 4 this 3 3721  5 other 1 3721  
632 0 0 6 610 3521 0 0 138 /**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */ 2 4 this 3 3721  5 other 1 3721  
633 0 0 6 611 3521 0 0 259 /**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3721  5 other 1 3721  3 ref 1 3721  
634 0 0 6 612 3521 0 0 259 /**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3721  5 other 1 3721  3 ref 1 3721  
635 0 0 6 613 3521 0 0 34 /**
 * @deprecated Do not use.
 */ 2 4 this 3 3721  5 other 1 3721  
636 0 0 6 614 3521 0 0 34 /**
 * @deprecated Do not use.
 */ 2 4 this 3 3721  5 other 1 3721  
637 0 0 7 615 3720 2536 0 0 2 4 this 3 3721  6 scalar 1 3521  
638 0 0 7 616 3720 2536 0 0 2 4 this 3 3721  6 scalar 1 3521  
639 0 0 7 617 3720 2536 0 65 /**
 * Returns the up vector for the given coordinate system.
 */ 1 2 cs 1 3537  
640 0 0 7 618 3720 2536 0 68 /**
 * Returns the right vector for the given coordinate system.
 */ 1 2 cs 1 3537  
641 0 0 7 619 3720 2536 0 70 /**
 * Returns the forward vector for the given coordinate system.
 */ 1 2 cs 1 3537  
642 0 0 7 620 3720 2536 0 67 /**
 * Returns the down vector for the given coordinate system.
 */ 1 2 cs 1 3537  
643 0 0 7 621 3720 2536 0 67 /**
 * Returns the left vector for the given coordinate system.
 */ 1 2 cs 1 3537  
644 0 0 7 622 3720 2536 0 67 /**
 * Returns the back vector for the given coordinate system.
 */ 1 2 cs 1 3537  
645 0 0 7 623 3720 2536 0 152 /**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */ 4 5 right 1 3521  3 fwd 1 3521  2 up 1 3521  2 cs 1 3537  
646 0 0 6 624 3672 0 0 0 1 4 this 3 3721  
647 0 0 7 625 3683 0 0 0 0 
648 0 0 7 628 3723 2562 0 0 0 
649 0 0 7 628 3723 2562 0 10 /**
 *
 */ 2 4 copy 1 3688  1 z 1 3524  
650 0 0 7 628 3723 2562 0 10 /**
 *
 */ 1 4 copy 1 3715  
651 0 0 7 628 3723 2562 0 0 1 6 param0 0 3724  
652 0 0 7 628 3723 2562 0 10 /**
 *
 */ 1 10 fill_value 1 3524  
653 0 0 7 628 3723 2562 0 10 /**
 *
 */ 3 1 x 1 3524  1 y 1 3524  1 z 1 3524  
654 0 0 6 629 3669 0 0 0 2 4 this 3 3724  9 attr_name 1 3672  
655 0 0 6 630 3524 0 0 0 3 4 this 3 3723  9 attr_name 1 3672  6 assign 1 3669  
656 0 0 6 631 3724 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
657 0 0 6 632 3724 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
658 0 0 6 633 3724 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
659 0 0 6 634 3724 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
660 0 0 7 635 3696 2204 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3724  
661 0 0 7 636 3696 2204 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3724  
662 0 0 7 637 3696 2204 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3724  
663 0 0 7 641 3723 2562 0 0 1 4 this 3 3724  
664 0 0 7 642 3714 2464 0 0 2 4 this 3 3724  5 other 1 3715  
665 0 0 7 642 3723 2562 0 0 2 4 this 3 3724  5 other 1 3724  
666 0 0 7 643 3714 2464 0 0 2 4 this 3 3724  5 other 1 3715  
667 0 0 7 643 3723 2562 0 0 2 4 this 3 3724  5 other 1 3724  
668 0 0 7 644 3723 2562 0 10 /**
 *
 */ 2 4 this 3 3724  5 other 1 3715  
669 0 0 7 645 3723 2562 0 0 2 4 this 3 3724  6 scalar 1 3524  
670 0 0 7 646 3723 2562 0 0 2 4 this 3 3724  6 scalar 1 3524  
671 0 0 7 647 3723 2562 0 65 /**
 * Returns the up vector for the given coordinate system.
 */ 1 2 cs 1 3537  
672 0 0 7 648 3723 2562 0 68 /**
 * Returns the right vector for the given coordinate system.
 */ 1 2 cs 1 3537  
673 0 0 7 649 3723 2562 0 70 /**
 * Returns the forward vector for the given coordinate system.
 */ 1 2 cs 1 3537  
674 0 0 7 650 3723 2562 0 67 /**
 * Returns the down vector for the given coordinate system.
 */ 1 2 cs 1 3537  
675 0 0 7 651 3723 2562 0 67 /**
 * Returns the left vector for the given coordinate system.
 */ 1 2 cs 1 3537  
676 0 0 7 652 3723 2562 0 67 /**
 * Returns the back vector for the given coordinate system.
 */ 1 2 cs 1 3537  
677 0 0 7 653 3723 2562 0 152 /**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */ 4 5 right 1 3524  3 fwd 1 3524  2 up 1 3524  2 cs 1 3537  
678 0 0 6 654 3672 0 0 0 1 4 this 3 3724  
679 0 0 7 655 3683 0 0 0 0 
680 0 0 7 658 3726 2585 0 0 0 
681 0 0 7 658 3726 2585 0 0 1 6 param0 0 3727  
682 0 0 7 658 3726 2585 0 10 /**
 *
 */ 2 4 copy 1 3664  1 z 1 3518  
683 0 0 7 658 3726 2585 0 10 /**
 *
 */ 1 4 copy 1 3709  
684 0 0 7 658 3726 2585 0 10 /**
 *
 */ 1 10 fill_value 1 3518  
685 0 0 7 658 3726 2585 0 10 /**
 *
 */ 3 1 x 1 3518  1 y 1 3518  1 z 1 3518  
686 0 0 6 659 3669 0 0 0 2 4 this 3 3727  9 attr_name 1 3672  
687 0 0 6 660 3524 0 0 0 3 4 this 3 3726  9 attr_name 1 3672  6 assign 1 3669  
688 0 0 6 661 3727 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
689 0 0 6 662 3727 0 0 34 /**
 * Returns a unit X point.
 */ 0 
690 0 0 6 663 3727 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
691 0 0 6 664 3727 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
692 0 0 7 665 3699 2220 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3727  
693 0 0 7 666 3699 2220 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3727  
694 0 0 7 667 3699 2220 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3727  
695 0 0 7 671 3726 2585 0 0 1 4 this 3 3727  
696 0 0 7 672 3708 2323 0 0 2 4 this 3 3727  5 other 1 3709  
697 0 0 7 672 3726 2585 0 0 2 4 this 3 3727  5 other 1 3718  
698 0 0 7 673 3717 2502 0 0 2 4 this 3 3727  5 other 1 3727  
699 0 0 7 673 3708 2323 0 0 2 4 this 3 3727  5 other 1 3709  
700 0 0 7 673 3726 2585 0 0 2 4 this 3 3727  5 other 1 3718  
701 0 0 7 674 3726 2585 0 10 /**
 *
 */ 2 4 this 3 3727  5 other 1 3709  
702 0 0 7 675 3726 2585 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3727  
703 0 0 7 676 3726 2585 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3727  4 onto 1 3709  
704 0 0 7 677 3726 2585 0 0 2 4 this 3 3727  6 scalar 1 3518  
705 0 0 7 678 3726 2585 0 0 2 4 this 3 3727  6 scalar 1 3518  
706 0 0 6 679 3727 0 0 186 /**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */ 1 2 cs 1 3537  
707 0 0 7 680 3726 2585 0 146 /**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */ 4 5 right 1 3518  3 fwd 1 3518  2 up 1 3518  2 cs 1 3537  
708 0 0 6 681 3672 0 0 0 1 4 this 3 3727  
709 0 0 7 682 3683 0 0 0 0 
710 0 0 7 685 3729 2608 0 0 0 
711 0 0 7 685 3729 2608 0 0 1 6 param0 0 3730  
712 0 0 7 685 3729 2608 0 10 /**
 *
 */ 2 4 copy 1 3685  1 z 1 3521  
713 0 0 7 685 3729 2608 0 10 /**
 *
 */ 1 4 copy 1 3712  
714 0 0 7 685 3729 2608 0 10 /**
 *
 */ 1 10 fill_value 1 3521  
715 0 0 7 685 3729 2608 0 10 /**
 *
 */ 3 1 x 1 3521  1 y 1 3521  1 z 1 3521  
716 0 0 6 686 3669 0 0 0 2 4 this 3 3730  9 attr_name 1 3672  
717 0 0 6 687 3524 0 0 0 3 4 this 3 3729  9 attr_name 1 3672  6 assign 1 3669  
718 0 0 6 688 3730 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
719 0 0 6 689 3730 0 0 34 /**
 * Returns a unit X point.
 */ 0 
720 0 0 6 690 3730 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
721 0 0 6 691 3730 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
722 0 0 7 692 3702 2236 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3730  
723 0 0 7 693 3702 2236 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3730  
724 0 0 7 694 3702 2236 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3730  
725 0 0 7 698 3729 2608 0 0 1 4 this 3 3730  
726 0 0 7 699 3711 2396 0 0 2 4 this 3 3730  5 other 1 3712  
727 0 0 7 699 3729 2608 0 0 2 4 this 3 3730  5 other 1 3721  
728 0 0 7 700 3720 2536 0 0 2 4 this 3 3730  5 other 1 3730  
729 0 0 7 700 3711 2396 0 0 2 4 this 3 3730  5 other 1 3712  
730 0 0 7 700 3729 2608 0 0 2 4 this 3 3730  5 other 1 3721  
731 0 0 7 701 3729 2608 0 10 /**
 *
 */ 2 4 this 3 3730  5 other 1 3712  
732 0 0 7 702 3729 2608 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3730  
733 0 0 7 703 3729 2608 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3730  4 onto 1 3712  
734 0 0 7 704 3729 2608 0 0 2 4 this 3 3730  6 scalar 1 3521  
735 0 0 7 705 3729 2608 0 0 2 4 this 3 3730  6 scalar 1 3521  
736 0 0 6 706 3730 0 0 186 /**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */ 1 2 cs 1 3537  
737 0 0 7 707 3729 2608 0 146 /**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */ 4 5 right 1 3521  3 fwd 1 3521  2 up 1 3521  2 cs 1 3537  
738 0 0 6 708 3672 0 0 0 1 4 this 3 3730  
739 0 0 7 709 3683 0 0 0 0 
740 0 0 7 712 3732 2629 0 0 0 
741 0 0 7 712 3732 2629 0 0 1 6 param0 0 3733  
742 0 0 7 712 3732 2629 0 10 /**
 *
 */ 2 4 copy 1 3688  1 z 1 3524  
743 0 0 7 712 3732 2629 0 10 /**
 *
 */ 1 4 copy 1 3715  
744 0 0 7 712 3732 2629 0 10 /**
 *
 */ 1 10 fill_value 1 3524  
745 0 0 7 712 3732 2629 0 10 /**
 *
 */ 3 1 x 1 3524  1 y 1 3524  1 z 1 3524  
746 0 0 6 713 3669 0 0 0 2 4 this 3 3733  9 attr_name 1 3672  
747 0 0 6 714 3524 0 0 0 3 4 this 3 3732  9 attr_name 1 3672  6 assign 1 3669  
748 0 0 6 715 3733 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
749 0 0 6 716 3733 0 0 34 /**
 * Returns a unit X point.
 */ 0 
750 0 0 6 717 3733 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
751 0 0 6 718 3733 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
752 0 0 7 719 3705 2250 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3733  
753 0 0 7 720 3705 2250 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3733  
754 0 0 7 721 3705 2250 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3733  
755 0 0 7 725 3732 2629 0 0 1 4 this 3 3733  
756 0 0 7 726 3714 2464 0 0 2 4 this 3 3733  5 other 1 3715  
757 0 0 7 726 3732 2629 0 0 2 4 this 3 3733  5 other 1 3724  
758 0 0 7 727 3723 2562 0 0 2 4 this 3 3733  5 other 1 3733  
759 0 0 7 727 3714 2464 0 0 2 4 this 3 3733  5 other 1 3715  
760 0 0 7 727 3732 2629 0 0 2 4 this 3 3733  5 other 1 3724  
761 0 0 7 728 3732 2629 0 10 /**
 *
 */ 2 4 this 3 3733  5 other 1 3715  
762 0 0 7 729 3732 2629 0 0 2 4 this 3 3733  6 scalar 1 3524  
763 0 0 7 730 3732 2629 0 0 2 4 this 3 3733  6 scalar 1 3524  
764 0 0 6 731 3733 0 0 186 /**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */ 1 2 cs 1 3537  
765 0 0 7 732 3732 2629 0 146 /**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */ 4 5 right 1 3524  3 fwd 1 3524  2 up 1 3524  2 cs 1 3537  
766 0 0 6 733 3672 0 0 0 1 4 this 3 3733  
767 0 0 7 734 3683 0 0 0 0 
768 0 0 7 738 3735 2703 0 0 0 
769 0 0 7 738 3735 2703 0 84 /**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */ 1 5 point 1 3727  
770 0 0 7 738 3735 2703 0 10 /**
 *
 */ 2 4 copy 1 3709  1 w 1 3518  
771 0 0 7 738 3735 2703 0 0 1 6 param0 0 3736  
772 0 0 7 738 3735 2703 0 85 /**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */ 1 6 vector 1 3718  
773 0 0 7 738 3735 2703 0 10 /**
 *
 */ 1 4 copy 1 3738  
774 0 0 7 738 3735 2703 0 10 /**
 *
 */ 1 10 fill_value 1 3518  
775 0 0 7 738 3735 2703 0 10 /**
 *
 */ 4 1 x 1 3518  1 y 1 3518  1 z 1 3518  1 w 1 3518  
776 0 0 4 739 3668 0 0 0 2 4 this 3 3735  4 size 1 3666  
777 0 0 6 742 3735 0 0 0 2 4 this 3 3735  4 copy 1 3736  
778 0 0 6 742 3735 0 0 0 2 4 this 3 3735  10 fill_value 1 3518  
779 0 0 6 743 3736 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
780 0 0 6 744 3736 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
781 0 0 6 745 3736 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
782 0 0 6 746 3736 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
783 0 0 6 747 3736 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
784 0 0 6 748 3669 0 0 0 1 4 this 3 3736  
785 0 0 6 749 3669 0 0 0 2 4 this 3 3736  9 attr_name 1 3672  
786 0 0 6 750 3524 0 0 0 3 4 this 3 3735  9 attr_name 1 3672  6 assign 1 3669  
787 0 0 4 751 3668 0 0 10 /**
 *
 */ 3 4 this 3 3735  1 i 1 3524  10 assign_val 1 3518  
788 0 0 6 751 3518 0 0 0 2 4 this 3 3736  1 i 1 3524  
789 0 0 6 752 3524 0 0 0 0 
790 0 0 6 753 3673 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3736  
791 0 0 6 754 3518 0 0 10 /**
 *
 */ 2 4 this 3 3736  1 i 1 3524  
792 0 0 4 755 3668 0 0 10 /**
 *
 */ 3 4 this 3 3735  1 i 1 3524  5 value 1 3518  
793 0 0 6 756 3518 0 0 10 /**
 *
 */ 1 4 this 3 3736  
794 0 0 6 757 3518 0 0 10 /**
 *
 */ 1 4 this 3 3736  
795 0 0 6 758 3518 0 0 10 /**
 *
 */ 1 4 this 3 3736  
796 0 0 6 759 3518 0 0 10 /**
 *
 */ 1 4 this 3 3736  
797 0 0 7 760 3708 2323 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3736  
798 0 0 7 761 3663 2032 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3736  
799 0 0 4 762 3668 0 0 10 /**
 *
 */ 2 4 this 3 3735  5 value 1 3518  
800 0 0 4 763 3668 0 0 10 /**
 *
 */ 2 4 this 3 3735  5 value 1 3518  
801 0 0 4 764 3668 0 0 10 /**
 *
 */ 2 4 this 3 3735  5 value 1 3518  
802 0 0 4 765 3668 0 0 10 /**
 *
 */ 2 4 this 3 3735  5 value 1 3518  
803 0 0 4 771 3668 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3735  1 i 1 3524  5 value 1 3518  
804 0 0 4 772 3668 0 0 10 /**
 *
 */ 2 4 this 3 3735  5 value 1 3518  
805 0 0 4 773 3668 0 0 10 /**
 *
 */ 2 4 this 3 3735  5 value 1 3518  
806 0 0 4 774 3668 0 0 10 /**
 *
 */ 2 4 this 3 3735  5 value 1 3518  
807 0 0 4 775 3668 0 0 10 /**
 *
 */ 2 4 this 3 3735  5 value 1 3518  
808 0 0 4 776 3668 0 0 161 /**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3736  
809 0 0 6 777 3524 0 0 0 0 
810 0 0 4 779 3668 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3735  10 fill_value 1 3518  
811 0 0 4 780 3668 0 0 10 /**
 *
 */ 5 4 this 3 3735  1 x 1 3518  1 y 1 3518  1 z 1 3518  1 w 1 3518  
812 0 0 6 781 3518 0 0 10 /**
 *
 */ 2 4 this 3 3736  5 other 1 3736  
813 0 0 6 782 3518 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3736  
814 0 0 6 783 3518 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3736  
815 0 0 6 784 3673 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3735  
816 0 0 7 785 3735 2703 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3736  
817 0 0 7 786 3735 2703 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3736  4 onto 1 3736  
818 0 0 6 787 3673 0 0 0 2 4 this 3 3736  5 other 1 3736  
819 0 0 6 788 3673 0 0 0 2 4 this 3 3736  5 other 1 3736  
820 0 0 6 789 3673 0 0 0 2 4 this 3 3736  5 other 1 3736  
821 0 0 6 790 3524 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3736  5 other 1 3736  
822 0 0 6 790 3524 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3736  5 other 1 3736  9 threshold 1 3518  
823 0 0 6 791 3666 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3736  
824 0 0 6 791 3666 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3736  9 threshold 1 3518  
825 0 0 6 792 3666 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3736  4 hash 1 3666  
826 0 0 6 792 3666 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3736  4 hash 1 3666  9 threshold 1 3518  
827 0 0 4 793 3668 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3736  7 hashgen 1 3674  
828 0 0 4 793 3668 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3736  7 hashgen 1 3674  9 threshold 1 3518  
829 0 0 7 794 3735 2703 0 0 1 4 this 3 3736  
830 0 0 7 795 3735 2703 0 0 2 4 this 3 3736  5 other 1 3736  
831 0 0 7 796 3735 2703 0 0 2 4 this 3 3736  5 other 1 3736  
832 0 0 7 797 3735 2703 0 0 2 4 this 3 3736  6 scalar 1 3518  
833 0 0 7 798 3735 2703 0 0 2 4 this 3 3736  6 scalar 1 3518  
834 0 0 6 799 3735 0 0 0 2 4 this 3 3735  5 other 1 3736  
835 0 0 6 800 3735 0 0 0 2 4 this 3 3735  5 other 1 3736  
836 0 0 6 801 3735 0 0 0 2 4 this 3 3735  6 scalar 1 3518  
837 0 0 6 802 3735 0 0 0 2 4 this 3 3735  6 scalar 1 3518  
838 0 0 4 803 3668 0 0 10 /**
 *
 */ 2 4 this 3 3735  5 other 1 3736  
839 0 0 7 804 3735 2703 0 0 2 4 this 3 3736  8 exponent 1 3518  
840 0 0 6 805 3669 0 0 0 2 4 this 3 3735  8 exponent 1 3518  
841 0 0 7 806 3735 2703 0 10 /**
 *
 */ 2 4 this 3 3736  5 other 1 3736  
842 0 0 7 807 3735 2703 0 10 /**
 *
 */ 2 4 this 3 3736  5 other 1 3736  
843 0 0 6 808 3673 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3736  5 other 1 3736  
844 0 0 6 808 3673 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3736  5 other 1 3736  9 threshold 1 3518  
845 0 0 4 809 3668 0 0 10 /**
 *
 */ 2 4 this 3 3736  3 out 1 3676  
846 0 0 6 810 3672 0 0 0 1 4 this 3 3736  
847 0 0 4 811 3668 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3736  11 destination 1 3678  
848 0 0 4 812 3668 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3735  6 source 1 3680  
849 0 0 4 813 3668 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3736  11 destination 1 3678  
850 0 0 4 814 3668 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3735  6 source 1 3680  
851 0 0 7 815 3683 0 0 0 0 
852 0 0 7 819 3740 2714 0 0 0 
853 0 0 7 819 3740 2714 0 10 /**
 *
 */ 1 4 copy 1 3736  
854 0 0 7 819 3740 2714 0 0 1 6 param0 0 3738  
855 0 0 7 819 3740 2714 0 10 /**
 *
 */ 1 10 fill_value 1 3518  
856 0 0 7 819 3740 2714 0 10 /**
 *
 */ 4 1 x 1 3518  1 y 1 3518  1 z 1 3518  1 w 1 3518  
857 0 0 4 820 3668 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3740  10 fill_value 1 3518  
858 0 0 4 821 3668 0 0 10 /**
 *
 */ 5 4 this 3 3740  1 x 1 3518  1 y 1 3518  1 z 1 3518  1 w 1 3518  
859 0 0 4 822 3668 0 0 10 /**
 *
 */ 3 4 this 3 3740  1 i 1 3524  10 assign_val 1 3518  
860 0 0 6 822 3518 0 0 0 2 4 this 3 3738  1 i 1 3524  
861 0 0 6 823 3524 0 0 0 0 
862 0 0 4 824 3668 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3738  
863 0 0 6 825 3524 0 0 0 0 
864 0 0 6 826 3673 0 0 0 2 4 this 3 3738  5 other 1 3738  
865 0 0 6 827 3673 0 0 0 2 4 this 3 3738  5 other 1 3738  
866 0 0 7 828 3683 0 0 0 0 
867 0 0 7 832 3741 2788 0 0 0 
868 0 0 7 832 3741 2788 0 84 /**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */ 1 5 point 1 3730  
869 0 0 7 832 3741 2788 0 10 /**
 *
 */ 2 4 copy 1 3712  1 w 1 3521  
870 0 0 7 832 3741 2788 0 0 1 6 param0 0 3742  
871 0 0 7 832 3741 2788 0 85 /**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */ 1 6 vector 1 3721  
872 0 0 7 832 3741 2788 0 10 /**
 *
 */ 1 4 copy 1 3744  
873 0 0 7 832 3741 2788 0 10 /**
 *
 */ 1 10 fill_value 1 3521  
874 0 0 7 832 3741 2788 0 10 /**
 *
 */ 4 1 x 1 3521  1 y 1 3521  1 z 1 3521  1 w 1 3521  
875 0 0 4 833 3668 0 0 0 2 4 this 3 3741  4 size 1 3666  
876 0 0 6 836 3741 0 0 0 2 4 this 3 3741  4 copy 1 3742  
877 0 0 6 836 3741 0 0 0 2 4 this 3 3741  10 fill_value 1 3521  
878 0 0 6 837 3742 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
879 0 0 6 838 3742 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
880 0 0 6 839 3742 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
881 0 0 6 840 3742 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
882 0 0 6 841 3742 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
883 0 0 6 842 3669 0 0 0 1 4 this 3 3742  
884 0 0 6 843 3669 0 0 0 2 4 this 3 3742  9 attr_name 1 3672  
885 0 0 6 844 3524 0 0 0 3 4 this 3 3741  9 attr_name 1 3672  6 assign 1 3669  
886 0 0 4 845 3668 0 0 10 /**
 *
 */ 3 4 this 3 3741  1 i 1 3524  10 assign_val 1 3521  
887 0 0 6 845 3521 0 0 0 2 4 this 3 3742  1 i 1 3524  
888 0 0 6 846 3524 0 0 0 0 
889 0 0 6 847 3673 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3742  
890 0 0 6 848 3521 0 0 10 /**
 *
 */ 2 4 this 3 3742  1 i 1 3524  
891 0 0 4 849 3668 0 0 10 /**
 *
 */ 3 4 this 3 3741  1 i 1 3524  5 value 1 3521  
892 0 0 6 850 3521 0 0 10 /**
 *
 */ 1 4 this 3 3742  
893 0 0 6 851 3521 0 0 10 /**
 *
 */ 1 4 this 3 3742  
894 0 0 6 852 3521 0 0 10 /**
 *
 */ 1 4 this 3 3742  
895 0 0 6 853 3521 0 0 10 /**
 *
 */ 1 4 this 3 3742  
896 0 0 7 854 3711 2396 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3742  
897 0 0 7 855 3684 2095 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3742  
898 0 0 4 856 3668 0 0 10 /**
 *
 */ 2 4 this 3 3741  5 value 1 3521  
899 0 0 4 857 3668 0 0 10 /**
 *
 */ 2 4 this 3 3741  5 value 1 3521  
900 0 0 4 858 3668 0 0 10 /**
 *
 */ 2 4 this 3 3741  5 value 1 3521  
901 0 0 4 859 3668 0 0 10 /**
 *
 */ 2 4 this 3 3741  5 value 1 3521  
902 0 0 4 865 3668 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3741  1 i 1 3524  5 value 1 3521  
903 0 0 4 866 3668 0 0 10 /**
 *
 */ 2 4 this 3 3741  5 value 1 3521  
904 0 0 4 867 3668 0 0 10 /**
 *
 */ 2 4 this 3 3741  5 value 1 3521  
905 0 0 4 868 3668 0 0 10 /**
 *
 */ 2 4 this 3 3741  5 value 1 3521  
906 0 0 4 869 3668 0 0 10 /**
 *
 */ 2 4 this 3 3741  5 value 1 3521  
907 0 0 4 870 3668 0 0 161 /**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3742  
908 0 0 6 871 3524 0 0 0 0 
909 0 0 4 873 3668 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3741  10 fill_value 1 3521  
910 0 0 4 874 3668 0 0 10 /**
 *
 */ 5 4 this 3 3741  1 x 1 3521  1 y 1 3521  1 z 1 3521  1 w 1 3521  
911 0 0 6 875 3521 0 0 10 /**
 *
 */ 2 4 this 3 3742  5 other 1 3742  
912 0 0 6 876 3521 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3742  
913 0 0 6 877 3521 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3742  
914 0 0 6 878 3673 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3741  
915 0 0 7 879 3741 2788 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3742  
916 0 0 7 880 3741 2788 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3742  4 onto 1 3742  
917 0 0 6 881 3673 0 0 0 2 4 this 3 3742  5 other 1 3742  
918 0 0 6 882 3673 0 0 0 2 4 this 3 3742  5 other 1 3742  
919 0 0 6 883 3673 0 0 0 2 4 this 3 3742  5 other 1 3742  
920 0 0 6 884 3524 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3742  5 other 1 3742  
921 0 0 6 884 3524 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3742  5 other 1 3742  9 threshold 1 3521  
922 0 0 6 885 3666 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3742  
923 0 0 6 885 3666 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3742  9 threshold 1 3521  
924 0 0 6 886 3666 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3742  4 hash 1 3666  
925 0 0 6 886 3666 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3742  4 hash 1 3666  9 threshold 1 3521  
926 0 0 4 887 3668 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3742  7 hashgen 1 3674  
927 0 0 4 887 3668 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3742  7 hashgen 1 3674  9 threshold 1 3521  
928 0 0 7 888 3741 2788 0 0 1 4 this 3 3742  
929 0 0 7 889 3741 2788 0 0 2 4 this 3 3742  5 other 1 3742  
930 0 0 7 890 3741 2788 0 0 2 4 this 3 3742  5 other 1 3742  
931 0 0 7 891 3741 2788 0 0 2 4 this 3 3742  6 scalar 1 3521  
932 0 0 7 892 3741 2788 0 0 2 4 this 3 3742  6 scalar 1 3521  
933 0 0 6 893 3741 0 0 0 2 4 this 3 3741  5 other 1 3742  
934 0 0 6 894 3741 0 0 0 2 4 this 3 3741  5 other 1 3742  
935 0 0 6 895 3741 0 0 0 2 4 this 3 3741  6 scalar 1 3521  
936 0 0 6 896 3741 0 0 0 2 4 this 3 3741  6 scalar 1 3521  
937 0 0 4 897 3668 0 0 10 /**
 *
 */ 2 4 this 3 3741  5 other 1 3742  
938 0 0 7 898 3741 2788 0 0 2 4 this 3 3742  8 exponent 1 3521  
939 0 0 6 899 3669 0 0 0 2 4 this 3 3741  8 exponent 1 3521  
940 0 0 7 900 3741 2788 0 10 /**
 *
 */ 2 4 this 3 3742  5 other 1 3742  
941 0 0 7 901 3741 2788 0 10 /**
 *
 */ 2 4 this 3 3742  5 other 1 3742  
942 0 0 6 902 3673 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3742  5 other 1 3742  
943 0 0 6 902 3673 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3742  5 other 1 3742  9 threshold 1 3521  
944 0 0 4 903 3668 0 0 10 /**
 *
 */ 2 4 this 3 3742  3 out 1 3676  
945 0 0 6 904 3672 0 0 0 1 4 this 3 3742  
946 0 0 4 905 3668 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3742  11 destination 1 3678  
947 0 0 4 906 3668 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3741  6 source 1 3680  
948 0 0 4 907 3668 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3742  11 destination 1 3678  
949 0 0 4 908 3668 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3741  6 source 1 3680  
950 0 0 7 909 3683 0 0 0 0 
951 0 0 7 913 3746 2799 0 0 0 
952 0 0 7 913 3746 2799 0 10 /**
 *
 */ 1 4 copy 1 3742  
953 0 0 7 913 3746 2799 0 0 1 6 param0 0 3744  
954 0 0 7 913 3746 2799 0 10 /**
 *
 */ 1 10 fill_value 1 3521  
955 0 0 7 913 3746 2799 0 10 /**
 *
 */ 4 1 x 1 3521  1 y 1 3521  1 z 1 3521  1 w 1 3521  
956 0 0 4 914 3668 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3746  10 fill_value 1 3521  
957 0 0 4 915 3668 0 0 10 /**
 *
 */ 5 4 this 3 3746  1 x 1 3521  1 y 1 3521  1 z 1 3521  1 w 1 3521  
958 0 0 4 916 3668 0 0 10 /**
 *
 */ 3 4 this 3 3746  1 i 1 3524  10 assign_val 1 3521  
959 0 0 6 916 3521 0 0 0 2 4 this 3 3744  1 i 1 3524  
960 0 0 6 917 3524 0 0 0 0 
961 0 0 4 918 3668 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3744  
962 0 0 6 919 3524 0 0 0 0 
963 0 0 6 920 3673 0 0 0 2 4 this 3 3744  5 other 1 3744  
964 0 0 6 921 3673 0 0 0 2 4 this 3 3744  5 other 1 3744  
965 0 0 7 922 3683 0 0 0 0 
966 0 0 7 926 3747 2869 0 0 0 
967 0 0 7 926 3747 2869 0 84 /**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */ 1 5 point 1 3733  
968 0 0 7 926 3747 2869 0 10 /**
 *
 */ 2 4 copy 1 3715  1 w 1 3524  
969 0 0 7 926 3747 2869 0 0 1 6 param0 0 3748  
970 0 0 7 926 3747 2869 0 85 /**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */ 1 6 vector 1 3724  
971 0 0 7 926 3747 2869 0 10 /**
 *
 */ 1 4 copy 1 3750  
972 0 0 7 926 3747 2869 0 10 /**
 *
 */ 1 10 fill_value 1 3524  
973 0 0 7 926 3747 2869 0 10 /**
 *
 */ 4 1 x 1 3524  1 y 1 3524  1 z 1 3524  1 w 1 3524  
974 0 0 4 927 3668 0 0 0 2 4 this 3 3747  4 size 1 3666  
975 0 0 6 930 3747 0 0 0 2 4 this 3 3747  4 copy 1 3748  
976 0 0 6 930 3747 0 0 0 2 4 this 3 3747  10 fill_value 1 3524  
977 0 0 6 931 3748 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
978 0 0 6 932 3748 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
979 0 0 6 933 3748 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
980 0 0 6 934 3748 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
981 0 0 6 935 3748 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
982 0 0 6 936 3669 0 0 0 1 4 this 3 3748  
983 0 0 6 937 3669 0 0 0 2 4 this 3 3748  9 attr_name 1 3672  
984 0 0 6 938 3524 0 0 0 3 4 this 3 3747  9 attr_name 1 3672  6 assign 1 3669  
985 0 0 4 939 3668 0 0 10 /**
 *
 */ 3 4 this 3 3747  1 i 1 3524  10 assign_val 1 3524  
986 0 0 6 939 3524 0 0 0 2 4 this 3 3748  1 i 1 3524  
987 0 0 6 940 3524 0 0 0 0 
988 0 0 6 941 3673 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3748  
989 0 0 6 942 3524 0 0 10 /**
 *
 */ 2 4 this 3 3748  1 i 1 3524  
990 0 0 4 943 3668 0 0 10 /**
 *
 */ 3 4 this 3 3747  1 i 1 3524  5 value 1 3524  
991 0 0 6 944 3524 0 0 10 /**
 *
 */ 1 4 this 3 3748  
992 0 0 6 945 3524 0 0 10 /**
 *
 */ 1 4 this 3 3748  
993 0 0 6 946 3524 0 0 10 /**
 *
 */ 1 4 this 3 3748  
994 0 0 6 947 3524 0 0 10 /**
 *
 */ 1 4 this 3 3748  
995 0 0 7 948 3714 2464 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3748  
996 0 0 7 949 3687 2154 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3748  
997 0 0 4 950 3668 0 0 10 /**
 *
 */ 2 4 this 3 3747  5 value 1 3524  
998 0 0 4 951 3668 0 0 10 /**
 *
 */ 2 4 this 3 3747  5 value 1 3524  
999 0 0 4 952 3668 0 0 10 /**
 *
 */ 2 4 this 3 3747  5 value 1 3524  
1000 0 0 4 953 3668 0 0 10 /**
 *
 */ 2 4 this 3 3747  5 value 1 3524  
1001 0 0 4 959 3668 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3747  1 i 1 3524  5 value 1 3524  
1002 0 0 4 960 3668 0 0 10 /**
 *
 */ 2 4 this 3 3747  5 value 1 3524  
1003 0 0 4 961 3668 0 0 10 /**
 *
 */ 2 4 this 3 3747  5 value 1 3524  
1004 0 0 4 962 3668 0 0 10 /**
 *
 */ 2 4 this 3 3747  5 value 1 3524  
1005 0 0 4 963 3668 0 0 10 /**
 *
 */ 2 4 this 3 3747  5 value 1 3524  
1006 0 0 4 964 3668 0 0 161 /**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3748  
1007 0 0 6 965 3524 0 0 0 0 
1008 0 0 4 967 3668 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3747  10 fill_value 1 3524  
1009 0 0 4 968 3668 0 0 10 /**
 *
 */ 5 4 this 3 3747  1 x 1 3524  1 y 1 3524  1 z 1 3524  1 w 1 3524  
1010 0 0 6 969 3524 0 0 10 /**
 *
 */ 2 4 this 3 3748  5 other 1 3748  
1011 0 0 6 970 3524 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3748  
1012 0 0 6 971 3673 0 0 0 2 4 this 3 3748  5 other 1 3748  
1013 0 0 6 972 3673 0 0 0 2 4 this 3 3748  5 other 1 3748  
1014 0 0 6 973 3673 0 0 0 2 4 this 3 3748  5 other 1 3748  
1015 0 0 6 974 3524 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3748  5 other 1 3748  
1016 0 0 6 975 3666 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3748  
1017 0 0 6 976 3666 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3748  4 hash 1 3666  
1018 0 0 4 977 3668 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3748  7 hashgen 1 3674  
1019 0 0 7 978 3747 2869 0 0 1 4 this 3 3748  
1020 0 0 7 979 3747 2869 0 0 2 4 this 3 3748  5 other 1 3748  
1021 0 0 7 980 3747 2869 0 0 2 4 this 3 3748  5 other 1 3748  
1022 0 0 7 981 3747 2869 0 0 2 4 this 3 3748  6 scalar 1 3524  
1023 0 0 7 982 3747 2869 0 0 2 4 this 3 3748  6 scalar 1 3524  
1024 0 0 6 983 3747 0 0 0 2 4 this 3 3747  5 other 1 3748  
1025 0 0 6 984 3747 0 0 0 2 4 this 3 3747  5 other 1 3748  
1026 0 0 6 985 3747 0 0 0 2 4 this 3 3747  6 scalar 1 3524  
1027 0 0 6 986 3747 0 0 0 2 4 this 3 3747  6 scalar 1 3524  
1028 0 0 4 987 3668 0 0 10 /**
 *
 */ 2 4 this 3 3747  5 other 1 3748  
1029 0 0 7 988 3747 2869 0 0 2 4 this 3 3748  8 exponent 1 3524  
1030 0 0 6 989 3669 0 0 0 2 4 this 3 3747  8 exponent 1 3524  
1031 0 0 7 990 3747 2869 0 10 /**
 *
 */ 2 4 this 3 3748  5 other 1 3748  
1032 0 0 7 991 3747 2869 0 10 /**
 *
 */ 2 4 this 3 3748  5 other 1 3748  
1033 0 0 6 992 3673 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3748  5 other 1 3748  
1034 0 0 6 992 3673 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3748  5 other 1 3748  9 threshold 1 3524  
1035 0 0 4 993 3668 0 0 10 /**
 *
 */ 2 4 this 3 3748  3 out 1 3676  
1036 0 0 6 994 3672 0 0 0 1 4 this 3 3748  
1037 0 0 4 995 3668 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3748  11 destination 1 3678  
1038 0 0 4 996 3668 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3747  6 source 1 3680  
1039 0 0 4 997 3668 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3748  11 destination 1 3678  
1040 0 0 4 998 3668 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3747  6 source 1 3680  
1041 0 0 7 999 3683 0 0 0 0 
1042 0 0 7 1003 3752 2880 0 0 0 
1043 0 0 7 1003 3752 2880 0 10 /**
 *
 */ 1 4 copy 1 3748  
1044 0 0 7 1003 3752 2880 0 0 1 6 param0 0 3750  
1045 0 0 7 1003 3752 2880 0 10 /**
 *
 */ 1 10 fill_value 1 3524  
1046 0 0 7 1003 3752 2880 0 10 /**
 *
 */ 4 1 x 1 3524  1 y 1 3524  1 z 1 3524  1 w 1 3524  
1047 0 0 4 1004 3668 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3752  10 fill_value 1 3524  
1048 0 0 4 1005 3668 0 0 10 /**
 *
 */ 5 4 this 3 3752  1 x 1 3524  1 y 1 3524  1 z 1 3524  1 w 1 3524  
1049 0 0 4 1006 3668 0 0 10 /**
 *
 */ 3 4 this 3 3752  1 i 1 3524  10 assign_val 1 3524  
1050 0 0 6 1006 3524 0 0 0 2 4 this 3 3750  1 i 1 3524  
1051 0 0 6 1007 3524 0 0 0 0 
1052 0 0 4 1008 3668 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3750  
1053 0 0 6 1009 3524 0 0 0 0 
1054 0 0 6 1010 3673 0 0 0 2 4 this 3 3750  5 other 1 3750  
1055 0 0 6 1011 3673 0 0 0 2 4 this 3 3750  5 other 1 3750  
1056 0 0 7 1012 3683 0 0 0 0 
1057 0 0 7 1015 3753 2900 0 0 0 
1058 0 0 7 1015 3753 2900 0 10 /**
 *
 */ 2 4 copy 1 3709  1 w 1 3518  
1059 0 0 7 1015 3753 2900 0 10 /**
 *
 */ 1 4 copy 1 3736  
1060 0 0 7 1015 3753 2900 0 0 1 6 param0 0 3754  
1061 0 0 7 1015 3753 2900 0 10 /**
 *
 */ 1 10 fill_value 1 3518  
1062 0 0 7 1015 3753 2900 0 10 /**
 *
 */ 4 1 x 1 3518  1 y 1 3518  1 z 1 3518  1 w 1 3518  
1063 0 0 6 1016 3669 0 0 0 2 4 this 3 3754  9 attr_name 1 3672  
1064 0 0 6 1017 3524 0 0 0 3 4 this 3 3753  9 attr_name 1 3672  6 assign 1 3669  
1065 0 0 6 1018 3754 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
1066 0 0 6 1019 3754 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
1067 0 0 6 1020 3754 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
1068 0 0 6 1021 3754 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
1069 0 0 6 1022 3754 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
1070 0 0 7 1023 3717 2502 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3754  
1071 0 0 7 1024 3690 2172 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3754  
1072 0 0 7 1027 3753 2900 0 0 1 4 this 3 3754  
1073 0 0 7 1028 3735 2703 0 0 2 4 this 3 3754  5 other 1 3736  
1074 0 0 7 1028 3753 2900 0 0 2 4 this 3 3754  5 other 1 3754  
1075 0 0 7 1029 3735 2703 0 0 2 4 this 3 3754  5 other 1 3736  
1076 0 0 7 1029 3753 2900 0 0 2 4 this 3 3754  5 other 1 3754  
1077 0 0 7 1030 3753 2900 0 0 2 4 this 3 3754  6 scalar 1 3518  
1078 0 0 7 1031 3753 2900 0 0 2 4 this 3 3754  6 scalar 1 3518  
1079 0 0 7 1032 3753 2900 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3754  
1080 0 0 7 1033 3753 2900 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3754  4 onto 1 3736  
1081 0 0 6 1034 3672 0 0 0 1 4 this 3 3754  
1082 0 0 7 1035 3683 0 0 0 0 
1083 0 0 7 1038 3756 2920 0 0 0 
1084 0 0 7 1038 3756 2920 0 10 /**
 *
 */ 2 4 copy 1 3712  1 w 1 3521  
1085 0 0 7 1038 3756 2920 0 10 /**
 *
 */ 1 4 copy 1 3742  
1086 0 0 7 1038 3756 2920 0 0 1 6 param0 0 3757  
1087 0 0 7 1038 3756 2920 0 10 /**
 *
 */ 1 10 fill_value 1 3521  
1088 0 0 7 1038 3756 2920 0 10 /**
 *
 */ 4 1 x 1 3521  1 y 1 3521  1 z 1 3521  1 w 1 3521  
1089 0 0 6 1039 3669 0 0 0 2 4 this 3 3757  9 attr_name 1 3672  
1090 0 0 6 1040 3524 0 0 0 3 4 this 3 3756  9 attr_name 1 3672  6 assign 1 3669  
1091 0 0 6 1041 3757 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
1092 0 0 6 1042 3757 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
1093 0 0 6 1043 3757 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
1094 0 0 6 1044 3757 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
1095 0 0 6 1045 3757 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
1096 0 0 7 1046 3720 2536 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3757  
1097 0 0 7 1047 3693 2190 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3757  
1098 0 0 7 1050 3756 2920 0 0 1 4 this 3 3757  
1099 0 0 7 1051 3741 2788 0 0 2 4 this 3 3757  5 other 1 3742  
1100 0 0 7 1051 3756 2920 0 0 2 4 this 3 3757  5 other 1 3757  
1101 0 0 7 1052 3741 2788 0 0 2 4 this 3 3757  5 other 1 3742  
1102 0 0 7 1052 3756 2920 0 0 2 4 this 3 3757  5 other 1 3757  
1103 0 0 7 1053 3756 2920 0 0 2 4 this 3 3757  6 scalar 1 3521  
1104 0 0 7 1054 3756 2920 0 0 2 4 this 3 3757  6 scalar 1 3521  
1105 0 0 7 1055 3756 2920 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3757  
1106 0 0 7 1056 3756 2920 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3757  4 onto 1 3742  
1107 0 0 6 1057 3672 0 0 0 1 4 this 3 3757  
1108 0 0 7 1058 3683 0 0 0 0 
1109 0 0 7 1061 3759 2938 0 0 0 
1110 0 0 7 1061 3759 2938 0 10 /**
 *
 */ 2 4 copy 1 3715  1 w 1 3524  
1111 0 0 7 1061 3759 2938 0 10 /**
 *
 */ 1 4 copy 1 3748  
1112 0 0 7 1061 3759 2938 0 0 1 6 param0 0 3760  
1113 0 0 7 1061 3759 2938 0 10 /**
 *
 */ 1 10 fill_value 1 3524  
1114 0 0 7 1061 3759 2938 0 10 /**
 *
 */ 4 1 x 1 3524  1 y 1 3524  1 z 1 3524  1 w 1 3524  
1115 0 0 6 1062 3669 0 0 0 2 4 this 3 3760  9 attr_name 1 3672  
1116 0 0 6 1063 3524 0 0 0 3 4 this 3 3759  9 attr_name 1 3672  6 assign 1 3669  
1117 0 0 6 1064 3760 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
1118 0 0 6 1065 3760 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
1119 0 0 6 1066 3760 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
1120 0 0 6 1067 3760 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
1121 0 0 6 1068 3760 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
1122 0 0 7 1069 3723 2562 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3760  
1123 0 0 7 1070 3696 2204 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3760  
1124 0 0 7 1073 3759 2938 0 0 1 4 this 3 3760  
1125 0 0 7 1074 3747 2869 0 0 2 4 this 3 3760  5 other 1 3748  
1126 0 0 7 1074 3759 2938 0 0 2 4 this 3 3760  5 other 1 3760  
1127 0 0 7 1075 3747 2869 0 0 2 4 this 3 3760  5 other 1 3748  
1128 0 0 7 1075 3759 2938 0 0 2 4 this 3 3760  5 other 1 3760  
1129 0 0 7 1076 3759 2938 0 0 2 4 this 3 3760  6 scalar 1 3524  
1130 0 0 7 1077 3759 2938 0 0 2 4 this 3 3760  6 scalar 1 3524  
1131 0 0 6 1078 3672 0 0 0 1 4 this 3 3760  
1132 0 0 7 1079 3683 0 0 0 0 
1133 0 0 7 1082 3762 2958 0 0 0 
1134 0 0 7 1082 3762 2958 0 0 1 6 param0 0 3763  
1135 0 0 7 1082 3762 2958 0 10 /**
 *
 */ 2 4 copy 1 3709  1 w 1 3518  
1136 0 0 7 1082 3762 2958 0 10 /**
 *
 */ 1 4 copy 1 3736  
1137 0 0 7 1082 3762 2958 0 10 /**
 *
 */ 1 10 fill_value 1 3518  
1138 0 0 7 1082 3762 2958 0 10 /**
 *
 */ 4 1 x 1 3518  1 y 1 3518  1 z 1 3518  1 w 1 3518  
1139 0 0 6 1083 3669 0 0 0 2 4 this 3 3763  9 attr_name 1 3672  
1140 0 0 6 1084 3524 0 0 0 3 4 this 3 3762  9 attr_name 1 3672  6 assign 1 3669  
1141 0 0 6 1085 3763 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
1142 0 0 6 1086 3763 0 0 34 /**
 * Returns a unit X point.
 */ 0 
1143 0 0 6 1087 3763 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
1144 0 0 6 1088 3763 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
1145 0 0 6 1089 3763 0 0 34 /**
 * Returns a unit W point.
 */ 0 
1146 0 0 7 1090 3726 2585 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3763  
1147 0 0 7 1091 3699 2220 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3763  
1148 0 0 7 1094 3762 2958 0 0 1 4 this 3 3763  
1149 0 0 7 1095 3735 2703 0 0 2 4 this 3 3763  5 other 1 3736  
1150 0 0 7 1095 3762 2958 0 0 2 4 this 3 3763  5 other 1 3754  
1151 0 0 7 1096 3753 2900 0 0 2 4 this 3 3763  5 other 1 3763  
1152 0 0 7 1096 3735 2703 0 0 2 4 this 3 3763  5 other 1 3736  
1153 0 0 7 1096 3762 2958 0 0 2 4 this 3 3763  5 other 1 3754  
1154 0 0 7 1097 3762 2958 0 0 2 4 this 3 3763  6 scalar 1 3518  
1155 0 0 7 1098 3762 2958 0 0 2 4 this 3 3763  6 scalar 1 3518  
1156 0 0 7 1099 3762 2958 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3763  
1157 0 0 7 1100 3762 2958 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3763  4 onto 1 3736  
1158 0 0 6 1101 3672 0 0 0 1 4 this 3 3763  
1159 0 0 7 1102 3683 0 0 0 0 
1160 0 0 7 1105 3765 2978 0 0 0 
1161 0 0 7 1105 3765 2978 0 0 1 6 param0 0 3766  
1162 0 0 7 1105 3765 2978 0 10 /**
 *
 */ 2 4 copy 1 3712  1 w 1 3521  
1163 0 0 7 1105 3765 2978 0 10 /**
 *
 */ 1 4 copy 1 3742  
1164 0 0 7 1105 3765 2978 0 10 /**
 *
 */ 1 10 fill_value 1 3521  
1165 0 0 7 1105 3765 2978 0 10 /**
 *
 */ 4 1 x 1 3521  1 y 1 3521  1 z 1 3521  1 w 1 3521  
1166 0 0 6 1106 3669 0 0 0 2 4 this 3 3766  9 attr_name 1 3672  
1167 0 0 6 1107 3524 0 0 0 3 4 this 3 3765  9 attr_name 1 3672  6 assign 1 3669  
1168 0 0 6 1108 3766 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
1169 0 0 6 1109 3766 0 0 34 /**
 * Returns a unit X point.
 */ 0 
1170 0 0 6 1110 3766 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
1171 0 0 6 1111 3766 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
1172 0 0 6 1112 3766 0 0 34 /**
 * Returns a unit W point.
 */ 0 
1173 0 0 7 1113 3729 2608 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3766  
1174 0 0 7 1114 3702 2236 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3766  
1175 0 0 7 1117 3765 2978 0 0 1 4 this 3 3766  
1176 0 0 7 1118 3741 2788 0 0 2 4 this 3 3766  5 other 1 3742  
1177 0 0 7 1118 3765 2978 0 0 2 4 this 3 3766  5 other 1 3757  
1178 0 0 7 1119 3756 2920 0 0 2 4 this 3 3766  5 other 1 3766  
1179 0 0 7 1119 3741 2788 0 0 2 4 this 3 3766  5 other 1 3742  
1180 0 0 7 1119 3765 2978 0 0 2 4 this 3 3766  5 other 1 3757  
1181 0 0 7 1120 3765 2978 0 0 2 4 this 3 3766  6 scalar 1 3521  
1182 0 0 7 1121 3765 2978 0 0 2 4 this 3 3766  6 scalar 1 3521  
1183 0 0 7 1122 3765 2978 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3766  
1184 0 0 7 1123 3765 2978 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3766  4 onto 1 3742  
1185 0 0 6 1124 3672 0 0 0 1 4 this 3 3766  
1186 0 0 7 1125 3683 0 0 0 0 
1187 0 0 7 1128 3768 2996 0 0 0 
1188 0 0 7 1128 3768 2996 0 0 1 6 param0 0 3769  
1189 0 0 7 1128 3768 2996 0 10 /**
 *
 */ 2 4 copy 1 3715  1 w 1 3524  
1190 0 0 7 1128 3768 2996 0 10 /**
 *
 */ 1 4 copy 1 3748  
1191 0 0 7 1128 3768 2996 0 10 /**
 *
 */ 1 10 fill_value 1 3524  
1192 0 0 7 1128 3768 2996 0 10 /**
 *
 */ 4 1 x 1 3524  1 y 1 3524  1 z 1 3524  1 w 1 3524  
1193 0 0 6 1129 3669 0 0 0 2 4 this 3 3769  9 attr_name 1 3672  
1194 0 0 6 1130 3524 0 0 0 3 4 this 3 3768  9 attr_name 1 3672  6 assign 1 3669  
1195 0 0 6 1131 3769 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
1196 0 0 6 1132 3769 0 0 34 /**
 * Returns a unit X point.
 */ 0 
1197 0 0 6 1133 3769 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
1198 0 0 6 1134 3769 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
1199 0 0 6 1135 3769 0 0 34 /**
 * Returns a unit W point.
 */ 0 
1200 0 0 7 1136 3732 2629 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3769  
1201 0 0 7 1137 3705 2250 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3769  
1202 0 0 7 1140 3768 2996 0 0 1 4 this 3 3769  
1203 0 0 7 1141 3747 2869 0 0 2 4 this 3 3769  5 other 1 3748  
1204 0 0 7 1141 3768 2996 0 0 2 4 this 3 3769  5 other 1 3760  
1205 0 0 7 1142 3759 2938 0 0 2 4 this 3 3769  5 other 1 3769  
1206 0 0 7 1142 3747 2869 0 0 2 4 this 3 3769  5 other 1 3748  
1207 0 0 7 1142 3768 2996 0 0 2 4 this 3 3769  5 other 1 3760  
1208 0 0 7 1143 3768 2996 0 0 2 4 this 3 3769  6 scalar 1 3524  
1209 0 0 7 1144 3768 2996 0 0 2 4 this 3 3769  6 scalar 1 3524  
1210 0 0 6 1145 3672 0 0 0 1 4 this 3 3769  
1211 0 0 7 1146 3683 0 0 0 0 
1212 0 0 7 1162 3771 3082 0 10 /**
 *
 */ 0 
1213 0 0 7 1162 3771 3082 0 10 /**
 *
 */ 1 5 other 1 3772  
1214 0 0 7 1162 3771 3082 0 60 /**
 * Constructs the matrix from three individual rows.
 */ 3 6 param0 0 3709  6 param1 0 3709  6 param2 0 3709  
1215 0 0 7 1162 3771 3082 0 10 /**
 *
 */ 9 6 param0 0 3518  6 param1 0 3518  6 param2 0 3518  6 param3 0 3518  6 param4 0 3518  6 param5 0 3518  6 param6 0 3518  6 param7 0 3518  6 param8 0 3518  
1216 0 0 6 1163 3771 0 0 10 /**
 *
 */ 2 4 this 3 3771  5 other 1 3772  
1217 0 0 6 1163 3771 0 0 10 /**
 *
 */ 2 4 this 3 3771  10 fill_value 1 3518  
1218 0 0 4 1164 3668 0 0 0 2 4 this 3 3771  4 size 1 3666  
1219 0 0 6 1167 3669 0 0 0 1 4 this 3 3772  
1220 0 0 4 1168 3668 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 3771  10 fill_value 1 3518  
1221 0 0 4 1169 3668 0 0 10 /**
 *
 */ 10 4 this 3 3771  3 e00 1 3518  3 e01 1 3518  3 e02 1 3518  3 e10 1 3518  3 e11 1 3518  3 e12 1 3518  3 e20 1 3518  3 e21 1 3518  3 e22 1 3518  
1222 0 0 7 1170 3774 3001 0 0 2 4 this 3 3771  1 i 1 3524  
1223 0 0 7 1170 3775 3006 0 0 2 4 this 3 3772  1 i 1 3524  
1224 0 0 6 1171 3524 0 0 55 /**
 * Returns 3: the number of rows of a LMatrix3.
 */ 0 
1225 0 0 4 1172 3668 0 0 109 /**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */ 3 4 this 3 3771  3 row 1 3524  1 v 1 3664  
1226 0 0 4 1172 3668 0 0 82 /**
 * Replaces the indicated row of the matrix from a three-component vector.
 */ 3 4 this 3 3771  3 row 1 3524  1 v 1 3709  
1227 0 0 4 1173 3668 0 0 109 /**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */ 3 4 this 3 3771  3 col 1 3524  1 v 1 3664  
1228 0 0 4 1173 3668 0 0 85 /**
 * Replaces the indicated column of the matrix from a three-component vector.
 */ 3 4 this 3 3771  3 col 1 3524  1 v 1 3709  
1229 0 0 4 1174 3668 0 0 78 /**
 * Stores the indicated row of the matrix as a three-component vector.
 */ 3 4 this 3 3772  10 result_vec 1 3708  3 row 1 3524  
1230 0 0 7 1174 3708 2323 0 79 /**
 * Returns the indicated row of the matrix as a three-component vector.
 */ 2 4 this 3 3772  3 row 1 3524  
1231 0 0 7 1175 3708 2323 0 82 /**
 * Returns the indicated column of the matrix as a three-component vector.
 */ 2 4 this 3 3772  3 col 1 3524  
1232 0 0 7 1180 3663 2032 0 106 /**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */ 2 4 this 3 3772  3 row 1 3524  
1233 0 0 7 1181 3663 2032 0 106 /**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */ 2 4 this 3 3772  3 col 1 3524  
1234 0 0 4 1184 3668 0 0 10 /**
 *
 */ 3 4 this 3 3771  3 row 1 3524  3 col 1 3524  
1235 0 0 6 1184 3518 0 0 0 3 4 this 3 3772  3 row 1 3524  3 col 1 3524  
1236 0 0 6 1185 3673 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3772  
1237 0 0 6 1186 3673 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 3772  
1238 0 0 6 1187 3518 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 3772  3 row 1 3524  3 col 1 3524  
1239 0 0 4 1188 3668 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 3771  3 row 1 3524  3 col 1 3524  5 value 1 3518  
1240 0 0 4 1189 3668 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3772  
1241 0 0 6 1190 3524 0 0 62 /**
 * Returns the number of elements in the matrix, nine.
 */ 1 4 this 3 3772  
1242 0 0 6 1191 3673 0 0 0 2 4 this 3 3772  5 other 1 3772  
1243 0 0 6 1192 3673 0 0 0 2 4 this 3 3772  5 other 1 3772  
1244 0 0 6 1193 3673 0 0 0 2 4 this 3 3772  5 other 1 3772  
1245 0 0 6 1194 3524 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3772  5 other 1 3772  
1246 0 0 6 1194 3524 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3772  5 other 1 3772  9 threshold 1 3518  
1247 0 0 6 1195 3666 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3772  
1248 0 0 6 1195 3666 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3772  9 threshold 1 3518  
1249 0 0 6 1196 3666 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3772  4 hash 1 3666  
1250 0 0 6 1196 3666 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3772  4 hash 1 3666  9 threshold 1 3518  
1251 0 0 7 1197 3708 2323 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3772  1 v 1 3709  
1252 0 0 7 1198 3663 2032 0 162 /**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3772  1 v 1 3664  
1253 0 0 7 1199 3663 2032 0 161 /**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3772  1 v 1 3664  
1254 0 0 7 1199 3708 2323 0 194 /**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3772  1 v 1 3709  
1255 0 0 7 1200 3708 2323 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3772  1 v 1 3709  
1256 0 0 4 1201 3668 0 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3772  1 v 1 3708  
1257 0 0 4 1202 3668 0 0 139 /**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3772  1 v 1 3663  
1258 0 0 4 1203 3668 0 0 137 /**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */ 2 4 this 3 3772  1 v 1 3663  
1259 0 0 4 1203 3668 0 0 171 /**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3772  1 v 1 3708  
1260 0 0 4 1204 3668 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 3772  1 v 1 3708  
1261 0 0 4 1205 3668 0 0 25 // this = other1 * other2 3 4 this 3 3771  6 other1 1 3772  6 other2 1 3772  
1262 0 0 7 1206 3771 3082 0 0 2 4 this 3 3772  5 other 1 3772  
1263 0 0 7 1206 3771 3082 0 0 2 4 this 3 3772  6 scalar 1 3518  
1264 0 0 7 1207 3771 3082 0 0 2 4 this 3 3772  6 scalar 1 3518  
1265 0 0 6 1208 3771 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3771  5 other 1 3772  
1266 0 0 6 1209 3771 0 0 66 /**
 * Performs a memberwise subtraction between two matrices.
 */ 2 4 this 3 3771  5 other 1 3772  
1267 0 0 6 1210 3771 0 0 10 /**
 *
 */ 2 4 this 3 3771  5 other 1 3772  
1268 0 0 6 1210 3771 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3771  6 scalar 1 3518  
1269 0 0 6 1211 3771 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3771  6 scalar 1 3518  
1270 0 0 4 1212 3668 0 0 10 /**
 *
 */ 2 4 this 3 3771  5 other 1 3772  
1271 0 0 6 1213 3518 0 0 49 /**
 * Returns the determinant of the matrix.
 */ 1 4 this 3 3772  
1272 0 0 4 1214 3668 0 0 10 /**
 *
 */ 2 4 this 3 3771  5 other 1 3772  
1273 0 0 4 1215 3668 0 0 10 /**
 *
 */ 1 4 this 3 3771  
1274 0 0 6 1216 3673 0 0 463 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3771  5 other 1 3772  
1275 0 0 6 1217 3673 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 3771  
1276 0 0 6 1218 3673 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3771  5 other 1 3772  
1277 0 0 6 1218 3673 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3771  5 other 1 3776  
1278 0 0 6 1219 3772 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1279 0 0 4 1220 3668 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 3771  5 trans 1 3664  
1280 0 0 4 1221 3668 0 0 98 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 2 4 this 3 3771  5 angle 1 3518  
1281 0 0 4 1221 3668 0 0 125 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 3771  5 angle 1 3518  4 axis 1 3709  2 cs 1 3537  
1282 0 0 4 1222 3668 0 0 95 /**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */ 2 4 this 3 3771  5 scale 1 3664  
1283 0 0 4 1222 3668 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 3771  5 scale 1 3709  
1284 0 0 7 1223 3771 3082 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3664  
1285 0 0 7 1223 3771 3082 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 2 2 tx 1 3518  2 ty 1 3518  
1286 0 0 7 1224 3771 3082 0 91 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 1 5 angle 1 3518  
1287 0 0 7 1224 3771 3082 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3518  4 axis 1 3709  2 cs 1 3537  
1288 0 0 7 1225 3771 3082 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 1 5 scale 1 3664  
1289 0 0 7 1225 3771 3082 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3709  
1290 0 0 7 1225 3771 3082 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 2 2 sx 1 3518  2 sy 1 3518  
1291 0 0 7 1225 3771 3082 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3518  2 sy 1 3518  2 sz 1 3518  
1292 0 0 4 1226 3668 0 0 163 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 4 4 this 3 3771  5 angle 1 3518  4 axis 1 3709  2 cs 1 3537  
1293 0 0 7 1227 3771 3082 0 156 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 3 5 angle 1 3518  4 axis 1 3709  2 cs 1 3537  
1294 0 0 4 1228 3668 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 3771  5 shear 1 3709  2 cs 1 3537  
1295 0 0 7 1229 3771 3082 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3709  2 cs 1 3537  
1296 0 0 7 1229 3771 3082 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3518  4 shxz 1 3518  4 shyz 1 3518  2 cs 1 3537  
1297 0 0 4 1230 3668 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 3771  5 scale 1 3709  5 shear 1 3709  2 cs 1 3537  
1298 0 0 7 1231 3771 3082 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3709  5 shear 1 3709  2 cs 1 3537  
1299 0 0 7 1231 3771 3082 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3518  2 sy 1 3518  2 sz 1 3518  4 shxy 1 3518  4 shxz 1 3518  4 shyz 1 3518  2 cs 1 3537  
1300 0 0 6 1232 3772 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3537  2 to 1 3537  
1301 0 0 6 1233 3673 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3772  5 other 1 3772  
1302 0 0 6 1233 3673 0 0 93 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3772  5 other 1 3772  9 threshold 1 3518  
1303 0 0 4 1234 3668 0 0 10 /**
 *
 */ 2 4 this 3 3772  3 out 1 3676  
1304 0 0 4 1235 3668 0 0 10 /**
 *
 */ 3 4 this 3 3772  3 out 1 3676  12 indent_level 1 3524  
1305 0 0 6 1236 3672 0 0 0 1 4 this 3 3772  
1306 0 0 4 1237 3668 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3772  7 hashgen 1 3674  
1307 0 0 4 1237 3668 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3772  7 hashgen 1 3674  9 threshold 1 3518  
1308 0 0 4 1238 3668 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3772  11 destination 1 3678  
1309 0 0 4 1239 3668 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3771  4 scan 1 3680  
1310 0 0 4 1240 3668 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3772  11 destination 1 3678  
1311 0 0 4 1241 3668 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 3771  6 source 1 3680  
1312 0 0 7 1242 3683 0 0 0 0 
1313 0 0 7 1154 3774 3001 0 0 1 6 param0 0 3778  
1314 0 0 4 1151 3668 0 0 10 /**
 *
 */ 3 4 this 3 3774  1 i 1 3524  10 assign_val 1 3518  
1315 0 0 6 1151 3518 0 0 0 2 4 this 3 3778  1 i 1 3524  
1316 0 0 6 1152 3524 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1317 0 0 6 1153 3709 0 0 0 1 4 this 3 3778  
1318 0 0 7 1160 3775 3006 0 0 1 6 param0 0 3780  
1319 0 0 6 1157 3518 0 0 0 2 4 this 3 3780  1 i 1 3524  
1320 0 0 6 1158 3524 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1321 0 0 6 1159 3709 0 0 0 1 4 this 3 3780  
1322 0 0 7 1260 3782 3180 0 10 /**
 *
 */ 0 
1323 0 0 7 1260 3782 3180 0 95 // Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component. 1 6 upper3 1 3772  
1324 0 0 7 1260 3782 3180 0 10 /**
 *
 */ 2 6 upper3 1 3772  5 trans 1 3709  
1325 0 0 7 1260 3782 3180 0 10 /**
 *
 */ 1 5 other 1 3776  
1326 0 0 7 1260 3782 3180 0 59 /**
 * Constructs the matrix from four individual rows.
 */ 4 6 param0 0 3736  6 param1 0 3736  6 param2 0 3736  6 param3 0 3736  
1327 0 0 7 1260 3782 3180 0 10 /**
 *
 */ 1 5 other 1 3783  
1328 0 0 7 1260 3782 3180 0 10 /**
 *
 */ 16 6 param0 0 3518  6 param1 0 3518  6 param2 0 3518  6 param3 0 3518  6 param4 0 3518  6 param5 0 3518  6 param6 0 3518  6 param7 0 3518  6 param8 0 3518  6 param9 0 3518  7 param10 0 3518  7 param11 0 3518  7 param12 0 3518  7 param13 0 3518  7 param14 0 3518  7 param15 0 3518  
1329 0 0 6 1261 3782 0 0 10 /**
 *
 */ 2 4 this 3 3782  5 other 1 3776  
1330 0 0 6 1261 3782 0 0 10 /**
 *
 */ 2 4 this 3 3782  5 other 1 3783  
1331 0 0 6 1261 3782 0 0 10 /**
 *
 */ 2 4 this 3 3782  10 fill_value 1 3518  
1332 0 0 4 1262 3668 0 0 0 2 4 this 3 3782  4 size 1 3666  
1333 0 0 6 1265 3669 0 0 0 1 4 this 3 3776  
1334 0 0 4 1266 3668 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 3782  10 fill_value 1 3518  
1335 0 0 4 1267 3668 0 0 10 /**
 *
 */ 17 4 this 3 3782  3 e00 1 3518  3 e01 1 3518  3 e02 1 3518  3 e03 1 3518  3 e10 1 3518  3 e11 1 3518  3 e12 1 3518  3 e13 1 3518  3 e20 1 3518  3 e21 1 3518  3 e22 1 3518  3 e23 1 3518  3 e30 1 3518  3 e31 1 3518  3 e32 1 3518  3 e33 1 3518  
1336 0 0 4 1268 3668 0 0 45 // Get and set the upper 3x3 rotation matrix. 2 4 this 3 3782  6 upper3 1 3772  
1337 0 0 7 1269 3771 3082 0 45 /**
 * Retrieves the upper 3x3 submatrix.
 */ 1 4 this 3 3776  
1338 0 0 7 1270 3785 3089 0 0 2 4 this 3 3782  1 i 1 3524  
1339 0 0 7 1270 3786 3094 0 0 2 4 this 3 3776  1 i 1 3524  
1340 0 0 6 1271 3524 0 0 55 /**
 * Returns 4: the number of rows of a LMatrix4.
 */ 0 
1341 0 0 4 1272 3668 0 0 119 /**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */ 3 4 this 3 3782  3 row 1 3524  1 v 1 3709  
1342 0 0 4 1272 3668 0 0 52 /**
 * Replaces the indicated row of the matrix.
 */ 3 4 this 3 3782  3 row 1 3524  1 v 1 3736  
1343 0 0 4 1273 3668 0 0 119 /**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */ 3 4 this 3 3782  3 col 1 3524  1 v 1 3709  
1344 0 0 4 1273 3668 0 0 55 /**
 * Replaces the indicated column of the matrix.
 */ 3 4 this 3 3782  3 col 1 3524  1 v 1 3736  
1345 0 0 4 1274 3668 0 0 74 /**
 * Stores the indicated row of the matrix as a 4-component vector.
 */ 3 4 this 3 3776  10 result_vec 1 3735  3 row 1 3524  
1346 0 0 7 1274 3735 2703 0 77 /**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */ 2 4 this 3 3776  3 row 1 3524  
1347 0 0 7 1275 3735 2703 0 80 /**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */ 2 4 this 3 3776  3 col 1 3524  
1348 0 0 4 1276 3668 0 0 100 /**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */ 3 4 this 3 3776  10 result_vec 1 3708  3 row 1 3524  
1349 0 0 7 1276 3708 2323 0 103 /**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */ 2 4 this 3 3776  3 row 1 3524  
1350 0 0 7 1282 3708 2323 0 106 /**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */ 2 4 this 3 3776  3 col 1 3524  
1351 0 0 4 1283 3668 0 0 10 /**
 *
 */ 3 4 this 3 3782  3 row 1 3524  3 col 1 3524  
1352 0 0 6 1283 3518 0 0 0 3 4 this 3 3776  3 row 1 3524  3 col 1 3524  
1353 0 0 6 1284 3673 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3776  
1354 0 0 6 1285 3673 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 3776  
1355 0 0 6 1286 3518 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 3776  3 row 1 3524  3 col 1 3524  
1356 0 0 4 1287 3668 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 3782  3 row 1 3524  3 col 1 3524  5 value 1 3518  
1357 0 0 4 1288 3668 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3776  
1358 0 0 6 1289 3524 0 0 60 /**
 * Returns the number of elements in the matrix, 16.
 */ 1 4 this 3 3776  
1359 0 0 4 1290 3668 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3782  
1360 0 0 4 1290 3668 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3776  
1361 0 0 4 1291 3668 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3782  
1362 0 0 4 1291 3668 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3776  
1363 0 0 6 1292 3673 0 0 0 2 4 this 3 3776  5 other 1 3776  
1364 0 0 6 1293 3673 0 0 0 2 4 this 3 3776  5 other 1 3776  
1365 0 0 6 1294 3673 0 0 0 2 4 this 3 3776  5 other 1 3776  
1366 0 0 6 1295 3524 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3776  5 other 1 3776  
1367 0 0 6 1295 3524 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3776  5 other 1 3776  9 threshold 1 3518  
1368 0 0 6 1296 3666 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3776  
1369 0 0 6 1296 3666 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3776  9 threshold 1 3518  
1370 0 0 6 1297 3666 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3776  4 hash 1 3666  
1371 0 0 6 1297 3666 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3776  4 hash 1 3666  9 threshold 1 3518  
1372 0 0 7 1298 3735 2703 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 3776  1 v 1 3736  
1373 0 0 7 1299 3708 2323 0 162 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3776  1 v 1 3709  
1374 0 0 7 1300 3708 2323 0 143 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3776  1 v 1 3709  
1375 0 0 7 1301 3708 2323 0 169 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */ 2 4 this 3 3776  1 v 1 3709  
1376 0 0 7 1302 3708 2323 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3776  1 v 1 3709  
1377 0 0 4 1303 3668 0 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 3776  1 v 1 3735  
1378 0 0 4 1304 3668 0 0 139 /**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3776  1 v 1 3708  
1379 0 0 4 1305 3668 0 0 120 /**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */ 2 4 this 3 3776  1 v 1 3708  
1380 0 0 4 1306 3668 0 0 142 /**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */ 2 4 this 3 3776  1 v 1 3708  
1381 0 0 4 1307 3668 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 3776  1 v 1 3708  
1382 0 0 4 1308 3668 0 0 25 // this = other1 * other2 3 4 this 3 3782  6 other1 1 3776  6 other2 1 3776  
1383 0 0 7 1309 3782 3180 0 0 2 4 this 3 3776  5 other 1 3776  
1384 0 0 7 1309 3782 3180 0 0 2 4 this 3 3776  6 scalar 1 3518  
1385 0 0 7 1310 3782 3180 0 0 2 4 this 3 3776  6 scalar 1 3518  
1386 0 0 6 1311 3782 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3782  5 other 1 3776  
1387 0 0 6 1312 3782 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3782  5 other 1 3776  
1388 0 0 6 1313 3782 0 0 10 /**
 *
 */ 2 4 this 3 3782  5 other 1 3776  
1389 0 0 6 1313 3782 0 0 10 /**
 *
 */ 2 4 this 3 3782  6 scalar 1 3518  
1390 0 0 6 1314 3782 0 0 10 /**
 *
 */ 2 4 this 3 3782  6 scalar 1 3518  
1391 0 0 4 1315 3668 0 0 10 /**
 *
 */ 2 4 this 3 3782  5 other 1 3776  
1392 0 0 4 1316 3668 0 0 10 /**
 *
 */ 2 4 this 3 3782  5 other 1 3776  
1393 0 0 4 1317 3668 0 0 10 /**
 *
 */ 1 4 this 3 3782  
1394 0 0 6 1318 3673 0 0 461 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */ 2 4 this 3 3782  5 other 1 3776  
1395 0 0 6 1319 3673 0 0 139 // bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component) 2 4 this 3 3782  5 other 1 3776  
1396 0 0 6 1320 3673 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 3782  
1397 0 0 4 1321 3668 0 0 46 /**
 * Computes (*this) += other * weight.
 */ 3 4 this 3 3782  5 other 1 3776  6 weight 1 3518  
1398 0 0 6 1322 3776 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1399 0 0 6 1323 3776 0 0 46 /**
 * Returns an matrix filled with ones.
 */ 0 
1400 0 0 6 1324 3776 0 0 47 /**
 * Returns an matrix filled with zeros.
 */ 0 
1401 0 0 4 1325 3668 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 3782  5 trans 1 3709  
1402 0 0 4 1326 3668 0 0 122 /**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 3782  5 angle 1 3518  4 axis 1 3709  2 cs 1 3537  
1403 0 0 4 1327 3668 0 0 166 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 4 4 this 3 3782  5 angle 1 3518  4 axis 1 3709  2 cs 1 3537  
1404 0 0 4 1328 3668 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 3782  5 scale 1 3709  
1405 0 0 4 1329 3668 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 3782  5 shear 1 3709  2 cs 1 3537  
1406 0 0 4 1330 3668 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 3782  5 scale 1 3709  5 shear 1 3709  2 cs 1 3537  
1407 0 0 7 1331 3782 3180 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3709  
1408 0 0 7 1331 3782 3180 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 3 2 tx 1 3518  2 ty 1 3518  2 tz 1 3518  
1409 0 0 7 1332 3782 3180 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3518  4 axis 1 3709  2 cs 1 3537  
1410 0 0 7 1333 3782 3180 0 159 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 3 5 angle 1 3518  4 axis 1 3709  2 cs 1 3537  
1411 0 0 7 1334 3782 3180 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3709  
1412 0 0 7 1334 3782 3180 0 69 /**
 * Returns a matrix that applies the indicated uniform scale.
 */ 1 5 scale 1 3518  
1413 0 0 7 1334 3782 3180 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3518  2 sy 1 3518  2 sz 1 3518  
1414 0 0 7 1335 3782 3180 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3709  2 cs 1 3537  
1415 0 0 7 1335 3782 3180 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3518  4 shxz 1 3518  4 shyz 1 3518  2 cs 1 3537  
1416 0 0 7 1336 3782 3180 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3709  5 shear 1 3709  2 cs 1 3537  
1417 0 0 7 1336 3782 3180 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3518  2 sy 1 3518  2 sz 1 3518  4 shxy 1 3518  4 shxz 1 3518  4 shyz 1 3518  2 cs 1 3537  
1418 0 0 6 1337 3776 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1419 0 0 6 1338 3776 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1420 0 0 6 1339 3776 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3537  2 to 1 3537  
1421 0 0 6 1340 3673 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3776  5 other 1 3776  
1422 0 0 6 1340 3673 0 0 199 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */ 3 4 this 3 3776  5 other 1 3776  9 threshold 1 3518  
1423 0 0 4 1341 3668 0 0 10 /**
 *
 */ 2 4 this 3 3776  3 out 1 3676  
1424 0 0 4 1342 3668 0 0 10 /**
 *
 */ 3 4 this 3 3776  3 out 1 3676  12 indent_level 1 3524  
1425 0 0 6 1343 3672 0 0 0 1 4 this 3 3776  
1426 0 0 4 1344 3668 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3776  7 hashgen 1 3674  
1427 0 0 4 1344 3668 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3776  7 hashgen 1 3674  5 scale 1 3518  
1428 0 0 4 1345 3668 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3776  11 destination 1 3678  
1429 0 0 4 1346 3668 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3782  4 scan 1 3680  
1430 0 0 4 1347 3668 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3776  11 destination 1 3678  
1431 0 0 4 1348 3668 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 3782  6 source 1 3680  
1432 0 0 7 1349 3683 0 0 0 0 
1433 0 0 7 1252 3785 3089 0 0 1 6 param0 0 3787  
1434 0 0 4 1249 3668 0 0 10 /**
 *
 */ 3 4 this 3 3785  1 i 1 3524  10 assign_val 1 3518  
1435 0 0 6 1249 3518 0 0 0 2 4 this 3 3787  1 i 1 3524  
1436 0 0 6 1250 3524 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1437 0 0 6 1251 3736 0 0 0 1 4 this 3 3787  
1438 0 0 7 1258 3786 3094 0 0 1 6 param0 0 3789  
1439 0 0 6 1255 3518 0 0 0 2 4 this 3 3789  1 i 1 3524  
1440 0 0 6 1256 3524 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1441 0 0 6 1257 3736 0 0 0 1 4 this 3 3789  
1442 0 0 7 1353 3791 3190 0 10 /**
 *
 */ 0 
1443 0 0 7 1353 3791 3190 0 10 /**
 *
 */ 1 4 copy 1 3776  
1444 0 0 7 1353 3791 3190 0 10 /**
 *
 */ 1 4 copy 1 3783  
1445 0 0 7 1353 3791 3190 0 10 /**
 *
 */ 16 3 e00 1 3518  3 e01 1 3518  3 e02 1 3518  3 e03 1 3518  3 e10 1 3518  3 e11 1 3518  3 e12 1 3518  3 e13 1 3518  3 e20 1 3518  3 e21 1 3518  3 e22 1 3518  3 e23 1 3518  3 e30 1 3518  3 e31 1 3518  3 e32 1 3518  3 e33 1 3518  
1446 0 0 6 1354 3791 0 0 10 /**
 *
 */ 2 4 this 3 3791  4 copy 1 3776  
1447 0 0 6 1354 3791 0 0 10 /**
 *
 */ 2 4 this 3 3791  4 copy 1 3783  
1448 0 0 4 1355 3668 0 0 10 /**
 *
 */ 17 4 this 3 3791  3 e00 1 3518  3 e01 1 3518  3 e02 1 3518  3 e03 1 3518  3 e10 1 3518  3 e11 1 3518  3 e12 1 3518  3 e13 1 3518  3 e20 1 3518  3 e21 1 3518  3 e22 1 3518  3 e23 1 3518  3 e30 1 3518  3 e31 1 3518  3 e32 1 3518  3 e33 1 3518  
1449 0 0 4 1356 3668 0 0 10 /**
 *
 */ 3 4 this 3 3791  3 row 1 3524  3 col 1 3524  
1450 0 0 6 1356 3518 0 0 0 3 4 this 3 3783  3 row 1 3524  3 col 1 3524  
1451 0 0 4 1357 3668 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3783  
1452 0 0 6 1358 3524 0 0 65 /**
 * Returns the number of elements in the matrix, sixteen.
 */ 1 4 this 3 3783  
1453 0 0 6 1359 3673 0 0 0 2 4 this 3 3783  5 other 1 3783  
1454 0 0 6 1360 3673 0 0 0 2 4 this 3 3783  5 other 1 3783  
1455 0 0 7 1361 3683 0 0 0 0 
1456 0 0 7 1377 3792 3276 0 10 /**
 *
 */ 0 
1457 0 0 7 1377 3792 3276 0 10 /**
 *
 */ 1 5 other 1 3793  
1458 0 0 7 1377 3792 3276 0 60 /**
 * Constructs the matrix from three individual rows.
 */ 3 6 param0 0 3712  6 param1 0 3712  6 param2 0 3712  
1459 0 0 7 1377 3792 3276 0 10 /**
 *
 */ 9 6 param0 0 3521  6 param1 0 3521  6 param2 0 3521  6 param3 0 3521  6 param4 0 3521  6 param5 0 3521  6 param6 0 3521  6 param7 0 3521  6 param8 0 3521  
1460 0 0 6 1378 3792 0 0 10 /**
 *
 */ 2 4 this 3 3792  5 other 1 3793  
1461 0 0 6 1378 3792 0 0 10 /**
 *
 */ 2 4 this 3 3792  10 fill_value 1 3521  
1462 0 0 4 1379 3668 0 0 0 2 4 this 3 3792  4 size 1 3666  
1463 0 0 6 1382 3669 0 0 0 1 4 this 3 3793  
1464 0 0 4 1383 3668 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 3792  10 fill_value 1 3521  
1465 0 0 4 1384 3668 0 0 10 /**
 *
 */ 10 4 this 3 3792  3 e00 1 3521  3 e01 1 3521  3 e02 1 3521  3 e10 1 3521  3 e11 1 3521  3 e12 1 3521  3 e20 1 3521  3 e21 1 3521  3 e22 1 3521  
1466 0 0 7 1385 3795 3195 0 0 2 4 this 3 3792  1 i 1 3524  
1467 0 0 7 1385 3796 3200 0 0 2 4 this 3 3793  1 i 1 3524  
1468 0 0 6 1386 3524 0 0 55 /**
 * Returns 3: the number of rows of a LMatrix3.
 */ 0 
1469 0 0 4 1387 3668 0 0 109 /**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */ 3 4 this 3 3792  3 row 1 3524  1 v 1 3685  
1470 0 0 4 1387 3668 0 0 82 /**
 * Replaces the indicated row of the matrix from a three-component vector.
 */ 3 4 this 3 3792  3 row 1 3524  1 v 1 3712  
1471 0 0 4 1388 3668 0 0 109 /**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */ 3 4 this 3 3792  3 col 1 3524  1 v 1 3685  
1472 0 0 4 1388 3668 0 0 85 /**
 * Replaces the indicated column of the matrix from a three-component vector.
 */ 3 4 this 3 3792  3 col 1 3524  1 v 1 3712  
1473 0 0 4 1389 3668 0 0 78 /**
 * Stores the indicated row of the matrix as a three-component vector.
 */ 3 4 this 3 3793  10 result_vec 1 3711  3 row 1 3524  
1474 0 0 7 1389 3711 2396 0 79 /**
 * Returns the indicated row of the matrix as a three-component vector.
 */ 2 4 this 3 3793  3 row 1 3524  
1475 0 0 7 1390 3711 2396 0 82 /**
 * Returns the indicated column of the matrix as a three-component vector.
 */ 2 4 this 3 3793  3 col 1 3524  
1476 0 0 7 1395 3684 2095 0 106 /**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */ 2 4 this 3 3793  3 row 1 3524  
1477 0 0 7 1396 3684 2095 0 106 /**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */ 2 4 this 3 3793  3 col 1 3524  
1478 0 0 4 1399 3668 0 0 10 /**
 *
 */ 3 4 this 3 3792  3 row 1 3524  3 col 1 3524  
1479 0 0 6 1399 3521 0 0 0 3 4 this 3 3793  3 row 1 3524  3 col 1 3524  
1480 0 0 6 1400 3673 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3793  
1481 0 0 6 1401 3673 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 3793  
1482 0 0 6 1402 3521 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 3793  3 row 1 3524  3 col 1 3524  
1483 0 0 4 1403 3668 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 3792  3 row 1 3524  3 col 1 3524  5 value 1 3521  
1484 0 0 4 1404 3668 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3793  
1485 0 0 6 1405 3524 0 0 62 /**
 * Returns the number of elements in the matrix, nine.
 */ 1 4 this 3 3793  
1486 0 0 6 1406 3673 0 0 0 2 4 this 3 3793  5 other 1 3793  
1487 0 0 6 1407 3673 0 0 0 2 4 this 3 3793  5 other 1 3793  
1488 0 0 6 1408 3673 0 0 0 2 4 this 3 3793  5 other 1 3793  
1489 0 0 6 1409 3524 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3793  5 other 1 3793  
1490 0 0 6 1409 3524 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3793  5 other 1 3793  9 threshold 1 3521  
1491 0 0 6 1410 3666 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3793  
1492 0 0 6 1410 3666 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3793  9 threshold 1 3521  
1493 0 0 6 1411 3666 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3793  4 hash 1 3666  
1494 0 0 6 1411 3666 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3793  4 hash 1 3666  9 threshold 1 3521  
1495 0 0 7 1412 3711 2396 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3793  1 v 1 3712  
1496 0 0 7 1413 3684 2095 0 162 /**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3793  1 v 1 3685  
1497 0 0 7 1414 3684 2095 0 161 /**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3793  1 v 1 3685  
1498 0 0 7 1414 3711 2396 0 194 /**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3793  1 v 1 3712  
1499 0 0 7 1415 3711 2396 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3793  1 v 1 3712  
1500 0 0 4 1416 3668 0 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3793  1 v 1 3711  
1501 0 0 4 1417 3668 0 0 139 /**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3793  1 v 1 3684  
1502 0 0 4 1418 3668 0 0 137 /**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */ 2 4 this 3 3793  1 v 1 3684  
1503 0 0 4 1418 3668 0 0 171 /**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3793  1 v 1 3711  
1504 0 0 4 1419 3668 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 3793  1 v 1 3711  
1505 0 0 4 1420 3668 0 0 25 // this = other1 * other2 3 4 this 3 3792  6 other1 1 3793  6 other2 1 3793  
1506 0 0 7 1421 3792 3276 0 0 2 4 this 3 3793  5 other 1 3793  
1507 0 0 7 1421 3792 3276 0 0 2 4 this 3 3793  6 scalar 1 3521  
1508 0 0 7 1422 3792 3276 0 0 2 4 this 3 3793  6 scalar 1 3521  
1509 0 0 6 1423 3792 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3792  5 other 1 3793  
1510 0 0 6 1424 3792 0 0 66 /**
 * Performs a memberwise subtraction between two matrices.
 */ 2 4 this 3 3792  5 other 1 3793  
1511 0 0 6 1425 3792 0 0 10 /**
 *
 */ 2 4 this 3 3792  5 other 1 3793  
1512 0 0 6 1425 3792 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3792  6 scalar 1 3521  
1513 0 0 6 1426 3792 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3792  6 scalar 1 3521  
1514 0 0 4 1427 3668 0 0 10 /**
 *
 */ 2 4 this 3 3792  5 other 1 3793  
1515 0 0 6 1428 3521 0 0 49 /**
 * Returns the determinant of the matrix.
 */ 1 4 this 3 3793  
1516 0 0 4 1429 3668 0 0 10 /**
 *
 */ 2 4 this 3 3792  5 other 1 3793  
1517 0 0 4 1430 3668 0 0 10 /**
 *
 */ 1 4 this 3 3792  
1518 0 0 6 1431 3673 0 0 463 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3792  5 other 1 3793  
1519 0 0 6 1432 3673 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 3792  
1520 0 0 6 1433 3673 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3792  5 other 1 3793  
1521 0 0 6 1433 3673 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3792  5 other 1 3797  
1522 0 0 6 1434 3793 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1523 0 0 4 1435 3668 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 3792  5 trans 1 3685  
1524 0 0 4 1436 3668 0 0 98 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 2 4 this 3 3792  5 angle 1 3521  
1525 0 0 4 1436 3668 0 0 125 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 3792  5 angle 1 3521  4 axis 1 3712  2 cs 1 3537  
1526 0 0 4 1437 3668 0 0 95 /**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */ 2 4 this 3 3792  5 scale 1 3685  
1527 0 0 4 1437 3668 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 3792  5 scale 1 3712  
1528 0 0 7 1438 3792 3276 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3685  
1529 0 0 7 1438 3792 3276 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 2 2 tx 1 3521  2 ty 1 3521  
1530 0 0 7 1439 3792 3276 0 91 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 1 5 angle 1 3521  
1531 0 0 7 1439 3792 3276 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3521  4 axis 1 3712  2 cs 1 3537  
1532 0 0 7 1440 3792 3276 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 1 5 scale 1 3685  
1533 0 0 7 1440 3792 3276 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3712  
1534 0 0 7 1440 3792 3276 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 2 2 sx 1 3521  2 sy 1 3521  
1535 0 0 7 1440 3792 3276 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3521  2 sy 1 3521  2 sz 1 3521  
1536 0 0 4 1441 3668 0 0 163 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 4 4 this 3 3792  5 angle 1 3521  4 axis 1 3712  2 cs 1 3537  
1537 0 0 7 1442 3792 3276 0 156 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 3 5 angle 1 3521  4 axis 1 3712  2 cs 1 3537  
1538 0 0 4 1443 3668 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 3792  5 shear 1 3712  2 cs 1 3537  
1539 0 0 7 1444 3792 3276 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3712  2 cs 1 3537  
1540 0 0 7 1444 3792 3276 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3521  4 shxz 1 3521  4 shyz 1 3521  2 cs 1 3537  
1541 0 0 4 1445 3668 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 3792  5 scale 1 3712  5 shear 1 3712  2 cs 1 3537  
1542 0 0 7 1446 3792 3276 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3712  5 shear 1 3712  2 cs 1 3537  
1543 0 0 7 1446 3792 3276 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3521  2 sy 1 3521  2 sz 1 3521  4 shxy 1 3521  4 shxz 1 3521  4 shyz 1 3521  2 cs 1 3537  
1544 0 0 6 1447 3793 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3537  2 to 1 3537  
1545 0 0 6 1448 3673 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3793  5 other 1 3793  
1546 0 0 6 1448 3673 0 0 93 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3793  5 other 1 3793  9 threshold 1 3521  
1547 0 0 4 1449 3668 0 0 10 /**
 *
 */ 2 4 this 3 3793  3 out 1 3676  
1548 0 0 4 1450 3668 0 0 10 /**
 *
 */ 3 4 this 3 3793  3 out 1 3676  12 indent_level 1 3524  
1549 0 0 6 1451 3672 0 0 0 1 4 this 3 3793  
1550 0 0 4 1452 3668 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3793  7 hashgen 1 3674  
1551 0 0 4 1452 3668 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3793  7 hashgen 1 3674  9 threshold 1 3521  
1552 0 0 4 1453 3668 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3793  11 destination 1 3678  
1553 0 0 4 1454 3668 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3792  4 scan 1 3680  
1554 0 0 4 1455 3668 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3793  11 destination 1 3678  
1555 0 0 4 1456 3668 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 3792  6 source 1 3680  
1556 0 0 7 1457 3683 0 0 0 0 
1557 0 0 7 1369 3795 3195 0 0 1 6 param0 0 3799  
1558 0 0 4 1366 3668 0 0 10 /**
 *
 */ 3 4 this 3 3795  1 i 1 3524  10 assign_val 1 3521  
1559 0 0 6 1366 3521 0 0 0 2 4 this 3 3799  1 i 1 3524  
1560 0 0 6 1367 3524 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1561 0 0 6 1368 3712 0 0 0 1 4 this 3 3799  
1562 0 0 7 1375 3796 3200 0 0 1 6 param0 0 3801  
1563 0 0 6 1372 3521 0 0 0 2 4 this 3 3801  1 i 1 3524  
1564 0 0 6 1373 3524 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1565 0 0 6 1374 3712 0 0 0 1 4 this 3 3801  
1566 0 0 7 1473 3803 3372 0 10 /**
 *
 */ 0 
1567 0 0 7 1473 3803 3372 0 95 // Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component. 1 6 upper3 1 3793  
1568 0 0 7 1473 3803 3372 0 10 /**
 *
 */ 2 6 upper3 1 3793  5 trans 1 3712  
1569 0 0 7 1473 3803 3372 0 10 /**
 *
 */ 1 5 other 1 3797  
1570 0 0 7 1473 3803 3372 0 59 /**
 * Constructs the matrix from four individual rows.
 */ 4 6 param0 0 3742  6 param1 0 3742  6 param2 0 3742  6 param3 0 3742  
1571 0 0 7 1473 3803 3372 0 10 /**
 *
 */ 1 5 other 1 3804  
1572 0 0 7 1473 3803 3372 0 10 /**
 *
 */ 16 6 param0 0 3521  6 param1 0 3521  6 param2 0 3521  6 param3 0 3521  6 param4 0 3521  6 param5 0 3521  6 param6 0 3521  6 param7 0 3521  6 param8 0 3521  6 param9 0 3521  7 param10 0 3521  7 param11 0 3521  7 param12 0 3521  7 param13 0 3521  7 param14 0 3521  7 param15 0 3521  
1573 0 0 6 1474 3803 0 0 10 /**
 *
 */ 2 4 this 3 3803  5 other 1 3797  
1574 0 0 6 1474 3803 0 0 10 /**
 *
 */ 2 4 this 3 3803  5 other 1 3804  
1575 0 0 6 1474 3803 0 0 10 /**
 *
 */ 2 4 this 3 3803  10 fill_value 1 3521  
1576 0 0 4 1475 3668 0 0 0 2 4 this 3 3803  4 size 1 3666  
1577 0 0 6 1478 3669 0 0 0 1 4 this 3 3797  
1578 0 0 4 1479 3668 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 3803  10 fill_value 1 3521  
1579 0 0 4 1480 3668 0 0 10 /**
 *
 */ 17 4 this 3 3803  3 e00 1 3521  3 e01 1 3521  3 e02 1 3521  3 e03 1 3521  3 e10 1 3521  3 e11 1 3521  3 e12 1 3521  3 e13 1 3521  3 e20 1 3521  3 e21 1 3521  3 e22 1 3521  3 e23 1 3521  3 e30 1 3521  3 e31 1 3521  3 e32 1 3521  3 e33 1 3521  
1580 0 0 4 1481 3668 0 0 45 // Get and set the upper 3x3 rotation matrix. 2 4 this 3 3803  6 upper3 1 3793  
1581 0 0 7 1482 3792 3276 0 45 /**
 * Retrieves the upper 3x3 submatrix.
 */ 1 4 this 3 3797  
1582 0 0 7 1483 3806 3281 0 0 2 4 this 3 3803  1 i 1 3524  
1583 0 0 7 1483 3807 3286 0 0 2 4 this 3 3797  1 i 1 3524  
1584 0 0 6 1484 3524 0 0 55 /**
 * Returns 4: the number of rows of a LMatrix4.
 */ 0 
1585 0 0 4 1485 3668 0 0 119 /**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */ 3 4 this 3 3803  3 row 1 3524  1 v 1 3712  
1586 0 0 4 1485 3668 0 0 52 /**
 * Replaces the indicated row of the matrix.
 */ 3 4 this 3 3803  3 row 1 3524  1 v 1 3742  
1587 0 0 4 1486 3668 0 0 119 /**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */ 3 4 this 3 3803  3 col 1 3524  1 v 1 3712  
1588 0 0 4 1486 3668 0 0 55 /**
 * Replaces the indicated column of the matrix.
 */ 3 4 this 3 3803  3 col 1 3524  1 v 1 3742  
1589 0 0 4 1487 3668 0 0 74 /**
 * Stores the indicated row of the matrix as a 4-component vector.
 */ 3 4 this 3 3797  10 result_vec 1 3741  3 row 1 3524  
1590 0 0 7 1487 3741 2788 0 77 /**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */ 2 4 this 3 3797  3 row 1 3524  
1591 0 0 7 1488 3741 2788 0 80 /**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */ 2 4 this 3 3797  3 col 1 3524  
1592 0 0 4 1489 3668 0 0 100 /**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */ 3 4 this 3 3797  10 result_vec 1 3711  3 row 1 3524  
1593 0 0 7 1489 3711 2396 0 103 /**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */ 2 4 this 3 3797  3 row 1 3524  
1594 0 0 7 1495 3711 2396 0 106 /**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */ 2 4 this 3 3797  3 col 1 3524  
1595 0 0 4 1496 3668 0 0 10 /**
 *
 */ 3 4 this 3 3803  3 row 1 3524  3 col 1 3524  
1596 0 0 6 1496 3521 0 0 0 3 4 this 3 3797  3 row 1 3524  3 col 1 3524  
1597 0 0 6 1497 3673 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3797  
1598 0 0 6 1498 3673 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 3797  
1599 0 0 6 1499 3521 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 3797  3 row 1 3524  3 col 1 3524  
1600 0 0 4 1500 3668 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 3803  3 row 1 3524  3 col 1 3524  5 value 1 3521  
1601 0 0 4 1501 3668 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3797  
1602 0 0 6 1502 3524 0 0 60 /**
 * Returns the number of elements in the matrix, 16.
 */ 1 4 this 3 3797  
1603 0 0 4 1503 3668 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3803  
1604 0 0 4 1503 3668 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3797  
1605 0 0 4 1504 3668 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3803  
1606 0 0 4 1504 3668 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3797  
1607 0 0 6 1505 3673 0 0 0 2 4 this 3 3797  5 other 1 3797  
1608 0 0 6 1506 3673 0 0 0 2 4 this 3 3797  5 other 1 3797  
1609 0 0 6 1507 3673 0 0 0 2 4 this 3 3797  5 other 1 3797  
1610 0 0 6 1508 3524 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3797  5 other 1 3797  
1611 0 0 6 1508 3524 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3797  5 other 1 3797  9 threshold 1 3521  
1612 0 0 6 1509 3666 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3797  
1613 0 0 6 1509 3666 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3797  9 threshold 1 3521  
1614 0 0 6 1510 3666 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3797  4 hash 1 3666  
1615 0 0 6 1510 3666 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3797  4 hash 1 3666  9 threshold 1 3521  
1616 0 0 7 1511 3741 2788 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 3797  1 v 1 3742  
1617 0 0 7 1512 3711 2396 0 162 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3797  1 v 1 3712  
1618 0 0 7 1513 3711 2396 0 143 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3797  1 v 1 3712  
1619 0 0 7 1514 3711 2396 0 169 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */ 2 4 this 3 3797  1 v 1 3712  
1620 0 0 7 1515 3711 2396 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3797  1 v 1 3712  
1621 0 0 4 1516 3668 0 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 3797  1 v 1 3741  
1622 0 0 4 1517 3668 0 0 139 /**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3797  1 v 1 3711  
1623 0 0 4 1518 3668 0 0 120 /**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */ 2 4 this 3 3797  1 v 1 3711  
1624 0 0 4 1519 3668 0 0 142 /**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */ 2 4 this 3 3797  1 v 1 3711  
1625 0 0 4 1520 3668 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 3797  1 v 1 3711  
1626 0 0 4 1521 3668 0 0 25 // this = other1 * other2 3 4 this 3 3803  6 other1 1 3797  6 other2 1 3797  
1627 0 0 7 1522 3803 3372 0 0 2 4 this 3 3797  5 other 1 3797  
1628 0 0 7 1522 3803 3372 0 0 2 4 this 3 3797  6 scalar 1 3521  
1629 0 0 7 1523 3803 3372 0 0 2 4 this 3 3797  6 scalar 1 3521  
1630 0 0 6 1524 3803 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3803  5 other 1 3797  
1631 0 0 6 1525 3803 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3803  5 other 1 3797  
1632 0 0 6 1526 3803 0 0 10 /**
 *
 */ 2 4 this 3 3803  5 other 1 3797  
1633 0 0 6 1526 3803 0 0 10 /**
 *
 */ 2 4 this 3 3803  6 scalar 1 3521  
1634 0 0 6 1527 3803 0 0 10 /**
 *
 */ 2 4 this 3 3803  6 scalar 1 3521  
1635 0 0 4 1528 3668 0 0 10 /**
 *
 */ 2 4 this 3 3803  5 other 1 3797  
1636 0 0 4 1529 3668 0 0 10 /**
 *
 */ 2 4 this 3 3803  5 other 1 3797  
1637 0 0 4 1530 3668 0 0 10 /**
 *
 */ 1 4 this 3 3803  
1638 0 0 6 1531 3673 0 0 461 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */ 2 4 this 3 3803  5 other 1 3797  
1639 0 0 6 1532 3673 0 0 139 // bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component) 2 4 this 3 3803  5 other 1 3797  
1640 0 0 6 1533 3673 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 3803  
1641 0 0 4 1534 3668 0 0 46 /**
 * Computes (*this) += other * weight.
 */ 3 4 this 3 3803  5 other 1 3797  6 weight 1 3521  
1642 0 0 6 1535 3797 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1643 0 0 6 1536 3797 0 0 46 /**
 * Returns an matrix filled with ones.
 */ 0 
1644 0 0 6 1537 3797 0 0 47 /**
 * Returns an matrix filled with zeros.
 */ 0 
1645 0 0 4 1538 3668 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 3803  5 trans 1 3712  
1646 0 0 4 1539 3668 0 0 122 /**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 3803  5 angle 1 3521  4 axis 1 3712  2 cs 1 3537  
1647 0 0 4 1540 3668 0 0 166 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 4 4 this 3 3803  5 angle 1 3521  4 axis 1 3712  2 cs 1 3537  
1648 0 0 4 1541 3668 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 3803  5 scale 1 3712  
1649 0 0 4 1542 3668 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 3803  5 shear 1 3712  2 cs 1 3537  
1650 0 0 4 1543 3668 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 3803  5 scale 1 3712  5 shear 1 3712  2 cs 1 3537  
1651 0 0 7 1544 3803 3372 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3712  
1652 0 0 7 1544 3803 3372 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 3 2 tx 1 3521  2 ty 1 3521  2 tz 1 3521  
1653 0 0 7 1545 3803 3372 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3521  4 axis 1 3712  2 cs 1 3537  
1654 0 0 7 1546 3803 3372 0 159 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 3 5 angle 1 3521  4 axis 1 3712  2 cs 1 3537  
1655 0 0 7 1547 3803 3372 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3712  
1656 0 0 7 1547 3803 3372 0 69 /**
 * Returns a matrix that applies the indicated uniform scale.
 */ 1 5 scale 1 3521  
1657 0 0 7 1547 3803 3372 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3521  2 sy 1 3521  2 sz 1 3521  
1658 0 0 7 1548 3803 3372 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3712  2 cs 1 3537  
1659 0 0 7 1548 3803 3372 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3521  4 shxz 1 3521  4 shyz 1 3521  2 cs 1 3537  
1660 0 0 7 1549 3803 3372 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3712  5 shear 1 3712  2 cs 1 3537  
1661 0 0 7 1549 3803 3372 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3521  2 sy 1 3521  2 sz 1 3521  4 shxy 1 3521  4 shxz 1 3521  4 shyz 1 3521  2 cs 1 3537  
1662 0 0 6 1550 3797 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1663 0 0 6 1551 3797 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1664 0 0 6 1552 3797 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3537  2 to 1 3537  
1665 0 0 6 1553 3673 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3797  5 other 1 3797  
1666 0 0 6 1553 3673 0 0 199 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */ 3 4 this 3 3797  5 other 1 3797  9 threshold 1 3521  
1667 0 0 4 1554 3668 0 0 10 /**
 *
 */ 2 4 this 3 3797  3 out 1 3676  
1668 0 0 4 1555 3668 0 0 10 /**
 *
 */ 3 4 this 3 3797  3 out 1 3676  12 indent_level 1 3524  
1669 0 0 6 1556 3672 0 0 0 1 4 this 3 3797  
1670 0 0 4 1557 3668 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3797  7 hashgen 1 3674  
1671 0 0 4 1557 3668 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3797  7 hashgen 1 3674  5 scale 1 3521  
1672 0 0 4 1558 3668 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3797  11 destination 1 3678  
1673 0 0 4 1559 3668 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3803  4 scan 1 3680  
1674 0 0 4 1560 3668 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3797  11 destination 1 3678  
1675 0 0 4 1561 3668 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 3803  6 source 1 3680  
1676 0 0 7 1562 3683 0 0 0 0 
1677 0 0 7 1465 3806 3281 0 0 1 6 param0 0 3808  
1678 0 0 4 1462 3668 0 0 10 /**
 *
 */ 3 4 this 3 3806  1 i 1 3524  10 assign_val 1 3521  
1679 0 0 6 1462 3521 0 0 0 2 4 this 3 3808  1 i 1 3524  
1680 0 0 6 1463 3524 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1681 0 0 6 1464 3742 0 0 0 1 4 this 3 3808  
1682 0 0 7 1471 3807 3286 0 0 1 6 param0 0 3810  
1683 0 0 6 1468 3521 0 0 0 2 4 this 3 3810  1 i 1 3524  
1684 0 0 6 1469 3524 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1685 0 0 6 1470 3742 0 0 0 1 4 this 3 3810  
1686 0 0 7 1566 3812 3382 0 10 /**
 *
 */ 0 
1687 0 0 7 1566 3812 3382 0 10 /**
 *
 */ 1 4 copy 1 3797  
1688 0 0 7 1566 3812 3382 0 10 /**
 *
 */ 1 4 copy 1 3804  
1689 0 0 7 1566 3812 3382 0 10 /**
 *
 */ 16 3 e00 1 3521  3 e01 1 3521  3 e02 1 3521  3 e03 1 3521  3 e10 1 3521  3 e11 1 3521  3 e12 1 3521  3 e13 1 3521  3 e20 1 3521  3 e21 1 3521  3 e22 1 3521  3 e23 1 3521  3 e30 1 3521  3 e31 1 3521  3 e32 1 3521  3 e33 1 3521  
1690 0 0 6 1567 3812 0 0 10 /**
 *
 */ 2 4 this 3 3812  4 copy 1 3797  
1691 0 0 6 1567 3812 0 0 10 /**
 *
 */ 2 4 this 3 3812  4 copy 1 3804  
1692 0 0 4 1568 3668 0 0 10 /**
 *
 */ 17 4 this 3 3812  3 e00 1 3521  3 e01 1 3521  3 e02 1 3521  3 e03 1 3521  3 e10 1 3521  3 e11 1 3521  3 e12 1 3521  3 e13 1 3521  3 e20 1 3521  3 e21 1 3521  3 e22 1 3521  3 e23 1 3521  3 e30 1 3521  3 e31 1 3521  3 e32 1 3521  3 e33 1 3521  
1693 0 0 4 1569 3668 0 0 10 /**
 *
 */ 3 4 this 3 3812  3 row 1 3524  3 col 1 3524  
1694 0 0 6 1569 3521 0 0 0 3 4 this 3 3804  3 row 1 3524  3 col 1 3524  
1695 0 0 4 1570 3668 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3804  
1696 0 0 6 1571 3524 0 0 65 /**
 * Returns the number of elements in the matrix, sixteen.
 */ 1 4 this 3 3804  
1697 0 0 6 1572 3673 0 0 0 2 4 this 3 3804  5 other 1 3804  
1698 0 0 6 1573 3673 0 0 0 2 4 this 3 3804  5 other 1 3804  
1699 0 0 7 1574 3683 0 0 0 0 
1700 0 0 7 1585 3813 3439 0 10 /**
 *
 */ 0 
1701 0 0 7 1585 3813 3439 0 0 1 6 param0 0 3814  
1702 0 0 7 1585 3813 3439 0 10 /**
 *
 */ 1 4 copy 1 3736  
1703 0 0 7 1585 3813 3439 0 10 /**
 *
 */ 2 1 r 1 3518  4 copy 1 3709  
1704 0 0 7 1585 3813 3439 0 10 /**
 *
 */ 4 1 r 1 3518  1 i 1 3518  1 j 1 3518  1 k 1 3518  
1705 0 0 7 1586 3813 3439 0 10 /**
 *
 */ 1 1 v 1 3718  
1706 0 0 7 1587 3813 3439 0 54 /**
 * Returns the complex conjugate of this quat.
 */ 1 4 this 3 3814  
1707 0 0 7 1588 3708 2323 0 60 /**
 * Transforms a 3-d vector by the indicated rotation
 */ 2 4 this 3 3814  1 v 1 3709  
1708 0 0 7 1588 3735 2703 0 60 /**
 * Transforms a 4-d vector by the indicated rotation
 */ 2 4 this 3 3814  1 v 1 3736  
1709 0 0 7 1589 3813 3439 0 45 /**
 * actual multiply call (non virtual)
 */ 2 4 this 3 3814  3 rhs 1 3814  
1710 0 0 7 1590 3813 3439 0 0 1 4 this 3 3814  
1711 0 0 7 1591 3813 3439 0 0 2 4 this 3 3814  5 other 1 3814  
1712 0 0 7 1592 3813 3439 0 0 2 4 this 3 3814  5 other 1 3814  
1713 0 0 6 1593 3518 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */ 2 4 this 3 3814  5 other 1 3814  
1714 0 0 6 1594 3518 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */ 2 4 this 3 3814  5 other 1 3814  
1715 0 0 7 1595 3771 3082 0 0 2 4 this 3 3813  6 param0 0 3772  
1716 0 0 7 1595 3782 3180 0 0 2 4 this 3 3813  6 param0 0 3776  
1717 0 0 7 1595 3813 3439 0 0 2 4 this 3 3814  6 param0 0 3814  
1718 0 0 7 1595 3813 3439 0 0 2 4 this 3 3814  6 scalar 1 3518  
1719 0 0 7 1596 3813 3439 0 0 2 4 this 3 3814  6 scalar 1 3518  
1720 0 0 6 1597 3813 0 0 10 /**
 *
 */ 2 4 this 3 3813  6 param0 0 3814  
1721 0 0 7 1598 3813 3439 0 97 /**
 * Returns a new quaternion that represents this quaternion raised to the
 * given power.
 */ 2 4 this 3 3814  6 param0 0 3518  
1722 0 0 6 1599 3673 0 0 120 /**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3814  5 other 1 3814  
1723 0 0 6 1599 3673 0 0 96 /**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3814  5 other 1 3814  9 threshold 1 3518  
1724 0 0 6 1600 3673 0 0 127 /**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */ 2 4 this 3 3814  5 other 1 3814  
1725 0 0 6 1601 3673 0 0 103 /**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */ 3 4 this 3 3814  5 other 1 3814  9 threshold 1 3518  
1726 0 0 4 1602 3668 0 0 10 /**
 *
 */ 2 4 this 3 3814  6 param0 0 3676  
1727 0 0 4 1603 3668 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 3814  1 m 1 3771  
1728 0 0 4 1603 3668 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 3814  1 m 1 3782  
1729 0 0 4 1604 3668 0 0 226 /**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */ 2 4 this 3 3813  1 m 1 3772  
1730 0 0 4 1604 3668 0 0 10 /**
 *
 */ 2 4 this 3 3813  1 m 1 3776  
1731 0 0 4 1605 3668 0 0 132 /**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */ 3 4 this 3 3813  3 hpr 1 3709  2 cs 1 3537  
1732 0 0 7 1606 3708 2323 0 73 /**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */ 2 4 this 3 3814  2 cs 1 3537  
1733 0 0 7 1607 3717 2502 0 180 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */ 1 4 this 3 3814  
1734 0 0 7 1608 3717 2502 0 169 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */ 1 4 this 3 3814  
1735 0 0 6 1609 3518 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 3814  
1736 0 0 6 1610 3518 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 3814  
1737 0 0 4 1611 3668 0 0 86 /**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */ 3 4 this 3 3813  9 angle_rad 1 3518  4 axis 1 3718  
1738 0 0 4 1612 3668 0 0 86 /**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */ 3 4 this 3 3813  9 angle_deg 1 3518  4 axis 1 3718  
1739 0 0 7 1613 3717 2502 0 96 /**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */ 2 4 this 3 3814  2 cs 1 3537  
1740 0 0 7 1614 3717 2502 0 98 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */ 2 4 this 3 3814  2 cs 1 3537  
1741 0 0 7 1615 3717 2502 0 100 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */ 2 4 this 3 3814  2 cs 1 3537  
1742 0 0 6 1616 3518 0 0 10 /**
 *
 */ 1 4 this 3 3814  
1743 0 0 6 1617 3518 0 0 10 /**
 *
 */ 1 4 this 3 3814  
1744 0 0 6 1618 3518 0 0 10 /**
 *
 */ 1 4 this 3 3814  
1745 0 0 6 1619 3518 0 0 10 /**
 *
 */ 1 4 this 3 3814  
1746 0 0 4 1620 3668 0 0 10 /**
 *
 */ 2 4 this 3 3813  1 r 1 3518  
1747 0 0 4 1621 3668 0 0 10 /**
 *
 */ 2 4 this 3 3813  1 i 1 3518  
1748 0 0 4 1622 3668 0 0 10 /**
 *
 */ 2 4 this 3 3813  1 j 1 3518  
1749 0 0 4 1623 3668 0 0 10 /**
 *
 */ 2 4 this 3 3813  1 k 1 3518  
1750 0 0 6 1624 3673 0 0 10 /**
 *
 */ 1 4 this 3 3813  
1751 0 0 6 1625 3673 0 0 466 /**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3813  5 other 1 3814  
1752 0 0 6 1626 3673 0 0 129 /**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */ 1 4 this 3 3813  
1753 0 0 6 1627 3673 0 0 448 /**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3813  5 other 1 3814  
1754 0 0 6 1628 3673 0 0 115 /**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */ 1 4 this 3 3813  
1755 0 0 6 1629 3673 0 0 98 /**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */ 1 4 this 3 3814  
1756 0 0 6 1630 3673 0 0 110 /**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */ 2 4 this 3 3814  9 tolerance 1 3518  
1757 0 0 6 1631 3814 0 0 42 /**
 * Returns an identity quaternion.
 */ 0 
1758 0 0 7 1632 3683 0 0 0 0 
1759 0 0 7 1635 3816 3488 0 10 /**
 *
 */ 0 
1760 0 0 7 1635 3816 3488 0 0 1 6 param0 0 3817  
1761 0 0 7 1635 3816 3488 0 10 /**
 *
 */ 1 4 copy 1 3742  
1762 0 0 7 1635 3816 3488 0 10 /**
 *
 */ 2 1 r 1 3521  4 copy 1 3712  
1763 0 0 7 1635 3816 3488 0 10 /**
 *
 */ 4 1 r 1 3521  1 i 1 3521  1 j 1 3521  1 k 1 3521  
1764 0 0 7 1636 3816 3488 0 10 /**
 *
 */ 1 1 v 1 3721  
1765 0 0 7 1637 3816 3488 0 54 /**
 * Returns the complex conjugate of this quat.
 */ 1 4 this 3 3817  
1766 0 0 7 1638 3711 2396 0 60 /**
 * Transforms a 3-d vector by the indicated rotation
 */ 2 4 this 3 3817  1 v 1 3712  
1767 0 0 7 1638 3741 2788 0 60 /**
 * Transforms a 4-d vector by the indicated rotation
 */ 2 4 this 3 3817  1 v 1 3742  
1768 0 0 7 1639 3816 3488 0 45 /**
 * actual multiply call (non virtual)
 */ 2 4 this 3 3817  3 rhs 1 3817  
1769 0 0 7 1640 3816 3488 0 0 1 4 this 3 3817  
1770 0 0 7 1641 3816 3488 0 0 2 4 this 3 3817  5 other 1 3817  
1771 0 0 7 1642 3816 3488 0 0 2 4 this 3 3817  5 other 1 3817  
1772 0 0 6 1643 3521 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */ 2 4 this 3 3817  5 other 1 3817  
1773 0 0 6 1644 3521 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */ 2 4 this 3 3817  5 other 1 3817  
1774 0 0 7 1645 3792 3276 0 0 2 4 this 3 3816  6 param0 0 3793  
1775 0 0 7 1645 3803 3372 0 0 2 4 this 3 3816  6 param0 0 3797  
1776 0 0 7 1645 3816 3488 0 0 2 4 this 3 3817  6 param0 0 3817  
1777 0 0 7 1645 3816 3488 0 0 2 4 this 3 3817  6 scalar 1 3521  
1778 0 0 7 1646 3816 3488 0 0 2 4 this 3 3817  6 scalar 1 3521  
1779 0 0 6 1647 3816 0 0 10 /**
 *
 */ 2 4 this 3 3816  6 param0 0 3817  
1780 0 0 7 1648 3816 3488 0 97 /**
 * Returns a new quaternion that represents this quaternion raised to the
 * given power.
 */ 2 4 this 3 3817  6 param0 0 3521  
1781 0 0 6 1649 3673 0 0 120 /**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3817  5 other 1 3817  
1782 0 0 6 1649 3673 0 0 96 /**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3817  5 other 1 3817  9 threshold 1 3521  
1783 0 0 6 1650 3673 0 0 127 /**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */ 2 4 this 3 3817  5 other 1 3817  
1784 0 0 6 1651 3673 0 0 103 /**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */ 3 4 this 3 3817  5 other 1 3817  9 threshold 1 3521  
1785 0 0 4 1652 3668 0 0 10 /**
 *
 */ 2 4 this 3 3817  6 param0 0 3676  
1786 0 0 4 1653 3668 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 3817  1 m 1 3792  
1787 0 0 4 1653 3668 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 3817  1 m 1 3803  
1788 0 0 4 1654 3668 0 0 226 /**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */ 2 4 this 3 3816  1 m 1 3793  
1789 0 0 4 1654 3668 0 0 10 /**
 *
 */ 2 4 this 3 3816  1 m 1 3797  
1790 0 0 4 1655 3668 0 0 132 /**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */ 3 4 this 3 3816  3 hpr 1 3712  2 cs 1 3537  
1791 0 0 7 1656 3711 2396 0 73 /**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */ 2 4 this 3 3817  2 cs 1 3537  
1792 0 0 7 1657 3720 2536 0 180 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */ 1 4 this 3 3817  
1793 0 0 7 1658 3720 2536 0 169 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */ 1 4 this 3 3817  
1794 0 0 6 1659 3521 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 3817  
1795 0 0 6 1660 3521 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 3817  
1796 0 0 4 1661 3668 0 0 86 /**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */ 3 4 this 3 3816  9 angle_rad 1 3521  4 axis 1 3721  
1797 0 0 4 1662 3668 0 0 86 /**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */ 3 4 this 3 3816  9 angle_deg 1 3521  4 axis 1 3721  
1798 0 0 7 1663 3720 2536 0 96 /**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */ 2 4 this 3 3817  2 cs 1 3537  
1799 0 0 7 1664 3720 2536 0 98 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */ 2 4 this 3 3817  2 cs 1 3537  
1800 0 0 7 1665 3720 2536 0 100 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */ 2 4 this 3 3817  2 cs 1 3537  
1801 0 0 6 1666 3521 0 0 10 /**
 *
 */ 1 4 this 3 3817  
1802 0 0 6 1667 3521 0 0 10 /**
 *
 */ 1 4 this 3 3817  
1803 0 0 6 1668 3521 0 0 10 /**
 *
 */ 1 4 this 3 3817  
1804 0 0 6 1669 3521 0 0 10 /**
 *
 */ 1 4 this 3 3817  
1805 0 0 4 1670 3668 0 0 10 /**
 *
 */ 2 4 this 3 3816  1 r 1 3521  
1806 0 0 4 1671 3668 0 0 10 /**
 *
 */ 2 4 this 3 3816  1 i 1 3521  
1807 0 0 4 1672 3668 0 0 10 /**
 *
 */ 2 4 this 3 3816  1 j 1 3521  
1808 0 0 4 1673 3668 0 0 10 /**
 *
 */ 2 4 this 3 3816  1 k 1 3521  
1809 0 0 6 1674 3673 0 0 10 /**
 *
 */ 1 4 this 3 3816  
1810 0 0 6 1675 3673 0 0 466 /**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3816  5 other 1 3817  
1811 0 0 6 1676 3673 0 0 129 /**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */ 1 4 this 3 3816  
1812 0 0 6 1677 3673 0 0 448 /**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3816  5 other 1 3817  
1813 0 0 6 1678 3673 0 0 115 /**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */ 1 4 this 3 3816  
1814 0 0 6 1679 3673 0 0 98 /**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */ 1 4 this 3 3817  
1815 0 0 6 1680 3673 0 0 110 /**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */ 2 4 this 3 3817  9 tolerance 1 3521  
1816 0 0 6 1681 3817 0 0 42 /**
 * Returns an identity quaternion.
 */ 0 
1817 0 0 7 1682 3683 0 0 0 0 
1818 0 0 7 1685 3819 3493 0 10 /**
 *
 */ 0 
1819 0 0 7 1685 3819 3493 0 19 /**
 * lmatrix3
 */ 1 1 m 1 3772  
1820 0 0 7 1685 3819 3493 0 19 /**
 * lmatrix4
 */ 1 1 m 1 3776  
1821 0 0 7 1685 3819 3493 0 10 /**
 *
 */ 1 1 c 1 3814  
1822 0 0 7 1685 3819 3493 0 0 1 6 param0 0 3820  
1823 0 0 7 1685 3819 3493 0 10 /**
 *
 */ 1 4 copy 1 3736  
1824 0 0 7 1685 3819 3493 0 36 /**
 * axis + angle (in degrees)
 */ 2 4 axis 1 3718  5 angle 1 3518  
1825 0 0 7 1685 3819 3493 0 57 /**
 * Sets the rotation from the given Euler angles.
 */ 3 1 h 1 3518  1 p 1 3518  1 r 1 3518  
1826 0 0 7 1685 3819 3493 0 10 /**
 *
 */ 4 1 r 1 3518  1 i 1 3518  1 j 1 3518  1 k 1 3518  
1827 0 0 7 1686 3813 3439 0 0 2 4 this 3 3820  5 other 1 3814  
1828 0 0 7 1686 3819 3493 0 0 2 4 this 3 3820  5 other 1 3820  
1829 0 0 7 1686 3819 3493 0 0 2 4 this 3 3820  6 scalar 1 3518  
1830 0 0 7 1687 3819 3493 0 0 2 4 this 3 3820  6 scalar 1 3518  
1831 0 0 7 1688 3683 0 0 0 0 
1832 0 0 7 1691 3822 3498 0 10 /**
 *
 */ 0 
1833 0 0 7 1691 3822 3498 0 19 /**
 * lmatrix3
 */ 1 1 m 1 3793  
1834 0 0 7 1691 3822 3498 0 19 /**
 * lmatrix4
 */ 1 1 m 1 3797  
1835 0 0 7 1691 3822 3498 0 10 /**
 *
 */ 1 1 c 1 3817  
1836 0 0 7 1691 3822 3498 0 0 1 6 param0 0 3823  
1837 0 0 7 1691 3822 3498 0 10 /**
 *
 */ 1 4 copy 1 3742  
1838 0 0 7 1691 3822 3498 0 36 /**
 * axis + angle (in degrees)
 */ 2 4 axis 1 3721  5 angle 1 3521  
1839 0 0 7 1691 3822 3498 0 57 /**
 * Sets the rotation from the given Euler angles.
 */ 3 1 h 1 3521  1 p 1 3521  1 r 1 3521  
1840 0 0 7 1691 3822 3498 0 10 /**
 *
 */ 4 1 r 1 3521  1 i 1 3521  1 j 1 3521  1 k 1 3521  
1841 0 0 7 1692 3816 3488 0 0 2 4 this 3 3823  5 other 1 3817  
1842 0 0 7 1692 3822 3498 0 0 2 4 this 3 3823  5 other 1 3823  
1843 0 0 7 1692 3822 3498 0 0 2 4 this 3 3823  6 scalar 1 3521  
1844 0 0 7 1693 3822 3498 0 0 2 4 this 3 3823  6 scalar 1 3521  
1845 0 0 7 1694 3683 0 0 0 0 
1846 0 0 7 1697 3825 3502 0 10 /**
 *
 */ 0 
1847 0 0 7 1697 3825 3502 0 18 /**
 * matrix3
 */ 1 1 m 1 3772  
1848 0 0 7 1697 3825 3502 0 18 /**
 * matrix4
 */ 1 1 m 1 3776  
1849 0 0 7 1697 3825 3502 0 0 1 6 param0 0 3826  
1850 0 0 7 1697 3825 3502 0 10 /**
 *
 */ 1 1 c 1 3814  
1851 0 0 7 1697 3825 3502 0 25 /**
 * vector + twist
 */ 2 8 point_at 1 3718  5 twist 1 3518  
1852 0 0 7 1697 3825 3502 0 10 /**
 *
 */ 4 1 r 1 3518  1 i 1 3518  1 j 1 3518  1 k 1 3518  
1853 0 0 7 1698 3825 3502 0 0 2 4 this 3 3826  5 other 1 3814  
1854 0 0 7 1698 3825 3502 0 0 2 4 this 3 3826  5 other 1 3820  
1855 0 0 7 1699 3683 0 0 0 0 
1856 0 0 7 1702 3828 3506 0 10 /**
 *
 */ 0 
1857 0 0 7 1702 3828 3506 0 18 /**
 * matrix3
 */ 1 1 m 1 3793  
1858 0 0 7 1702 3828 3506 0 18 /**
 * matrix4
 */ 1 1 m 1 3797  
1859 0 0 7 1702 3828 3506 0 0 1 6 param0 0 3829  
1860 0 0 7 1702 3828 3506 0 10 /**
 *
 */ 1 1 c 1 3817  
1861 0 0 7 1702 3828 3506 0 25 /**
 * vector + twist
 */ 2 8 point_at 1 3721  5 twist 1 3521  
1862 0 0 7 1702 3828 3506 0 10 /**
 *
 */ 4 1 r 1 3521  1 i 1 3521  1 j 1 3521  1 k 1 3521  
1863 0 0 7 1703 3828 3506 0 0 2 4 this 3 3829  5 other 1 3817  
1864 0 0 7 1703 3828 3506 0 0 2 4 this 3 3829  5 other 1 3823  
1865 0 0 7 1704 3683 0 0 0 0 
1866 0 0 7 1778 3833 3514 0 0 1 6 param0 0 3831  
1867 0 0 7 1778 3833 3514 0 10 /**
 *
 */ 1 4 name 1 3672  
1868 0 0 7 1778 3833 3514 0 10 /**
 *
 */ 4 4 name 1 3672  13 default_value 1 3834  11 description 1 3672  5 flags 1 3524  
1869 0 0 7 1778 3833 3514 0 10 /**
 *
 */ 4 4 name 1 3672  13 default_value 1 3672  11 description 1 3672  5 flags 1 3524  
1870 0 0 6 1779 3833 0 0 0 2 4 this 3 3833  5 value 1 3834  
1871 0 0 6 1781 3836 0 0 0 2 4 this 3 3831  1 n 1 3524  
1872 0 0 4 1782 3668 0 0 48 /**
 * Reassigns the variable's local value.
 */ 2 4 this 3 3833  5 value 1 3834  
1873 0 0 6 1783 3834 0 0 40 /**
 * Returns the variable's value.
 */ 1 4 this 3 3831  
1874 0 0 7 1784 3837 0 0 48 /**
 * Returns the variable's default value.
 */ 1 4 this 3 3831  
1875 0 0 6 1780 3834 0 0 0 1 4 this 3 3831  
1876 0 0 6 4 3521 0 0 0 1 1 f 1 3521  
1877 0 0 6 4 3518 0 0 0 1 1 f 1 3518  
1878 0 0 6 5 3521 0 0 0 1 1 f 1 3521  
1879 0 0 6 5 3518 0 0 0 1 1 f 1 3518  
1880 0 0 6 547 3537 0 0 0 0 
1881 0 0 6 548 3537 0 0 0 1 3 str 1 3672  
1882 0 0 6 549 3672 0 0 0 1 2 cs 1 3537  
1883 0 0 6 550 3673 0 0 0 1 2 cs 1 3537  
1884 0 0 7 1244 3792 3276 0 0 1 1 a 1 3793  
1885 0 0 7 1244 3771 3082 0 0 1 1 a 1 3772  
1886 0 0 7 1244 3803 3372 0 0 1 1 a 1 3797  
1887 0 0 7 1244 3782 3180 0 0 1 1 a 1 3776  
1888 0 0 7 1245 3792 3276 0 0 1 1 a 1 3793  
1889 0 0 7 1245 3771 3082 0 0 1 1 a 1 3772  
1890 0 0 7 1245 3803 3372 0 0 1 1 a 1 3797  
1891 0 0 7 1245 3782 3180 0 0 1 1 a 1 3776  
1892 0 0 7 1245 3816 3488 0 0 1 1 a 1 3817  
1893 0 0 7 1245 3813 3439 0 0 1 1 a 1 3814  
1894 0 0 7 1576 3792 3276 0 0 2 1 m 1 3793  1 q 1 3817  
1895 0 0 7 1576 3771 3082 0 0 2 1 m 1 3772  1 q 1 3814  
1896 0 0 7 1576 3803 3372 0 0 2 1 m 1 3797  1 q 1 3817  
1897 0 0 7 1576 3782 3180 0 0 2 1 m 1 3776  1 q 1 3814  
1898 0 0 7 1576 3702 2236 0 0 2 1 v 1 3703  1 m 1 3793  
1899 0 0 7 1576 3699 2220 0 0 2 1 v 1 3700  1 m 1 3772  
1900 0 0 7 1576 3729 2608 0 0 2 1 v 1 3730  1 m 1 3793  
1901 0 0 7 1576 3729 2608 0 0 2 1 v 1 3730  1 m 1 3797  
1902 0 0 7 1576 3726 2585 0 0 2 1 v 1 3727  1 m 1 3772  
1903 0 0 7 1576 3726 2585 0 0 2 1 v 1 3727  1 m 1 3776  
1904 0 0 7 1576 3765 2978 0 0 2 1 v 1 3766  1 m 1 3797  
1905 0 0 7 1576 3762 2958 0 0 2 1 v 1 3763  1 m 1 3776  
1906 0 0 7 1576 3711 2396 0 0 2 1 v 1 3712  1 m 1 3793  
1907 0 0 7 1576 3708 2323 0 0 2 1 v 1 3709  1 m 1 3772  
1908 0 0 7 1576 3741 2788 0 0 2 1 v 1 3742  1 m 1 3797  
1909 0 0 7 1576 3735 2703 0 0 2 1 v 1 3736  1 m 1 3776  
1910 0 0 7 1576 3693 2190 0 0 2 1 v 1 3694  1 m 1 3793  
1911 0 0 7 1576 3690 2172 0 0 2 1 v 1 3691  1 m 1 3772  
1912 0 0 7 1576 3720 2536 0 0 2 1 v 1 3721  1 m 1 3793  
1913 0 0 7 1576 3720 2536 0 0 2 1 v 1 3721  1 m 1 3797  
1914 0 0 7 1576 3717 2502 0 0 2 1 v 1 3718  1 m 1 3772  
1915 0 0 7 1576 3717 2502 0 0 2 1 v 1 3718  1 m 1 3776  
1916 0 0 7 1576 3756 2920 0 0 2 1 v 1 3757  1 m 1 3797  
1917 0 0 7 1576 3753 2900 0 0 2 1 v 1 3754  1 m 1 3776  
1918 0 0 4 1577 3668 0 0 0 2 1 v 1 3702  1 m 1 3793  
1919 0 0 4 1577 3668 0 0 0 2 1 v 1 3699  1 m 1 3772  
1920 0 0 4 1577 3668 0 0 0 2 1 v 1 3729  1 m 1 3793  
1921 0 0 4 1577 3668 0 0 0 2 1 v 1 3729  1 m 1 3797  
1922 0 0 4 1577 3668 0 0 0 2 1 v 1 3726  1 m 1 3772  
1923 0 0 4 1577 3668 0 0 0 2 1 v 1 3726  1 m 1 3776  
1924 0 0 4 1577 3668 0 0 0 2 1 v 1 3711  1 m 1 3793  
1925 0 0 4 1577 3668 0 0 0 2 1 v 1 3708  1 m 1 3772  
1926 0 0 4 1577 3668 0 0 0 2 1 v 1 3741  1 m 1 3797  
1927 0 0 4 1577 3668 0 0 0 2 1 v 1 3735  1 m 1 3776  
1928 0 0 4 1577 3668 0 0 0 2 1 v 1 3693  1 m 1 3793  
1929 0 0 4 1577 3668 0 0 0 2 1 v 1 3690  1 m 1 3772  
1930 0 0 4 1577 3668 0 0 0 2 1 v 1 3720  1 m 1 3793  
1931 0 0 4 1577 3668 0 0 0 2 1 v 1 3720  1 m 1 3797  
1932 0 0 4 1577 3668 0 0 0 2 1 v 1 3717  1 m 1 3772  
1933 0 0 4 1577 3668 0 0 0 2 1 v 1 3717  1 m 1 3776  
1934 0 0 4 1578 3668 0 0 0 2 4 dest 1 3678  5 value 1 3793  
1935 0 0 4 1578 3668 0 0 0 2 4 dest 1 3678  5 value 1 3772  
1936 0 0 4 1578 3668 0 0 0 2 4 dest 1 3678  5 value 1 3797  
1937 0 0 4 1578 3668 0 0 0 2 4 dest 1 3678  5 value 1 3776  
1938 0 0 4 1579 3668 0 0 0 2 6 result 1 3792  6 source 1 3680  
1939 0 0 4 1579 3668 0 0 0 2 6 result 1 3771  6 source 1 3680  
1940 0 0 4 1579 3668 0 0 0 2 6 result 1 3803  6 source 1 3680  
1941 0 0 4 1579 3668 0 0 0 2 6 result 1 3782  6 source 1 3680  
1942 0 0 4 1580 3668 0 0 0 4 3 mat 1 3792  5 scale 1 3712  3 hpr 1 3712  2 cs 1 3537  
1943 0 0 4 1580 3668 0 0 0 5 3 mat 1 3792  5 scale 1 3712  5 shear 1 3712  3 hpr 1 3712  2 cs 1 3537  
1944 0 0 4 1580 3668 0 0 0 4 3 mat 1 3771  5 scale 1 3709  3 hpr 1 3709  2 cs 1 3537  
1945 0 0 4 1580 3668 0 0 0 5 3 mat 1 3771  5 scale 1 3709  5 shear 1 3709  3 hpr 1 3709  2 cs 1 3537  
1946 0 0 4 1580 3668 0 0 0 5 3 mat 1 3803  5 scale 1 3712  3 hpr 1 3712  9 translate 1 3712  2 cs 1 3537  
1947 0 0 4 1580 3668 0 0 0 6 3 mat 1 3803  5 scale 1 3712  5 shear 1 3712  3 hpr 1 3712  9 translate 1 3712  2 cs 1 3537  
1948 0 0 4 1580 3668 0 0 0 3 3 mat 1 3803  10 components 1 3838  2 cs 1 3537  
1949 0 0 4 1580 3668 0 0 0 5 3 mat 1 3782  5 scale 1 3709  3 hpr 1 3709  9 translate 1 3709  2 cs 1 3537  
1950 0 0 4 1580 3668 0 0 0 6 3 mat 1 3782  5 scale 1 3709  5 shear 1 3709  3 hpr 1 3709  9 translate 1 3709  2 cs 1 3537  
1951 0 0 4 1580 3668 0 0 0 3 3 mat 1 3782  10 components 1 3840  2 cs 1 3537  
1952 0 0 6 1581 3673 0 0 0 4 3 mat 1 3793  5 scale 1 3711  3 hpr 1 3711  2 cs 1 3537  
1953 0 0 6 1581 3673 0 0 0 5 3 mat 1 3793  5 scale 1 3711  5 shear 1 3711  3 hpr 1 3711  2 cs 1 3537  
1954 0 0 6 1581 3673 0 0 0 4 3 mat 1 3772  5 scale 1 3708  3 hpr 1 3708  2 cs 1 3537  
1955 0 0 6 1581 3673 0 0 0 5 3 mat 1 3772  5 scale 1 3708  5 shear 1 3708  3 hpr 1 3708  2 cs 1 3537  
1956 0 0 6 1581 3673 0 0 0 5 3 mat 1 3797  5 scale 1 3711  3 hpr 1 3711  9 translate 1 3711  2 cs 1 3537  
1957 0 0 6 1581 3673 0 0 0 6 3 mat 1 3797  5 scale 1 3711  5 shear 1 3711  3 hpr 1 3711  9 translate 1 3711  2 cs 1 3537  
1958 0 0 6 1581 3673 0 0 0 3 3 mat 1 3797  10 components 1 3842  2 CS 1 3537  
1959 0 0 6 1581 3673 0 0 0 5 3 mat 1 3776  5 scale 1 3708  3 hpr 1 3708  9 translate 1 3708  2 cs 1 3537  
1960 0 0 6 1581 3673 0 0 0 6 3 mat 1 3776  5 scale 1 3708  5 shear 1 3708  3 hpr 1 3708  9 translate 1 3708  2 cs 1 3537  
1961 0 0 6 1581 3673 0 0 0 3 3 mat 1 3776  10 components 1 3843  2 CS 1 3537  
1962 0 0 6 1582 3673 0 0 0 5 3 mat 1 3793  5 scale 1 3711  5 shear 1 3711  3 hpr 1 3711  2 cs 1 3537  
1963 0 0 6 1582 3673 0 0 0 5 3 mat 1 3772  5 scale 1 3708  5 shear 1 3708  3 hpr 1 3708  2 cs 1 3537  
1964 0 0 7 1583 3711 2396 0 0 1 7 old_hpr 1 3712  
1965 0 0 7 1583 3708 2323 0 0 1 7 old_hpr 1 3709  
329
3515 11 MathNumbers 0 141313 11 MathNumbers 11 MathNumbers 0 0 0 1 1966 1967 0 0 0 0 0 0 0 0

3516 10 LVecBase2f 0 141313 10 LVecBase2f 10 LVecBase2f 0 0 0 1 1970 2032 2 3844 3845 61 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030 2031 0 0 0 0 1 3517 75
/**
 * This is the base class for all two-component vectors and points.
 */

3517 0 0 794624 12 LVecBase2f:: 0 3516 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase2f::num_components 0
2 6 is_int 18 LVecBase2f::is_int 0
0 0 0

3518 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0

3519 10 LVecBase2d 0 141313 10 LVecBase2d 10 LVecBase2d 0 0 0 1 2033 2095 2 3846 3847 61 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 0 0 0 0 1 3520 75
/**
 * This is the base class for all two-component vectors and points.
 */

3520 0 0 794624 12 LVecBase2d:: 0 3519 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase2d::num_components 0
2 6 is_int 18 LVecBase2d::is_int 0
0 0 0

3521 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0

3522 10 LVecBase2i 0 141313 10 LVecBase2i 10 LVecBase2i 0 0 0 1 2096 2154 2 3848 3849 57 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 2142 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 0 0 0 0 1 3523 75
/**
 * This is the base class for all two-component vectors and points.
 */

3523 0 0 794624 12 LVecBase2i:: 0 3522 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase2i::num_components 0
2 6 is_int 18 LVecBase2i::is_int 0
1 0 0

3524 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

3525 9 LVector2f 0 141313 9 LVector2f 9 LVector2f 0 0 0 1 2155 2172 0 16 2156 2157 2158 2159 2160 2161 2162 2163 2164 2165 2166 2167 2168 2169 2170 2171 0 0 1 0 3516 0 0 0 0 49
/**
 * This is a two-component vector offset.
 */

3526 9 LVector2d 0 141313 9 LVector2d 9 LVector2d 0 0 0 1 2173 2190 0 16 2174 2175 2176 2177 2178 2179 2180 2181 2182 2183 2184 2185 2186 2187 2188 2189 0 0 1 0 3519 0 0 0 0 49
/**
 * This is a two-component vector offset.
 */

3527 9 LVector2i 0 141313 9 LVector2i 9 LVector2i 0 0 0 1 2191 2204 0 12 2192 2193 2194 2195 2196 2197 2198 2199 2200 2201 2202 2203 0 0 1 0 3522 0 0 0 0 49
/**
 * This is a two-component vector offset.
 */

3528 8 LPoint2f 0 141313 8 LPoint2f 8 LPoint2f 0 0 0 1 2205 2220 0 14 2206 2207 2208 2209 2210 2211 2212 2213 2214 2215 2216 2217 2218 2219 0 0 1 0 3516 0 0 0 0 50
/**
 * This is a two-component point in space.
 */

3529 8 LPoint2d 0 141313 8 LPoint2d 8 LPoint2d 0 0 0 1 2221 2236 0 14 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 2235 0 0 1 0 3519 0 0 0 0 50
/**
 * This is a two-component point in space.
 */

3530 8 LPoint2i 0 141313 8 LPoint2i 8 LPoint2i 0 0 0 1 2237 2250 0 12 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 0 0 1 0 3522 0 0 0 0 50
/**
 * This is a two-component point in space.
 */

3531 10 LVecBase3f 0 141313 10 LVecBase3f 10 LVecBase3f 0 0 0 1 2251 2323 6 3850 3851 3852 3853 3854 3855 71 2252 2253 2254 2255 2256 2257 2258 2259 2260 2261 2262 2263 2264 2265 2266 2267 2268 2269 2270 2271 2272 2273 2274 2275 2276 2277 2278 2279 2280 2281 2282 2283 2284 2285 2286 2287 2288 2289 2290 2291 2292 2293 2294 2295 2296 2297 2298 2299 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 2311 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 0 0 0 0 1 3532 77
/**
 * This is the base class for all three-component vectors and points.
 */

3532 0 0 794624 12 LVecBase3f:: 0 3531 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase3f::num_components 0
3 6 is_int 18 LVecBase3f::is_int 0
0 0 0

3533 10 LVecBase3d 0 141313 10 LVecBase3d 10 LVecBase3d 0 0 0 1 2324 2396 6 3856 3857 3858 3859 3860 3861 71 2325 2326 2327 2328 2329 2330 2331 2332 2333 2334 2335 2336 2337 2338 2339 2340 2341 2342 2343 2344 2345 2346 2347 2348 2349 2350 2351 2352 2353 2354 2355 2356 2357 2358 2359 2360 2361 2362 2363 2364 2365 2366 2367 2368 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 2391 2392 2393 2394 2395 0 0 0 0 1 3534 77
/**
 * This is the base class for all three-component vectors and points.
 */

3534 0 0 794624 12 LVecBase3d:: 0 3533 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase3d::num_components 0
3 6 is_int 18 LVecBase3d::is_int 0
0 0 0

3535 10 LVecBase3i 0 141313 10 LVecBase3i 10 LVecBase3i 0 0 0 1 2397 2464 6 3862 3863 3864 3865 3866 3867 66 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 2435 2436 2437 2438 2439 2440 2441 2442 2443 2444 2445 2446 2447 2448 2449 2450 2451 2452 2453 2454 2455 2456 2457 2458 2459 2460 2461 2462 2463 0 0 0 0 1 3536 77
/**
 * This is the base class for all three-component vectors and points.
 */

3536 0 0 794624 12 LVecBase3i:: 0 3535 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase3i::num_components 0
3 6 is_int 18 LVecBase3i::is_int 0
1 0 0

3537 16 CoordinateSystem 0 532481 16 CoordinateSystem 16 CoordinateSystem 0 0 0 0 0 0 0 0 0 0 6 10 CS_default 10 CS_default 210
// The CS_default entry does not refer to a particular coordinate system,
// but rather to the value stored in default_coordinate_system, which in
// turn is loaded from the config variable "coordinate-system".
0 12 CS_zup_right 12 CS_zup_right 21
// Z-Up, Right-handed
1 12 CS_yup_right 12 CS_yup_right 21
// Y-Up, Right-handed
2 11 CS_zup_left 11 CS_zup_left 20
// Z-Up, Left-handed
3 11 CS_yup_left 11 CS_yup_left 20
// Y-Up, Left-handed
4 10 CS_invalid 10 CS_invalid 156
// CS_invalid is not a coordinate system at all.  It can be used in user-
// input processing code to indicate a contradictory coordinate system
// request.
5 0 0

3538 9 LVector3f 0 141313 9 LVector3f 9 LVector3f 0 0 0 1 2469 2502 3 3868 3869 3870 32 2470 2471 2472 2473 2474 2475 2476 2477 2478 2479 2480 2481 2482 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 2495 2496 2497 2498 2499 2500 2501 0 0 1 0 3531 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3539 9 LVector3d 0 141313 9 LVector3d 9 LVector3d 0 0 0 1 2503 2536 3 3871 3872 3873 32 2504 2505 2506 2507 2508 2509 2510 2511 2512 2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 2534 2535 0 0 1 0 3533 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3540 9 LVector3i 0 141313 9 LVector3i 9 LVector3i 0 0 0 1 2537 2562 3 3874 3875 3876 24 2538 2539 2540 2541 2542 2543 2544 2545 2546 2547 2548 2549 2550 2551 2552 2553 2554 2555 2556 2557 2558 2559 2560 2561 0 0 1 0 3535 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3541 8 LPoint3f 0 141313 8 LPoint3f 8 LPoint3f 0 0 0 1 2563 2585 3 3877 3878 3879 21 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 2577 2578 2579 2580 2581 2582 2583 2584 0 0 1 0 3531 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3542 8 LPoint3d 0 141313 8 LPoint3d 8 LPoint3d 0 0 0 1 2586 2608 3 3880 3881 3882 21 2587 2588 2589 2590 2591 2592 2593 2594 2595 2596 2597 2598 2599 2600 2601 2602 2603 2604 2605 2606 2607 0 0 1 0 3533 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3543 8 LPoint3i 0 141313 8 LPoint3i 8 LPoint3i 0 0 0 1 2609 2629 3 3883 3884 3885 19 2610 2611 2612 2613 2614 2615 2616 2617 2618 2619 2620 2621 2622 2623 2624 2625 2626 2627 2628 0 0 1 0 3535 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3544 10 LVecBase4f 0 141313 10 LVecBase4f 10 LVecBase4f 0 0 0 1 2630 2703 5 3886 3887 3888 3889 3890 72 2631 2632 2633 2634 2635 2636 2637 2638 2639 2640 2641 2642 2643 2644 2645 2646 2647 2648 2649 2650 2651 2652 2653 2654 2655 2656 2657 2658 2659 2660 2661 2662 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 2673 2674 2675 2676 2677 2678 2679 2680 2681 2682 2683 2684 2685 2686 2687 2688 2689 2690 2691 2692 2693 2694 2695 2696 2697 2698 2699 2700 2701 2702 0 0 0 0 1 3545 77
/**
 * This is the base class for all three-component vectors and points.
 */

3545 0 0 794624 12 LVecBase4f:: 0 3544 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase4f::num_components 0
4 6 is_int 18 LVecBase4f::is_int 0
0 0 0

3546 19 UnalignedLVecBase4f 0 141313 19 UnalignedLVecBase4f 19 UnalignedLVecBase4f 0 0 0 1 2704 2714 0 9 2705 2706 2707 2708 2709 2710 2711 2712 2713 0 0 0 0 1 3547 391
/**
 * This is an "unaligned" LVecBase4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LVecBase4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LVecBase4 to get actual use from
 * it.
 */

3547 0 0 794624 21 UnalignedLVecBase4f:: 0 3546 0 0 0 0 0 0 0 0 0 2 14 num_components 35 UnalignedLVecBase4f::num_components 0
4 6 is_int 27 UnalignedLVecBase4f::is_int 0
0 0 0

3548 10 LVecBase4d 0 141313 10 LVecBase4d 10 LVecBase4d 0 0 0 1 2715 2788 5 3891 3892 3893 3894 3895 72 2716 2717 2718 2719 2720 2721 2722 2723 2724 2725 2726 2727 2728 2729 2730 2731 2732 2733 2734 2735 2736 2737 2738 2739 2740 2741 2742 2743 2744 2745 2746 2747 2748 2749 2750 2751 2752 2753 2754 2755 2756 2757 2758 2759 2760 2761 2762 2763 2764 2765 2766 2767 2768 2769 2770 2771 2772 2773 2774 2775 2776 2777 2778 2779 2780 2781 2782 2783 2784 2785 2786 2787 0 0 0 0 1 3549 77
/**
 * This is the base class for all three-component vectors and points.
 */

3549 0 0 794624 12 LVecBase4d:: 0 3548 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase4d::num_components 0
4 6 is_int 18 LVecBase4d::is_int 0
0 0 0

3550 19 UnalignedLVecBase4d 0 141313 19 UnalignedLVecBase4d 19 UnalignedLVecBase4d 0 0 0 1 2789 2799 0 9 2790 2791 2792 2793 2794 2795 2796 2797 2798 0 0 0 0 1 3551 391
/**
 * This is an "unaligned" LVecBase4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LVecBase4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LVecBase4 to get actual use from
 * it.
 */

3551 0 0 794624 21 UnalignedLVecBase4d:: 0 3550 0 0 0 0 0 0 0 0 0 2 14 num_components 35 UnalignedLVecBase4d::num_components 0
4 6 is_int 27 UnalignedLVecBase4d::is_int 0
0 0 0

3552 10 LVecBase4i 0 141313 10 LVecBase4i 10 LVecBase4i 0 0 0 1 2800 2869 5 3896 3897 3898 3899 3900 68 2801 2802 2803 2804 2805 2806 2807 2808 2809 2810 2811 2812 2813 2814 2815 2816 2817 2818 2819 2820 2821 2822 2823 2824 2825 2826 2827 2828 2829 2830 2831 2832 2833 2834 2835 2836 2837 2838 2839 2840 2841 2842 2843 2844 2845 2846 2847 2848 2849 2850 2851 2852 2853 2854 2855 2856 2857 2858 2859 2860 2861 2862 2863 2864 2865 2866 2867 2868 0 0 0 0 1 3553 77
/**
 * This is the base class for all three-component vectors and points.
 */

3553 0 0 794624 12 LVecBase4i:: 0 3552 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase4i::num_components 0
4 6 is_int 18 LVecBase4i::is_int 0
1 0 0

3554 19 UnalignedLVecBase4i 0 141313 19 UnalignedLVecBase4i 19 UnalignedLVecBase4i 0 0 0 1 2870 2880 0 9 2871 2872 2873 2874 2875 2876 2877 2878 2879 0 0 0 0 1 3555 391
/**
 * This is an "unaligned" LVecBase4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LVecBase4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LVecBase4 to get actual use from
 * it.
 */

3555 0 0 794624 21 UnalignedLVecBase4i:: 0 3554 0 0 0 0 0 0 0 0 0 2 14 num_components 35 UnalignedLVecBase4i::num_components 0
4 6 is_int 27 UnalignedLVecBase4i::is_int 0
1 0 0

3556 9 LVector4f 0 141313 9 LVector4f 9 LVector4f 0 0 0 1 2881 2900 2 3901 3902 18 2882 2883 2884 2885 2886 2887 2888 2889 2890 2891 2892 2893 2894 2895 2896 2897 2898 2899 0 0 1 0 3544 0 0 0 0 52
/**
 * This is a four-component vector distance.
 */

3557 9 LVector4d 0 141313 9 LVector4d 9 LVector4d 0 0 0 1 2901 2920 2 3903 3904 18 2902 2903 2904 2905 2906 2907 2908 2909 2910 2911 2912 2913 2914 2915 2916 2917 2918 2919 0 0 1 0 3548 0 0 0 0 52
/**
 * This is a four-component vector distance.
 */

3558 9 LVector4i 0 141313 9 LVector4i 9 LVector4i 0 0 0 1 2921 2938 2 3905 3906 16 2922 2923 2924 2925 2926 2927 2928 2929 2930 2931 2932 2933 2934 2935 2936 2937 0 0 1 0 3552 0 0 0 0 52
/**
 * This is a four-component vector distance.
 */

3559 8 LPoint4f 0 141313 8 LPoint4f 8 LPoint4f 0 0 0 1 2939 2958 2 3907 3908 18 2940 2941 2942 2943 2944 2945 2946 2947 2948 2949 2950 2951 2952 2953 2954 2955 2956 2957 0 0 1 0 3544 0 0 0 0 51
/**
 * This is a four-component point in space.
 */

3560 8 LPoint4d 0 141313 8 LPoint4d 8 LPoint4d 0 0 0 1 2959 2978 2 3909 3910 18 2960 2961 2962 2963 2964 2965 2966 2967 2968 2969 2970 2971 2972 2973 2974 2975 2976 2977 0 0 1 0 3548 0 0 0 0 51
/**
 * This is a four-component point in space.
 */

3561 8 LPoint4i 0 141313 8 LPoint4i 8 LPoint4i 0 0 0 1 2979 2996 2 3911 3912 16 2980 2981 2982 2983 2984 2985 2986 2987 2988 2989 2990 2991 2992 2993 2994 2995 0 0 1 0 3552 0 0 0 0 51
/**
 * This is a four-component point in space.
 */

3562 9 LMatrix3f 0 141313 9 LMatrix3f 9 LMatrix3f 0 0 0 1 3007 3082 2 3913 3914 74 3008 3009 3010 3011 3012 3013 3014 3015 3016 3017 3018 3019 3020 3021 3022 3023 3024 3025 3026 3027 3028 3029 3030 3031 3032 3033 3034 3035 3036 3037 3038 3039 3040 3041 3042 3043 3044 3045 3046 3047 3048 3049 3050 3051 3052 3053 3054 3055 3056 3057 3058 3059 3060 3061 3062 3063 3064 3065 3066 3067 3068 3069 3070 3071 3072 3073 3074 3075 3076 3077 3078 3079 3080 3081 4 3921 3922 3923 3924 0 0 0 3 3563 3564 3565 231
/**
 * This is a 3-by-3 transform matrix.  It typically will represent either a
 * rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix
 * (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.
 */

3563 0 0 794624 11 LMatrix3f:: 0 3562 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix3f::num_components 0
9 6 is_int 17 LMatrix3f::is_int 0
0 0 0

3564 3 Row 0 403457 14 LMatrix3f::Row 14 LMatrix3f::Row 3562 0 0 1 3000 3001 0 2 2997 2998 0 1 2999 0 0 0 66
// These helper classes are used to support two-level operator [].

3565 4 CRow 0 403457 15 LMatrix3f::CRow 15 LMatrix3f::CRow 3562 0 0 1 3005 3006 0 2 3002 3003 0 1 3004 0 0 0 0

3566 9 LMatrix4f 0 141313 9 LMatrix4f 9 LMatrix4f 0 0 0 1 3095 3180 2 3915 3916 84 3096 3097 3098 3099 3100 3101 3102 3103 3104 3105 3106 3107 3108 3109 3110 3111 3112 3113 3114 3115 3116 3117 3118 3119 3120 3121 3122 3123 3124 3125 3126 3127 3128 3129 3130 3131 3132 3133 3134 3135 3136 3137 3138 3139 3140 3141 3142 3143 3144 3145 3146 3147 3148 3149 3150 3151 3152 3153 3154 3155 3156 3157 3158 3159 3160 3161 3162 3163 3164 3165 3166 3167 3168 3169 3170 3171 3172 3173 3174 3175 3176 3177 3178 3179 3 3925 3926 3927 0 0 0 3 3567 3568 3569 45
/**
 * This is a 4-by-4 transform matrix.
 */

3567 0 0 794624 11 LMatrix4f:: 0 3566 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix4f::num_components 0
16 6 is_int 17 LMatrix4f::is_int 0
0 0 0

3568 3 Row 0 403457 14 LMatrix4f::Row 14 LMatrix4f::Row 3566 0 0 1 3088 3089 0 2 3085 3086 0 1 3087 0 0 0 66
// These helper classes are used to support two-level operator [].

3569 4 CRow 0 403457 15 LMatrix4f::CRow 15 LMatrix4f::CRow 3566 0 0 1 3093 3094 0 2 3090 3091 0 1 3092 0 0 0 0

3570 18 UnalignedLMatrix4f 0 141313 18 UnalignedLMatrix4f 18 UnalignedLMatrix4f 0 0 0 1 3181 3190 0 8 3182 3183 3184 3185 3186 3187 3188 3189 0 0 0 0 1 3571 385
/**
 * This is an "unaligned" LMatrix4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LMatrix4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LMatrix4 to get actual use from it.
 */

3571 0 0 794624 20 UnalignedLMatrix4f:: 0 3570 0 0 0 0 0 0 0 0 0 1 14 num_components 34 UnalignedLMatrix4f::num_components 0
16 0 0

3572 9 LMatrix3d 0 141313 9 LMatrix3d 9 LMatrix3d 0 0 0 1 3201 3276 2 3917 3918 74 3202 3203 3204 3205 3206 3207 3208 3209 3210 3211 3212 3213 3214 3215 3216 3217 3218 3219 3220 3221 3222 3223 3224 3225 3226 3227 3228 3229 3230 3231 3232 3233 3234 3235 3236 3237 3238 3239 3240 3241 3242 3243 3244 3245 3246 3247 3248 3249 3250 3251 3252 3253 3254 3255 3256 3257 3258 3259 3260 3261 3262 3263 3264 3265 3266 3267 3268 3269 3270 3271 3272 3273 3274 3275 4 3928 3929 3930 3931 0 0 0 3 3573 3574 3575 231
/**
 * This is a 3-by-3 transform matrix.  It typically will represent either a
 * rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix
 * (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.
 */

3573 0 0 794624 11 LMatrix3d:: 0 3572 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix3d::num_components 0
9 6 is_int 17 LMatrix3d::is_int 0
0 0 0

3574 3 Row 0 403457 14 LMatrix3d::Row 14 LMatrix3d::Row 3572 0 0 1 3194 3195 0 2 3191 3192 0 1 3193 0 0 0 66
// These helper classes are used to support two-level operator [].

3575 4 CRow 0 403457 15 LMatrix3d::CRow 15 LMatrix3d::CRow 3572 0 0 1 3199 3200 0 2 3196 3197 0 1 3198 0 0 0 0

3576 9 LMatrix4d 0 141313 9 LMatrix4d 9 LMatrix4d 0 0 0 1 3287 3372 2 3919 3920 84 3288 3289 3290 3291 3292 3293 3294 3295 3296 3297 3298 3299 3300 3301 3302 3303 3304 3305 3306 3307 3308 3309 3310 3311 3312 3313 3314 3315 3316 3317 3318 3319 3320 3321 3322 3323 3324 3325 3326 3327 3328 3329 3330 3331 3332 3333 3334 3335 3336 3337 3338 3339 3340 3341 3342 3343 3344 3345 3346 3347 3348 3349 3350 3351 3352 3353 3354 3355 3356 3357 3358 3359 3360 3361 3362 3363 3364 3365 3366 3367 3368 3369 3370 3371 3 3932 3933 3934 0 0 0 3 3577 3578 3579 45
/**
 * This is a 4-by-4 transform matrix.
 */

3577 0 0 794624 11 LMatrix4d:: 0 3576 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix4d::num_components 0
16 6 is_int 17 LMatrix4d::is_int 0
0 0 0

3578 3 Row 0 403457 14 LMatrix4d::Row 14 LMatrix4d::Row 3576 0 0 1 3280 3281 0 2 3277 3278 0 1 3279 0 0 0 66
// These helper classes are used to support two-level operator [].

3579 4 CRow 0 403457 15 LMatrix4d::CRow 15 LMatrix4d::CRow 3576 0 0 1 3285 3286 0 2 3282 3283 0 1 3284 0 0 0 0

3580 18 UnalignedLMatrix4d 0 141313 18 UnalignedLMatrix4d 18 UnalignedLMatrix4d 0 0 0 1 3373 3382 0 8 3374 3375 3376 3377 3378 3379 3380 3381 0 0 0 0 1 3581 385
/**
 * This is an "unaligned" LMatrix4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LMatrix4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LMatrix4 to get actual use from it.
 */

3581 0 0 794624 20 UnalignedLMatrix4d:: 0 3580 0 0 0 0 0 0 0 0 0 1 14 num_components 34 UnalignedLMatrix4d::num_components 0
16 0 0

3582 12 LQuaternionf 0 141313 12 LQuaternionf 12 LQuaternionf 0 0 0 1 3391 3439 0 47 3392 3393 3394 3395 3396 3397 3398 3399 3400 3401 3402 3403 3404 3405 3406 3407 3408 3409 3410 3411 3412 3413 3414 3415 3416 3417 3418 3419 3420 3421 3422 3423 3424 3425 3426 3427 3428 3429 3430 3431 3432 3433 3434 3435 3436 3437 3438 0 0 1 0 3544 0 0 0 0 44
/**
 * This is the base quaternion class
 */

3583 12 LQuaterniond 0 141313 12 LQuaterniond 12 LQuaterniond 0 0 0 1 3440 3488 0 47 3441 3442 3443 3444 3445 3446 3447 3448 3449 3450 3451 3452 3453 3454 3455 3456 3457 3458 3459 3460 3461 3462 3463 3464 3465 3466 3467 3468 3469 3470 3471 3472 3473 3474 3475 3476 3477 3478 3479 3480 3481 3482 3483 3484 3485 3486 3487 0 0 1 0 3548 0 0 0 0 44
/**
 * This is the base quaternion class
 */

3584 10 LRotationf 0 141313 10 LRotationf 10 LRotationf 0 0 0 1 3489 3493 0 3 3490 3491 3492 0 0 1 0 3582 0 0 0 0 61
/**
 * This is a unit quaternion representing a rotation.
 */

3585 10 LRotationd 0 141313 10 LRotationd 10 LRotationd 0 0 0 1 3494 3498 0 3 3495 3496 3497 0 0 1 0 3583 0 0 0 0 61
/**
 * This is a unit quaternion representing a rotation.
 */

3586 13 LOrientationf 0 141313 13 LOrientationf 13 LOrientationf 0 0 0 1 3499 3502 0 2 3500 3501 0 0 1 0 3582 0 0 0 0 65
/**
 * This is a unit quaternion representing an orientation.
 */

3587 13 LOrientationd 0 141313 13 LOrientationd 13 LOrientationd 0 0 0 1 3503 3506 0 2 3504 3505 0 0 1 0 3583 0 0 0 0 65
/**
 * This is a unit quaternion representing an orientation.
 */

3588 8 LVertexf 0 2105345 8 LVertexf 8 LVertexf 0 0 3541 0 0 0 0 0 0 0 0 0 0

3589 8 LNormalf 0 2105345 8 LNormalf 8 LNormalf 0 0 3538 0 0 0 0 0 0 0 0 0 0

3590 10 LTexCoordf 0 2105345 10 LTexCoordf 10 LTexCoordf 0 0 3528 0 0 0 0 0 0 0 0 0 0

3591 11 LTexCoord3f 0 2105345 11 LTexCoord3f 11 LTexCoord3f 0 0 3541 0 0 0 0 0 0 0 0 0 0

3592 7 LColorf 0 2105345 7 LColorf 7 LColorf 0 0 3544 0 0 0 0 0 0 0 0 0 0

3593 10 LRGBColorf 0 2105345 10 LRGBColorf 10 LRGBColorf 0 0 3531 0 0 0 0 0 0 0 0 0 0

3594 8 LVertexd 0 2105345 8 LVertexd 8 LVertexd 0 0 3542 0 0 0 0 0 0 0 0 0 0

3595 8 LNormald 0 2105345 8 LNormald 8 LNormald 0 0 3539 0 0 0 0 0 0 0 0 0 0

3596 10 LTexCoordd 0 2105345 10 LTexCoordd 10 LTexCoordd 0 0 3529 0 0 0 0 0 0 0 0 0 0

3597 11 LTexCoord3d 0 2105345 11 LTexCoord3d 11 LTexCoord3d 0 0 3542 0 0 0 0 0 0 0 0 0 0

3598 7 LColord 0 2105345 7 LColord 7 LColord 0 0 3548 0 0 0 0 0 0 0 0 0 0

3599 10 LRGBColord 0 2105345 10 LRGBColord 10 LRGBColord 0 0 3533 0 0 0 0 0 0 0 0 0 0

3600 5 Mat4F 0 2105345 5 Mat4F 5 Mat4F 0 0 3566 0 0 0 0 0 0 0 0 0 0

3601 5 Mat3F 0 2105345 5 Mat3F 5 Mat3F 0 0 3562 0 0 0 0 0 0 0 0 0 0

3602 7 VBase4F 0 2105345 7 VBase4F 7 VBase4F 0 0 3544 0 0 0 0 0 0 0 0 0 0

3603 5 Vec4F 0 2105345 5 Vec4F 5 Vec4F 0 0 3556 0 0 0 0 0 0 0 0 0 0

3604 7 Point4F 0 2105345 7 Point4F 7 Point4F 0 0 3559 0 0 0 0 0 0 0 0 0 0

3605 7 VBase3F 0 2105345 7 VBase3F 7 VBase3F 0 0 3531 0 0 0 0 0 0 0 0 0 0

3606 5 Vec3F 0 2105345 5 Vec3F 5 Vec3F 0 0 3538 0 0 0 0 0 0 0 0 0 0

3607 7 Point3F 0 2105345 7 Point3F 7 Point3F 0 0 3541 0 0 0 0 0 0 0 0 0 0

3608 7 VBase2F 0 2105345 7 VBase2F 7 VBase2F 0 0 3516 0 0 0 0 0 0 0 0 0 0

3609 5 Vec2F 0 2105345 5 Vec2F 5 Vec2F 0 0 3525 0 0 0 0 0 0 0 0 0 0

3610 7 Point2F 0 2105345 7 Point2F 7 Point2F 0 0 3528 0 0 0 0 0 0 0 0 0 0

3611 5 QuatF 0 2105345 5 QuatF 5 QuatF 0 0 3582 0 0 0 0 0 0 0 0 0 0

3612 5 Mat4D 0 2105345 5 Mat4D 5 Mat4D 0 0 3576 0 0 0 0 0 0 0 0 0 0

3613 5 Mat3D 0 2105345 5 Mat3D 5 Mat3D 0 0 3572 0 0 0 0 0 0 0 0 0 0

3614 7 VBase4D 0 2105345 7 VBase4D 7 VBase4D 0 0 3548 0 0 0 0 0 0 0 0 0 0

3615 5 Vec4D 0 2105345 5 Vec4D 5 Vec4D 0 0 3557 0 0 0 0 0 0 0 0 0 0

3616 7 Point4D 0 2105345 7 Point4D 7 Point4D 0 0 3560 0 0 0 0 0 0 0 0 0 0

3617 7 VBase3D 0 2105345 7 VBase3D 7 VBase3D 0 0 3533 0 0 0 0 0 0 0 0 0 0

3618 5 Vec3D 0 2105345 5 Vec3D 5 Vec3D 0 0 3539 0 0 0 0 0 0 0 0 0 0

3619 7 Point3D 0 2105345 7 Point3D 7 Point3D 0 0 3542 0 0 0 0 0 0 0 0 0 0

3620 7 VBase2D 0 2105345 7 VBase2D 7 VBase2D 0 0 3519 0 0 0 0 0 0 0 0 0 0

3621 5 Vec2D 0 2105345 5 Vec2D 5 Vec2D 0 0 3526 0 0 0 0 0 0 0 0 0 0

3622 7 Point2D 0 2105345 7 Point2D 7 Point2D 0 0 3529 0 0 0 0 0 0 0 0 0 0

3623 5 QuatD 0 2105345 5 QuatD 5 QuatD 0 0 3583 0 0 0 0 0 0 0 0 0 0

3624 9 LVecBase2 0 2105345 9 LVecBase2 9 LVecBase2 0 0 3516 0 0 0 0 0 0 0 0 0 0

3625 7 LPoint2 0 2105345 7 LPoint2 7 LPoint2 0 0 3528 0 0 0 0 0 0 0 0 0 0

3626 8 LVector2 0 2105345 8 LVector2 8 LVector2 0 0 3525 0 0 0 0 0 0 0 0 0 0

3627 9 LVecBase3 0 2105345 9 LVecBase3 9 LVecBase3 0 0 3531 0 0 0 0 0 0 0 0 0 0

3628 7 LPoint3 0 2105345 7 LPoint3 7 LPoint3 0 0 3541 0 0 0 0 0 0 0 0 0 0

3629 8 LVector3 0 2105345 8 LVector3 8 LVector3 0 0 3538 0 0 0 0 0 0 0 0 0 0

3630 9 LVecBase4 0 2105345 9 LVecBase4 9 LVecBase4 0 0 3544 0 0 0 0 0 0 0 0 0 0

3631 7 LPoint4 0 2105345 7 LPoint4 7 LPoint4 0 0 3559 0 0 0 0 0 0 0 0 0 0

3632 8 LVector4 0 2105345 8 LVector4 8 LVector4 0 0 3556 0 0 0 0 0 0 0 0 0 0

3633 11 LQuaternion 0 2105345 11 LQuaternion 11 LQuaternion 0 0 3582 0 0 0 0 0 0 0 0 0 0

3634 9 LRotation 0 2105345 9 LRotation 9 LRotation 0 0 3584 0 0 0 0 0 0 0 0 0 0

3635 12 LOrientation 0 2105345 12 LOrientation 12 LOrientation 0 0 3586 0 0 0 0 0 0 0 0 0 0

3636 8 LMatrix3 0 2105345 8 LMatrix3 8 LMatrix3 0 0 3562 0 0 0 0 0 0 0 0 0 0

3637 8 LMatrix4 0 2105345 8 LMatrix4 8 LMatrix4 0 0 3566 0 0 0 0 0 0 0 0 0 0

3638 7 LVertex 0 2105345 7 LVertex 7 LVertex 0 0 3588 0 0 0 0 0 0 0 0 0 0

3639 7 LNormal 0 2105345 7 LNormal 7 LNormal 0 0 3589 0 0 0 0 0 0 0 0 0 0

3640 9 LTexCoord 0 2105345 9 LTexCoord 9 LTexCoord 0 0 3590 0 0 0 0 0 0 0 0 0 0

3641 10 LTexCoord3 0 2105345 10 LTexCoord3 10 LTexCoord3 0 0 3591 0 0 0 0 0 0 0 0 0 0

3642 6 LColor 0 2105345 6 LColor 6 LColor 0 0 3592 0 0 0 0 0 0 0 0 0 0

3643 9 LRGBColor 0 2105345 9 LRGBColor 9 LRGBColor 0 0 3593 0 0 0 0 0 0 0 0 0 0

3644 18 UnalignedLVecBase4 0 2105345 18 UnalignedLVecBase4 18 UnalignedLVecBase4 0 0 3546 0 0 0 0 0 0 0 0 0 0

3645 17 UnalignedLMatrix4 0 2105345 17 UnalignedLMatrix4 17 UnalignedLMatrix4 0 0 3570 0 0 0 0 0 0 0 0 0 0

3646 4 Mat4 0 2105345 4 Mat4 4 Mat4 0 0 3566 0 0 0 0 0 0 0 0 0 0

3647 4 Mat3 0 2105345 4 Mat3 4 Mat3 0 0 3562 0 0 0 0 0 0 0 0 0 0

3648 6 VBase4 0 2105345 6 VBase4 6 VBase4 0 0 3544 0 0 0 0 0 0 0 0 0 0

3649 4 Vec4 0 2105345 4 Vec4 4 Vec4 0 0 3556 0 0 0 0 0 0 0 0 0 0

3650 6 Point4 0 2105345 6 Point4 6 Point4 0 0 3559 0 0 0 0 0 0 0 0 0 0

3651 6 VBase3 0 2105345 6 VBase3 6 VBase3 0 0 3531 0 0 0 0 0 0 0 0 0 0

3652 4 Vec3 0 2105345 4 Vec3 4 Vec3 0 0 3538 0 0 0 0 0 0 0 0 0 0

3653 6 Point3 0 2105345 6 Point3 6 Point3 0 0 3541 0 0 0 0 0 0 0 0 0 0

3654 6 VBase2 0 2105345 6 VBase2 6 VBase2 0 0 3516 0 0 0 0 0 0 0 0 0 0

3655 4 Vec2 0 2105345 4 Vec2 4 Vec2 0 0 3525 0 0 0 0 0 0 0 0 0 0

3656 6 Point2 0 2105345 6 Point2 6 Point2 0 0 3528 0 0 0 0 0 0 0 0 0 0

3657 4 Quat 0 2105345 4 Quat 4 Quat 0 0 3582 0 0 0 0 0 0 0 0 0 0

3658 19 ConfigVariableColor 0 141313 19 ConfigVariableColor 19 ConfigVariableColor 0 0 0 1 3507 3514 0 5 3508 3510 3511 3512 3513 0 1 3509 1 0 3659 0 0 0 0 538
/**
 * This is a convenience class to specialize ConfigVariable as a set of
 * floating-point types representing a color value.
 *
 * It interprets the color differently depending on how many words were
 * specified: if only one, it is interpreted as a shade of gray with alpha 1.
 * If two values were specified, a grayscale and alpha pair.  If three, a set
 * of R, G, B values with alpha 1, and if four, a complete RGBA color.
 *
 * This isn't defined in dtool because it relies on the LColor class, which is
 * defined in linmath.
 */

3659 14 ConfigVariable 0 2048 14 ConfigVariable 14 ConfigVariable 0 0 0 0 0 0 0 0 0 0 0 0 415
/**
 * This is a generic, untyped ConfigVariable.  It is also the base class for
 * the typed ConfigVariables, and contains all of the code common to
 * ConfigVariables of all types (except ConfigVariableList, which is a bit of
 * a special case).
 *
 * Mostly, this class serves as a thin wrapper around ConfigVariableCore
 * and/or ConfigDeclaration, more or less duplicating the interface presented
 * there.
 */

3660 13 MathNumbers * 0 8576 13 MathNumbers * 13 MathNumbers * 0 0 3515 0 0 0 0 0 0 0 0 0 0

3661 19 MathNumbers const * 0 8576 19 MathNumbers const * 19 MathNumbers const * 0 0 3662 0 0 0 0 0 0 0 0 0 0

3662 17 MathNumbers const 0 8832 17 MathNumbers const 17 MathNumbers const 0 0 3515 0 0 0 0 0 0 0 0 0 0

3663 12 LVecBase2f * 0 8576 12 LVecBase2f * 12 LVecBase2f * 0 0 3516 0 0 0 0 0 0 0 0 0 0

3664 18 LVecBase2f const * 0 8576 18 LVecBase2f const * 18 LVecBase2f const * 0 0 3665 0 0 0 0 0 0 0 0 0 0

3665 16 LVecBase2f const 0 8832 16 LVecBase2f const 16 LVecBase2f const 0 0 3516 0 0 0 0 0 0 0 0 0 0

3666 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 3667 0 0 0 0 0 0 0 0 0 0

3667 17 unsigned long int 0 8214 17 unsigned long int 17 unsigned long int 0 1 0 0 0 0 0 0 0 0 0 0 0

3668 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

3669 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 3670 0 0 0 0 0 0 0 0 0 0

3670 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 3671 0 0 0 0 0 0 0 0 0 0

3671 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0

3672 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

3673 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

3674 23 ChecksumHashGenerator * 0 8576 23 ChecksumHashGenerator * 23 ChecksumHashGenerator * 0 0 3675 0 0 0 0 0 0 0 0 0 0

3675 21 ChecksumHashGenerator 0 2048 21 ChecksumHashGenerator 21 ChecksumHashGenerator 0 0 0 0 0 0 0 0 0 0 0 0 125
/**
 * This is a specific kind of HashGenerator that simply adds up all of the
 * ints.  Nothing fancy, and pretty quick.
 */

3676 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 3677 0 0 0 0 0 0 0 0 0 0

3677 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

3678 10 Datagram * 0 8576 10 Datagram * 10 Datagram * 0 0 3679 0 0 0 0 0 0 0 0 0 0

3679 8 Datagram 0 2048 8 Datagram 8 Datagram 0 0 0 0 0 0 0 0 0 0 0 0 565
/**
 * An ordered list of data elements, formatted in memory for transmission over
 * a socket or writing to a data file.
 *
 * Data elements should be added one at a time, in order, to the Datagram.
 * The nature and contents of the data elements are totally up to the user.
 * When a Datagram has been transmitted and received, its data elements may be
 * extracted using a DatagramIterator; it is up to the caller to know the
 * correct type of each data element in order.
 *
 * A Datagram is itself headerless; it is simply a collection of data
 * elements.
 */

3680 18 DatagramIterator * 0 8576 18 DatagramIterator * 18 DatagramIterator * 0 0 3681 0 0 0 0 0 0 0 0 0 0

3681 16 DatagramIterator 0 2048 16 DatagramIterator 16 DatagramIterator 0 0 0 0 0 0 0 0 0 0 0 0 215
/**
 * A class to retrieve the individual data elements previously stored in a
 * Datagram.  Elements may be retrieved one at a time; it is up to the caller
 * to know the correct type and order of each element.
 */

3682 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

3683 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 3682 0 0 0 0 0 0 0 0 0 0

3684 12 LVecBase2d * 0 8576 12 LVecBase2d * 12 LVecBase2d * 0 0 3519 0 0 0 0 0 0 0 0 0 0

3685 18 LVecBase2d const * 0 8576 18 LVecBase2d const * 18 LVecBase2d const * 0 0 3686 0 0 0 0 0 0 0 0 0 0

3686 16 LVecBase2d const 0 8832 16 LVecBase2d const 16 LVecBase2d const 0 0 3519 0 0 0 0 0 0 0 0 0 0

3687 12 LVecBase2i * 0 8576 12 LVecBase2i * 12 LVecBase2i * 0 0 3522 0 0 0 0 0 0 0 0 0 0

3688 18 LVecBase2i const * 0 8576 18 LVecBase2i const * 18 LVecBase2i const * 0 0 3689 0 0 0 0 0 0 0 0 0 0

3689 16 LVecBase2i const 0 8832 16 LVecBase2i const 16 LVecBase2i const 0 0 3522 0 0 0 0 0 0 0 0 0 0

3690 11 LVector2f * 0 8576 11 LVector2f * 11 LVector2f * 0 0 3525 0 0 0 0 0 0 0 0 0 0

3691 17 LVector2f const * 0 8576 17 LVector2f const * 17 LVector2f const * 0 0 3692 0 0 0 0 0 0 0 0 0 0

3692 15 LVector2f const 0 8832 15 LVector2f const 15 LVector2f const 0 0 3525 0 0 0 0 0 0 0 0 0 0

3693 11 LVector2d * 0 8576 11 LVector2d * 11 LVector2d * 0 0 3526 0 0 0 0 0 0 0 0 0 0

3694 17 LVector2d const * 0 8576 17 LVector2d const * 17 LVector2d const * 0 0 3695 0 0 0 0 0 0 0 0 0 0

3695 15 LVector2d const 0 8832 15 LVector2d const 15 LVector2d const 0 0 3526 0 0 0 0 0 0 0 0 0 0

3696 11 LVector2i * 0 8576 11 LVector2i * 11 LVector2i * 0 0 3527 0 0 0 0 0 0 0 0 0 0

3697 17 LVector2i const * 0 8576 17 LVector2i const * 17 LVector2i const * 0 0 3698 0 0 0 0 0 0 0 0 0 0

3698 15 LVector2i const 0 8832 15 LVector2i const 15 LVector2i const 0 0 3527 0 0 0 0 0 0 0 0 0 0

3699 10 LPoint2f * 0 8576 10 LPoint2f * 10 LPoint2f * 0 0 3528 0 0 0 0 0 0 0 0 0 0

3700 16 LPoint2f const * 0 8576 16 LPoint2f const * 16 LPoint2f const * 0 0 3701 0 0 0 0 0 0 0 0 0 0

3701 14 LPoint2f const 0 8832 14 LPoint2f const 14 LPoint2f const 0 0 3528 0 0 0 0 0 0 0 0 0 0

3702 10 LPoint2d * 0 8576 10 LPoint2d * 10 LPoint2d * 0 0 3529 0 0 0 0 0 0 0 0 0 0

3703 16 LPoint2d const * 0 8576 16 LPoint2d const * 16 LPoint2d const * 0 0 3704 0 0 0 0 0 0 0 0 0 0

3704 14 LPoint2d const 0 8832 14 LPoint2d const 14 LPoint2d const 0 0 3529 0 0 0 0 0 0 0 0 0 0

3705 10 LPoint2i * 0 8576 10 LPoint2i * 10 LPoint2i * 0 0 3530 0 0 0 0 0 0 0 0 0 0

3706 16 LPoint2i const * 0 8576 16 LPoint2i const * 16 LPoint2i const * 0 0 3707 0 0 0 0 0 0 0 0 0 0

3707 14 LPoint2i const 0 8832 14 LPoint2i const 14 LPoint2i const 0 0 3530 0 0 0 0 0 0 0 0 0 0

3708 12 LVecBase3f * 0 8576 12 LVecBase3f * 12 LVecBase3f * 0 0 3531 0 0 0 0 0 0 0 0 0 0

3709 18 LVecBase3f const * 0 8576 18 LVecBase3f const * 18 LVecBase3f const * 0 0 3710 0 0 0 0 0 0 0 0 0 0

3710 16 LVecBase3f const 0 8832 16 LVecBase3f const 16 LVecBase3f const 0 0 3531 0 0 0 0 0 0 0 0 0 0

3711 12 LVecBase3d * 0 8576 12 LVecBase3d * 12 LVecBase3d * 0 0 3533 0 0 0 0 0 0 0 0 0 0

3712 18 LVecBase3d const * 0 8576 18 LVecBase3d const * 18 LVecBase3d const * 0 0 3713 0 0 0 0 0 0 0 0 0 0

3713 16 LVecBase3d const 0 8832 16 LVecBase3d const 16 LVecBase3d const 0 0 3533 0 0 0 0 0 0 0 0 0 0

3714 12 LVecBase3i * 0 8576 12 LVecBase3i * 12 LVecBase3i * 0 0 3535 0 0 0 0 0 0 0 0 0 0

3715 18 LVecBase3i const * 0 8576 18 LVecBase3i const * 18 LVecBase3i const * 0 0 3716 0 0 0 0 0 0 0 0 0 0

3716 16 LVecBase3i const 0 8832 16 LVecBase3i const 16 LVecBase3i const 0 0 3535 0 0 0 0 0 0 0 0 0 0

3717 11 LVector3f * 0 8576 11 LVector3f * 11 LVector3f * 0 0 3538 0 0 0 0 0 0 0 0 0 0

3718 17 LVector3f const * 0 8576 17 LVector3f const * 17 LVector3f const * 0 0 3719 0 0 0 0 0 0 0 0 0 0

3719 15 LVector3f const 0 8832 15 LVector3f const 15 LVector3f const 0 0 3538 0 0 0 0 0 0 0 0 0 0

3720 11 LVector3d * 0 8576 11 LVector3d * 11 LVector3d * 0 0 3539 0 0 0 0 0 0 0 0 0 0

3721 17 LVector3d const * 0 8576 17 LVector3d const * 17 LVector3d const * 0 0 3722 0 0 0 0 0 0 0 0 0 0

3722 15 LVector3d const 0 8832 15 LVector3d const 15 LVector3d const 0 0 3539 0 0 0 0 0 0 0 0 0 0

3723 11 LVector3i * 0 8576 11 LVector3i * 11 LVector3i * 0 0 3540 0 0 0 0 0 0 0 0 0 0

3724 17 LVector3i const * 0 8576 17 LVector3i const * 17 LVector3i const * 0 0 3725 0 0 0 0 0 0 0 0 0 0

3725 15 LVector3i const 0 8832 15 LVector3i const 15 LVector3i const 0 0 3540 0 0 0 0 0 0 0 0 0 0

3726 10 LPoint3f * 0 8576 10 LPoint3f * 10 LPoint3f * 0 0 3541 0 0 0 0 0 0 0 0 0 0

3727 16 LPoint3f const * 0 8576 16 LPoint3f const * 16 LPoint3f const * 0 0 3728 0 0 0 0 0 0 0 0 0 0

3728 14 LPoint3f const 0 8832 14 LPoint3f const 14 LPoint3f const 0 0 3541 0 0 0 0 0 0 0 0 0 0

3729 10 LPoint3d * 0 8576 10 LPoint3d * 10 LPoint3d * 0 0 3542 0 0 0 0 0 0 0 0 0 0

3730 16 LPoint3d const * 0 8576 16 LPoint3d const * 16 LPoint3d const * 0 0 3731 0 0 0 0 0 0 0 0 0 0

3731 14 LPoint3d const 0 8832 14 LPoint3d const 14 LPoint3d const 0 0 3542 0 0 0 0 0 0 0 0 0 0

3732 10 LPoint3i * 0 8576 10 LPoint3i * 10 LPoint3i * 0 0 3543 0 0 0 0 0 0 0 0 0 0

3733 16 LPoint3i const * 0 8576 16 LPoint3i const * 16 LPoint3i const * 0 0 3734 0 0 0 0 0 0 0 0 0 0

3734 14 LPoint3i const 0 8832 14 LPoint3i const 14 LPoint3i const 0 0 3543 0 0 0 0 0 0 0 0 0 0

3735 12 LVecBase4f * 0 8576 12 LVecBase4f * 12 LVecBase4f * 0 0 3544 0 0 0 0 0 0 0 0 0 0

3736 18 LVecBase4f const * 0 8576 18 LVecBase4f const * 18 LVecBase4f const * 0 0 3737 0 0 0 0 0 0 0 0 0 0

3737 16 LVecBase4f const 0 8832 16 LVecBase4f const 16 LVecBase4f const 0 0 3544 0 0 0 0 0 0 0 0 0 0

3738 27 UnalignedLVecBase4f const * 0 8576 27 UnalignedLVecBase4f const * 27 UnalignedLVecBase4f const * 0 0 3739 0 0 0 0 0 0 0 0 0 0

3739 25 UnalignedLVecBase4f const 0 8832 25 UnalignedLVecBase4f const 25 UnalignedLVecBase4f const 0 0 3546 0 0 0 0 0 0 0 0 0 0

3740 21 UnalignedLVecBase4f * 0 8576 21 UnalignedLVecBase4f * 21 UnalignedLVecBase4f * 0 0 3546 0 0 0 0 0 0 0 0 0 0

3741 12 LVecBase4d * 0 8576 12 LVecBase4d * 12 LVecBase4d * 0 0 3548 0 0 0 0 0 0 0 0 0 0

3742 18 LVecBase4d const * 0 8576 18 LVecBase4d const * 18 LVecBase4d const * 0 0 3743 0 0 0 0 0 0 0 0 0 0

3743 16 LVecBase4d const 0 8832 16 LVecBase4d const 16 LVecBase4d const 0 0 3548 0 0 0 0 0 0 0 0 0 0

3744 27 UnalignedLVecBase4d const * 0 8576 27 UnalignedLVecBase4d const * 27 UnalignedLVecBase4d const * 0 0 3745 0 0 0 0 0 0 0 0 0 0

3745 25 UnalignedLVecBase4d const 0 8832 25 UnalignedLVecBase4d const 25 UnalignedLVecBase4d const 0 0 3550 0 0 0 0 0 0 0 0 0 0

3746 21 UnalignedLVecBase4d * 0 8576 21 UnalignedLVecBase4d * 21 UnalignedLVecBase4d * 0 0 3550 0 0 0 0 0 0 0 0 0 0

3747 12 LVecBase4i * 0 8576 12 LVecBase4i * 12 LVecBase4i * 0 0 3552 0 0 0 0 0 0 0 0 0 0

3748 18 LVecBase4i const * 0 8576 18 LVecBase4i const * 18 LVecBase4i const * 0 0 3749 0 0 0 0 0 0 0 0 0 0

3749 16 LVecBase4i const 0 8832 16 LVecBase4i const 16 LVecBase4i const 0 0 3552 0 0 0 0 0 0 0 0 0 0

3750 27 UnalignedLVecBase4i const * 0 8576 27 UnalignedLVecBase4i const * 27 UnalignedLVecBase4i const * 0 0 3751 0 0 0 0 0 0 0 0 0 0

3751 25 UnalignedLVecBase4i const 0 8832 25 UnalignedLVecBase4i const 25 UnalignedLVecBase4i const 0 0 3554 0 0 0 0 0 0 0 0 0 0

3752 21 UnalignedLVecBase4i * 0 8576 21 UnalignedLVecBase4i * 21 UnalignedLVecBase4i * 0 0 3554 0 0 0 0 0 0 0 0 0 0

3753 11 LVector4f * 0 8576 11 LVector4f * 11 LVector4f * 0 0 3556 0 0 0 0 0 0 0 0 0 0

3754 17 LVector4f const * 0 8576 17 LVector4f const * 17 LVector4f const * 0 0 3755 0 0 0 0 0 0 0 0 0 0

3755 15 LVector4f const 0 8832 15 LVector4f const 15 LVector4f const 0 0 3556 0 0 0 0 0 0 0 0 0 0

3756 11 LVector4d * 0 8576 11 LVector4d * 11 LVector4d * 0 0 3557 0 0 0 0 0 0 0 0 0 0

3757 17 LVector4d const * 0 8576 17 LVector4d const * 17 LVector4d const * 0 0 3758 0 0 0 0 0 0 0 0 0 0

3758 15 LVector4d const 0 8832 15 LVector4d const 15 LVector4d const 0 0 3557 0 0 0 0 0 0 0 0 0 0

3759 11 LVector4i * 0 8576 11 LVector4i * 11 LVector4i * 0 0 3558 0 0 0 0 0 0 0 0 0 0

3760 17 LVector4i const * 0 8576 17 LVector4i const * 17 LVector4i const * 0 0 3761 0 0 0 0 0 0 0 0 0 0

3761 15 LVector4i const 0 8832 15 LVector4i const 15 LVector4i const 0 0 3558 0 0 0 0 0 0 0 0 0 0

3762 10 LPoint4f * 0 8576 10 LPoint4f * 10 LPoint4f * 0 0 3559 0 0 0 0 0 0 0 0 0 0

3763 16 LPoint4f const * 0 8576 16 LPoint4f const * 16 LPoint4f const * 0 0 3764 0 0 0 0 0 0 0 0 0 0

3764 14 LPoint4f const 0 8832 14 LPoint4f const 14 LPoint4f const 0 0 3559 0 0 0 0 0 0 0 0 0 0

3765 10 LPoint4d * 0 8576 10 LPoint4d * 10 LPoint4d * 0 0 3560 0 0 0 0 0 0 0 0 0 0

3766 16 LPoint4d const * 0 8576 16 LPoint4d const * 16 LPoint4d const * 0 0 3767 0 0 0 0 0 0 0 0 0 0

3767 14 LPoint4d const 0 8832 14 LPoint4d const 14 LPoint4d const 0 0 3560 0 0 0 0 0 0 0 0 0 0

3768 10 LPoint4i * 0 8576 10 LPoint4i * 10 LPoint4i * 0 0 3561 0 0 0 0 0 0 0 0 0 0

3769 16 LPoint4i const * 0 8576 16 LPoint4i const * 16 LPoint4i const * 0 0 3770 0 0 0 0 0 0 0 0 0 0

3770 14 LPoint4i const 0 8832 14 LPoint4i const 14 LPoint4i const 0 0 3561 0 0 0 0 0 0 0 0 0 0

3771 11 LMatrix3f * 0 8576 11 LMatrix3f * 11 LMatrix3f * 0 0 3562 0 0 0 0 0 0 0 0 0 0

3772 17 LMatrix3f const * 0 8576 17 LMatrix3f const * 17 LMatrix3f const * 0 0 3773 0 0 0 0 0 0 0 0 0 0

3773 15 LMatrix3f const 0 8832 15 LMatrix3f const 15 LMatrix3f const 0 0 3562 0 0 0 0 0 0 0 0 0 0

3774 5 Row * 0 8576 16 LMatrix3f::Row * 16 LMatrix3f::Row * 0 0 3564 0 0 0 0 0 0 0 0 0 0

3775 6 CRow * 0 8576 17 LMatrix3f::CRow * 17 LMatrix3f::CRow * 0 0 3565 0 0 0 0 0 0 0 0 0 0

3776 17 LMatrix4f const * 0 8576 17 LMatrix4f const * 17 LMatrix4f const * 0 0 3777 0 0 0 0 0 0 0 0 0 0

3777 15 LMatrix4f const 0 8832 15 LMatrix4f const 15 LMatrix4f const 0 0 3566 0 0 0 0 0 0 0 0 0 0

3778 11 Row const * 0 8576 22 LMatrix3f::Row const * 22 LMatrix3f::Row const * 0 0 3779 0 0 0 0 0 0 0 0 0 0

3779 9 Row const 0 8832 20 LMatrix3f::Row const 20 LMatrix3f::Row const 0 0 3564 0 0 0 0 0 0 0 0 0 0

3780 12 CRow const * 0 8576 23 LMatrix3f::CRow const * 23 LMatrix3f::CRow const * 0 0 3781 0 0 0 0 0 0 0 0 0 0

3781 10 CRow const 0 8832 21 LMatrix3f::CRow const 21 LMatrix3f::CRow const 0 0 3565 0 0 0 0 0 0 0 0 0 0

3782 11 LMatrix4f * 0 8576 11 LMatrix4f * 11 LMatrix4f * 0 0 3566 0 0 0 0 0 0 0 0 0 0

3783 26 UnalignedLMatrix4f const * 0 8576 26 UnalignedLMatrix4f const * 26 UnalignedLMatrix4f const * 0 0 3784 0 0 0 0 0 0 0 0 0 0

3784 24 UnalignedLMatrix4f const 0 8832 24 UnalignedLMatrix4f const 24 UnalignedLMatrix4f const 0 0 3570 0 0 0 0 0 0 0 0 0 0

3785 5 Row * 0 8576 16 LMatrix4f::Row * 16 LMatrix4f::Row * 0 0 3568 0 0 0 0 0 0 0 0 0 0

3786 6 CRow * 0 8576 17 LMatrix4f::CRow * 17 LMatrix4f::CRow * 0 0 3569 0 0 0 0 0 0 0 0 0 0

3787 11 Row const * 0 8576 22 LMatrix4f::Row const * 22 LMatrix4f::Row const * 0 0 3788 0 0 0 0 0 0 0 0 0 0

3788 9 Row const 0 8832 20 LMatrix4f::Row const 20 LMatrix4f::Row const 0 0 3568 0 0 0 0 0 0 0 0 0 0

3789 12 CRow const * 0 8576 23 LMatrix4f::CRow const * 23 LMatrix4f::CRow const * 0 0 3790 0 0 0 0 0 0 0 0 0 0

3790 10 CRow const 0 8832 21 LMatrix4f::CRow const 21 LMatrix4f::CRow const 0 0 3569 0 0 0 0 0 0 0 0 0 0

3791 20 UnalignedLMatrix4f * 0 8576 20 UnalignedLMatrix4f * 20 UnalignedLMatrix4f * 0 0 3570 0 0 0 0 0 0 0 0 0 0

3792 11 LMatrix3d * 0 8576 11 LMatrix3d * 11 LMatrix3d * 0 0 3572 0 0 0 0 0 0 0 0 0 0

3793 17 LMatrix3d const * 0 8576 17 LMatrix3d const * 17 LMatrix3d const * 0 0 3794 0 0 0 0 0 0 0 0 0 0

3794 15 LMatrix3d const 0 8832 15 LMatrix3d const 15 LMatrix3d const 0 0 3572 0 0 0 0 0 0 0 0 0 0

3795 5 Row * 0 8576 16 LMatrix3d::Row * 16 LMatrix3d::Row * 0 0 3574 0 0 0 0 0 0 0 0 0 0

3796 6 CRow * 0 8576 17 LMatrix3d::CRow * 17 LMatrix3d::CRow * 0 0 3575 0 0 0 0 0 0 0 0 0 0

3797 17 LMatrix4d const * 0 8576 17 LMatrix4d const * 17 LMatrix4d const * 0 0 3798 0 0 0 0 0 0 0 0 0 0

3798 15 LMatrix4d const 0 8832 15 LMatrix4d const 15 LMatrix4d const 0 0 3576 0 0 0 0 0 0 0 0 0 0

3799 11 Row const * 0 8576 22 LMatrix3d::Row const * 22 LMatrix3d::Row const * 0 0 3800 0 0 0 0 0 0 0 0 0 0

3800 9 Row const 0 8832 20 LMatrix3d::Row const 20 LMatrix3d::Row const 0 0 3574 0 0 0 0 0 0 0 0 0 0

3801 12 CRow const * 0 8576 23 LMatrix3d::CRow const * 23 LMatrix3d::CRow const * 0 0 3802 0 0 0 0 0 0 0 0 0 0

3802 10 CRow const 0 8832 21 LMatrix3d::CRow const 21 LMatrix3d::CRow const 0 0 3575 0 0 0 0 0 0 0 0 0 0

3803 11 LMatrix4d * 0 8576 11 LMatrix4d * 11 LMatrix4d * 0 0 3576 0 0 0 0 0 0 0 0 0 0

3804 26 UnalignedLMatrix4d const * 0 8576 26 UnalignedLMatrix4d const * 26 UnalignedLMatrix4d const * 0 0 3805 0 0 0 0 0 0 0 0 0 0

3805 24 UnalignedLMatrix4d const 0 8832 24 UnalignedLMatrix4d const 24 UnalignedLMatrix4d const 0 0 3580 0 0 0 0 0 0 0 0 0 0

3806 5 Row * 0 8576 16 LMatrix4d::Row * 16 LMatrix4d::Row * 0 0 3578 0 0 0 0 0 0 0 0 0 0

3807 6 CRow * 0 8576 17 LMatrix4d::CRow * 17 LMatrix4d::CRow * 0 0 3579 0 0 0 0 0 0 0 0 0 0

3808 11 Row const * 0 8576 22 LMatrix4d::Row const * 22 LMatrix4d::Row const * 0 0 3809 0 0 0 0 0 0 0 0 0 0

3809 9 Row const 0 8832 20 LMatrix4d::Row const 20 LMatrix4d::Row const 0 0 3578 0 0 0 0 0 0 0 0 0 0

3810 12 CRow const * 0 8576 23 LMatrix4d::CRow const * 23 LMatrix4d::CRow const * 0 0 3811 0 0 0 0 0 0 0 0 0 0

3811 10 CRow const 0 8832 21 LMatrix4d::CRow const 21 LMatrix4d::CRow const 0 0 3579 0 0 0 0 0 0 0 0 0 0

3812 20 UnalignedLMatrix4d * 0 8576 20 UnalignedLMatrix4d * 20 UnalignedLMatrix4d * 0 0 3580 0 0 0 0 0 0 0 0 0 0

3813 14 LQuaternionf * 0 8576 14 LQuaternionf * 14 LQuaternionf * 0 0 3582 0 0 0 0 0 0 0 0 0 0

3814 20 LQuaternionf const * 0 8576 20 LQuaternionf const * 20 LQuaternionf const * 0 0 3815 0 0 0 0 0 0 0 0 0 0

3815 18 LQuaternionf const 0 8832 18 LQuaternionf const 18 LQuaternionf const 0 0 3582 0 0 0 0 0 0 0 0 0 0

3816 14 LQuaterniond * 0 8576 14 LQuaterniond * 14 LQuaterniond * 0 0 3583 0 0 0 0 0 0 0 0 0 0

3817 20 LQuaterniond const * 0 8576 20 LQuaterniond const * 20 LQuaterniond const * 0 0 3818 0 0 0 0 0 0 0 0 0 0

3818 18 LQuaterniond const 0 8832 18 LQuaterniond const 18 LQuaterniond const 0 0 3583 0 0 0 0 0 0 0 0 0 0

3819 12 LRotationf * 0 8576 12 LRotationf * 12 LRotationf * 0 0 3584 0 0 0 0 0 0 0 0 0 0

3820 18 LRotationf const * 0 8576 18 LRotationf const * 18 LRotationf const * 0 0 3821 0 0 0 0 0 0 0 0 0 0

3821 16 LRotationf const 0 8832 16 LRotationf const 16 LRotationf const 0 0 3584 0 0 0 0 0 0 0 0 0 0

3822 12 LRotationd * 0 8576 12 LRotationd * 12 LRotationd * 0 0 3585 0 0 0 0 0 0 0 0 0 0

3823 18 LRotationd const * 0 8576 18 LRotationd const * 18 LRotationd const * 0 0 3824 0 0 0 0 0 0 0 0 0 0

3824 16 LRotationd const 0 8832 16 LRotationd const 16 LRotationd const 0 0 3585 0 0 0 0 0 0 0 0 0 0

3825 15 LOrientationf * 0 8576 15 LOrientationf * 15 LOrientationf * 0 0 3586 0 0 0 0 0 0 0 0 0 0

3826 21 LOrientationf const * 0 8576 21 LOrientationf const * 21 LOrientationf const * 0 0 3827 0 0 0 0 0 0 0 0 0 0

3827 19 LOrientationf const 0 8832 19 LOrientationf const 19 LOrientationf const 0 0 3586 0 0 0 0 0 0 0 0 0 0

3828 15 LOrientationd * 0 8576 15 LOrientationd * 15 LOrientationd * 0 0 3587 0 0 0 0 0 0 0 0 0 0

3829 21 LOrientationd const * 0 8576 21 LOrientationd const * 21 LOrientationd const * 0 0 3830 0 0 0 0 0 0 0 0 0 0

3830 19 LOrientationd const 0 8832 19 LOrientationd const 19 LOrientationd const 0 0 3587 0 0 0 0 0 0 0 0 0 0

3831 27 ConfigVariableColor const * 0 8576 27 ConfigVariableColor const * 27 ConfigVariableColor const * 0 0 3832 0 0 0 0 0 0 0 0 0 0

3832 25 ConfigVariableColor const 0 8832 25 ConfigVariableColor const 25 ConfigVariableColor const 0 0 3658 0 0 0 0 0 0 0 0 0 0

3833 21 ConfigVariableColor * 0 8576 21 ConfigVariableColor * 21 ConfigVariableColor * 0 0 3658 0 0 0 0 0 0 0 0 0 0

3834 14 LColor const * 0 8576 14 LColor const * 14 LColor const * 0 0 3835 0 0 0 0 0 0 0 0 0 0

3835 12 LColor const 0 8832 12 LColor const 12 LColor const 0 0 3642 0 0 0 0 0 0 0 0 0 0

3836 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 3518 0 0 0 0 0 0 0 0 0 0

3837 8 LColor * 0 8576 8 LColor * 8 LColor * 0 0 3642 0 0 0 0 0 0 0 0 0 0

3838 38 double const [::num_matrix_components] 0 4202496 38 double const [::num_matrix_components] 38 double const [::num_matrix_components] 0 0 3839 12 0 0 0 0 0 0 0 0 0 0

3839 12 double const 0 8832 12 double const 12 double const 0 0 3521 0 0 0 0 0 0 0 0 0 0

3840 37 float const [::num_matrix_components] 0 4202496 37 float const [::num_matrix_components] 37 float const [::num_matrix_components] 0 0 3841 12 0 0 0 0 0 0 0 0 0 0

3841 11 float const 0 8832 11 float const 11 float const 0 0 3518 0 0 0 0 0 0 0 0 0 0

3842 32 double [::num_matrix_components] 0 4202496 32 double [::num_matrix_components] 32 double [::num_matrix_components] 0 0 3521 12 0 0 0 0 0 0 0 0 0 0

3843 31 float [::num_matrix_components] 0 4202496 31 float [::num_matrix_components] 31 float [::num_matrix_components] 0 0 3518 12 0 0 0 0 0 0 0 0 0 0

0
77
3844 1 x 0 6 3518 1986 1988 0 0 0 0 0 0 13 LVecBase2f::x 0

3845 1 y 0 6 3518 1987 1989 0 0 0 0 0 0 13 LVecBase2f::y 0

3846 1 x 0 6 3521 2049 2051 0 0 0 0 0 0 13 LVecBase2d::x 0

3847 1 y 0 6 3521 2050 2052 0 0 0 0 0 0 13 LVecBase2d::y 0

3848 1 x 0 6 3524 2112 2114 0 0 0 0 0 0 13 LVecBase2i::x 0

3849 1 y 0 6 3524 2113 2115 0 0 0 0 0 0 13 LVecBase2i::y 0

3850 1 x 0 6 3518 2267 2271 0 0 0 0 0 0 13 LVecBase3f::x 0

3851 1 y 0 6 3518 2268 2272 0 0 0 0 0 0 13 LVecBase3f::y 0

3852 1 z 0 6 3518 2269 2273 0 0 0 0 0 0 13 LVecBase3f::z 0

3853 2 xy 0 2 3516 2274 0 0 0 0 0 0 0 14 LVecBase3f::xy 0

3854 2 xz 0 2 3516 2275 0 0 0 0 0 0 0 14 LVecBase3f::xz 0

3855 2 yz 0 2 3516 2276 0 0 0 0 0 0 0 14 LVecBase3f::yz 0

3856 1 x 0 6 3521 2340 2344 0 0 0 0 0 0 13 LVecBase3d::x 0

3857 1 y 0 6 3521 2341 2345 0 0 0 0 0 0 13 LVecBase3d::y 0

3858 1 z 0 6 3521 2342 2346 0 0 0 0 0 0 13 LVecBase3d::z 0

3859 2 xy 0 2 3519 2347 0 0 0 0 0 0 0 14 LVecBase3d::xy 0

3860 2 xz 0 2 3519 2348 0 0 0 0 0 0 0 14 LVecBase3d::xz 0

3861 2 yz 0 2 3519 2349 0 0 0 0 0 0 0 14 LVecBase3d::yz 0

3862 1 x 0 6 3524 2413 2417 0 0 0 0 0 0 13 LVecBase3i::x 0

3863 1 y 0 6 3524 2414 2418 0 0 0 0 0 0 13 LVecBase3i::y 0

3864 1 z 0 6 3524 2415 2419 0 0 0 0 0 0 13 LVecBase3i::z 0

3865 2 xy 0 2 3522 2420 0 0 0 0 0 0 0 14 LVecBase3i::xy 0

3866 2 xz 0 2 3522 2421 0 0 0 0 0 0 0 14 LVecBase3i::xz 0

3867 2 yz 0 2 3522 2422 0 0 0 0 0 0 0 14 LVecBase3i::yz 0

3868 2 xy 0 2 3525 2476 0 0 0 0 0 0 0 13 LVector3f::xy 0

3869 2 xz 0 2 3525 2477 0 0 0 0 0 0 0 13 LVector3f::xz 0

3870 2 yz 0 2 3525 2478 0 0 0 0 0 0 0 13 LVector3f::yz 0

3871 2 xy 0 2 3526 2510 0 0 0 0 0 0 0 13 LVector3d::xy 0

3872 2 xz 0 2 3526 2511 0 0 0 0 0 0 0 13 LVector3d::xz 0

3873 2 yz 0 2 3526 2512 0 0 0 0 0 0 0 13 LVector3d::yz 0

3874 2 xy 0 2 3527 2544 0 0 0 0 0 0 0 13 LVector3i::xy 0

3875 2 xz 0 2 3527 2545 0 0 0 0 0 0 0 13 LVector3i::xz 0

3876 2 yz 0 2 3527 2546 0 0 0 0 0 0 0 13 LVector3i::yz 0

3877 2 xy 0 2 3528 2570 0 0 0 0 0 0 0 12 LPoint3f::xy 0

3878 2 xz 0 2 3528 2571 0 0 0 0 0 0 0 12 LPoint3f::xz 0

3879 2 yz 0 2 3528 2572 0 0 0 0 0 0 0 12 LPoint3f::yz 0

3880 2 xy 0 2 3529 2593 0 0 0 0 0 0 0 12 LPoint3d::xy 0

3881 2 xz 0 2 3529 2594 0 0 0 0 0 0 0 12 LPoint3d::xz 0

3882 2 yz 0 2 3529 2595 0 0 0 0 0 0 0 12 LPoint3d::yz 0

3883 2 xy 0 2 3530 2616 0 0 0 0 0 0 0 12 LPoint3i::xy 0

3884 2 xz 0 2 3530 2617 0 0 0 0 0 0 0 12 LPoint3i::xz 0

3885 2 yz 0 2 3530 2618 0 0 0 0 0 0 0 12 LPoint3i::yz 0

3886 1 x 0 6 3518 2648 2654 0 0 0 0 0 0 13 LVecBase4f::x 0

3887 1 y 0 6 3518 2649 2655 0 0 0 0 0 0 13 LVecBase4f::y 0

3888 1 z 0 6 3518 2650 2656 0 0 0 0 0 0 13 LVecBase4f::z 0

3889 3 xyz 0 2 3531 2652 0 0 0 0 0 0 0 15 LVecBase4f::xyz 0

3890 2 xy 0 2 3516 2653 0 0 0 0 0 0 0 14 LVecBase4f::xy 0

3891 1 x 0 6 3521 2733 2739 0 0 0 0 0 0 13 LVecBase4d::x 0

3892 1 y 0 6 3521 2734 2740 0 0 0 0 0 0 13 LVecBase4d::y 0

3893 1 z 0 6 3521 2735 2741 0 0 0 0 0 0 13 LVecBase4d::z 0

3894 3 xyz 0 2 3533 2737 0 0 0 0 0 0 0 15 LVecBase4d::xyz 0

3895 2 xy 0 2 3519 2738 0 0 0 0 0 0 0 14 LVecBase4d::xy 0

3896 1 x 0 6 3524 2818 2824 0 0 0 0 0 0 13 LVecBase4i::x 0

3897 1 y 0 6 3524 2819 2825 0 0 0 0 0 0 13 LVecBase4i::y 0

3898 1 z 0 6 3524 2820 2826 0 0 0 0 0 0 13 LVecBase4i::z 0

3899 3 xyz 0 2 3535 2822 0 0 0 0 0 0 0 15 LVecBase4i::xyz 0

3900 2 xy 0 2 3522 2823 0 0 0 0 0 0 0 14 LVecBase4i::xy 0

3901 3 xyz 0 2 3538 2889 0 0 0 0 0 0 0 14 LVector4f::xyz 0

3902 2 xy 0 2 3525 2890 0 0 0 0 0 0 0 13 LVector4f::xy 0

3903 3 xyz 0 2 3539 2909 0 0 0 0 0 0 0 14 LVector4d::xyz 0

3904 2 xy 0 2 3526 2910 0 0 0 0 0 0 0 13 LVector4d::xy 0

3905 3 xyz 0 2 3540 2929 0 0 0 0 0 0 0 14 LVector4i::xyz 0

3906 2 xy 0 2 3527 2930 0 0 0 0 0 0 0 13 LVector4i::xy 0

3907 3 xyz 0 2 3541 2947 0 0 0 0 0 0 0 13 LPoint4f::xyz 0

3908 2 xy 0 2 3528 2948 0 0 0 0 0 0 0 12 LPoint4f::xy 0

3909 3 xyz 0 2 3542 2967 0 0 0 0 0 0 0 13 LPoint4d::xyz 0

3910 2 xy 0 2 3529 2968 0 0 0 0 0 0 0 12 LPoint4d::xy 0

3911 3 xyz 0 2 3543 2987 0 0 0 0 0 0 0 13 LPoint4i::xyz 0

3912 2 xy 0 2 3530 2988 0 0 0 0 0 0 0 12 LPoint4i::xy 0

3913 4 rows 0 66 3531 3019 0 0 0 0 3016 0 0 15 LMatrix3f::rows 0

3914 4 cols 0 66 3531 3020 0 0 0 0 3016 0 0 15 LMatrix3f::cols 0

3915 4 rows 0 66 3544 3109 0 0 0 0 3106 0 0 15 LMatrix4f::rows 0

3916 4 cols 0 66 3544 3110 0 0 0 0 3106 0 0 15 LMatrix4f::cols 0

3917 4 rows 0 66 3533 3213 0 0 0 0 3210 0 0 15 LMatrix3d::rows 0

3918 4 cols 0 66 3533 3214 0 0 0 0 3210 0 0 15 LMatrix3d::cols 0

3919 4 rows 0 66 3548 3301 0 0 0 0 3298 0 0 15 LMatrix4d::rows 0

3920 4 cols 0 66 3548 3302 0 0 0 0 3298 0 0 15 LMatrix4d::cols 0

14
3921 8 get_rows 0 3016 3019 19 LMatrix3f::get_rows 0

3922 8 get_cols 0 3016 3020 19 LMatrix3f::get_cols 0

3923 9 get_col2s 0 3016 3022 20 LMatrix3f::get_col2s 0

3924 9 get_row2s 0 3016 3021 20 LMatrix3f::get_row2s 0

3925 8 get_rows 0 3106 3109 19 LMatrix4f::get_rows 0

3926 8 get_cols 0 3106 3110 19 LMatrix4f::get_cols 0

3927 9 get_row3s 0 3106 3111 20 LMatrix4f::get_row3s 0

3928 8 get_rows 0 3210 3213 19 LMatrix3d::get_rows 0

3929 8 get_cols 0 3210 3214 19 LMatrix3d::get_cols 0

3930 9 get_col2s 0 3210 3216 20 LMatrix3d::get_col2s 0

3931 9 get_row2s 0 3210 3215 20 LMatrix3d::get_row2s 0

3932 8 get_rows 0 3298 3301 19 LMatrix4d::get_rows 0

3933 8 get_cols 0 3298 3302 19 LMatrix4d::get_cols 0

3934 9 get_row3s 0 3298 3303 20 LMatrix4d::get_row3s 0

